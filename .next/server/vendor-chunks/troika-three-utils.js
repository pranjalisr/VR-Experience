"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/troika-three-utils";
exports.ids = ["vendor-chunks/troika-three-utils"];
exports.modules = {

/***/ "(ssr)/./node_modules/troika-three-utils/dist/troika-three-utils.esm.js":
/*!************************************************************************!*\
  !*** ./node_modules/troika-three-utils/dist/troika-three-utils.esm.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BezierMesh: () => (/* binding */ BezierMesh),\n/* harmony export */   createDerivedMaterial: () => (/* binding */ createDerivedMaterial),\n/* harmony export */   expandShaderIncludes: () => (/* binding */ expandShaderIncludes),\n/* harmony export */   getShaderUniformTypes: () => (/* binding */ getShaderUniformTypes),\n/* harmony export */   getShadersForMaterial: () => (/* binding */ getShadersForMaterial),\n/* harmony export */   invertMatrix4: () => (/* binding */ invertMatrix4),\n/* harmony export */   voidMainRegExp: () => (/* binding */ voidMainRegExp)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n\n\n/**\n * Regular expression for matching the `void main() {` opener line in GLSL.\n * @type {RegExp}\n */\nconst voidMainRegExp = /\\bvoid\\s+main\\s*\\(\\s*\\)\\s*{/g;\n\n/**\n * Recursively expands all `#include <xyz>` statements within string of shader code.\n * Copied from three's WebGLProgram#parseIncludes for external use.\n *\n * @param {string} source - The GLSL source code to evaluate\n * @return {string} The GLSL code with all includes expanded\n */\nfunction expandShaderIncludes( source ) {\n  const pattern = /^[ \\t]*#include +<([\\w\\d./]+)>/gm;\n  function replace(match, include) {\n    let chunk = three__WEBPACK_IMPORTED_MODULE_0__.ShaderChunk[include];\n    return chunk ? expandShaderIncludes(chunk) : match\n  }\n  return source.replace( pattern, replace )\n}\n\n/*\n * This is a direct copy of MathUtils.generateUUID from Three.js, to preserve compatibility with three\n * versions before 0.113.0 as it was changed from Math to MathUtils in that version.\n * https://github.com/mrdoob/three.js/blob/dd8b5aa3b270c17096b90945cd2d6d1b13aaec53/src/math/MathUtils.js#L16\n */\n\nconst _lut = [];\n\nfor (let i = 0; i < 256; i++) {\n  _lut[i] = (i < 16 ? '0' : '') + (i).toString(16);\n}\n\nfunction generateUUID() {\n\n  // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136\n\n  const d0 = Math.random() * 0xffffffff | 0;\n  const d1 = Math.random() * 0xffffffff | 0;\n  const d2 = Math.random() * 0xffffffff | 0;\n  const d3 = Math.random() * 0xffffffff | 0;\n  const uuid = _lut[d0 & 0xff] + _lut[d0 >> 8 & 0xff] + _lut[d0 >> 16 & 0xff] + _lut[d0 >> 24 & 0xff] + '-' +\n    _lut[d1 & 0xff] + _lut[d1 >> 8 & 0xff] + '-' + _lut[d1 >> 16 & 0x0f | 0x40] + _lut[d1 >> 24 & 0xff] + '-' +\n    _lut[d2 & 0x3f | 0x80] + _lut[d2 >> 8 & 0xff] + '-' + _lut[d2 >> 16 & 0xff] + _lut[d2 >> 24 & 0xff] +\n    _lut[d3 & 0xff] + _lut[d3 >> 8 & 0xff] + _lut[d3 >> 16 & 0xff] + _lut[d3 >> 24 & 0xff];\n\n  // .toUpperCase() here flattens concatenated strings to save heap memory space.\n  return uuid.toUpperCase()\n\n}\n\n// Local assign polyfill to avoid importing troika-core\nconst assign = Object.assign || function(/*target, ...sources*/) {\n  let target = arguments[0];\n  for (let i = 1, len = arguments.length; i < len; i++) {\n    let source = arguments[i];\n    if (source) {\n      for (let prop in source) {\n        if (Object.prototype.hasOwnProperty.call(source, prop)) {\n          target[prop] = source[prop];\n        }\n      }\n    }\n  }\n  return target\n};\n\n\nconst epoch = Date.now();\nconst CONSTRUCTOR_CACHE = new WeakMap();\nconst SHADER_UPGRADE_CACHE = new Map();\n\n// Material ids must be integers, but we can't access the increment from Three's `Material` module,\n// so let's choose a sufficiently large starting value that should theoretically never collide.\nlet materialInstanceId = 1e10;\n\n/**\n * A utility for creating a custom shader material derived from another material's\n * shaders. This allows you to inject custom shader logic and transforms into the\n * builtin ThreeJS materials without having to recreate them from scratch.\n *\n * @param {THREE.Material} baseMaterial - the original material to derive from\n *\n * @param {Object} options - How the base material should be modified.\n * @param {Object=} options.defines - Custom `defines` for the material\n * @param {Object=} options.extensions - Custom `extensions` for the material, e.g. `{derivatives: true}`\n * @param {Object=} options.uniforms - Custom `uniforms` for use in the modified shader. These can\n *        be accessed and manipulated via the resulting material's `uniforms` property, just like\n *        in a ShaderMaterial. You do not need to repeat the base material's own uniforms here.\n * @param {String=} options.timeUniform - If specified, a uniform of this name will be injected into\n *        both shaders, and it will automatically be updated on each render frame with a number of\n *        elapsed milliseconds. The \"zero\" epoch time is not significant so don't rely on this as a\n *        true calendar time.\n * @param {String=} options.vertexDefs - Custom GLSL code to inject into the vertex shader's top-level\n *        definitions, above the `void main()` function.\n * @param {String=} options.vertexMainIntro - Custom GLSL code to inject at the top of the vertex\n *        shader's `void main` function.\n * @param {String=} options.vertexMainOutro - Custom GLSL code to inject at the end of the vertex\n *        shader's `void main` function.\n * @param {String=} options.vertexTransform - Custom GLSL code to manipulate the `position`, `normal`,\n *        and/or `uv` vertex attributes. This code will be wrapped within a standalone function with\n *        those attributes exposed by their normal names as read/write values.\n * @param {String=} options.fragmentDefs - Custom GLSL code to inject into the fragment shader's top-level\n *        definitions, above the `void main()` function.\n * @param {String=} options.fragmentMainIntro - Custom GLSL code to inject at the top of the fragment\n *        shader's `void main` function.\n * @param {String=} options.fragmentMainOutro - Custom GLSL code to inject at the end of the fragment\n *        shader's `void main` function. You can manipulate `gl_FragColor` here but keep in mind it goes\n *        after any of ThreeJS's color postprocessing shader chunks (tonemapping, fog, etc.), so if you\n *        want those to apply to your changes use `fragmentColorTransform` instead.\n * @param {String=} options.fragmentColorTransform - Custom GLSL code to manipulate the `gl_FragColor`\n *        output value. Will be injected near the end of the `void main` function, but before any\n *        of ThreeJS's color postprocessing shader chunks (tonemapping, fog, etc.), and before the\n *        `fragmentMainOutro`.\n * @param {function({fragmentShader: string, vertexShader:string}):\n *        {fragmentShader: string, vertexShader:string}} options.customRewriter - A function\n *        for performing custom rewrites of the full shader code. Useful if you need to do something\n *        special that's not covered by the other builtin options. This function will be executed before\n *        any other transforms are applied.\n * @param {boolean=} options.chained - Set to `true` to prototype-chain the derived material to the base\n *        material, rather than the default behavior of copying it. This allows the derived material to\n *        automatically pick up changes made to the base material and its properties. This can be useful\n *        where the derived material is hidden from the user as an implementation detail, allowing them\n *        to work with the original material like normal. But it can result in unexpected behavior if not\n *        handled carefully.\n *\n * @return {THREE.Material}\n *\n * The returned material will also have two new methods, `getDepthMaterial()` and `getDistanceMaterial()`,\n * which can be called to get a variant of the derived material for use in shadow casting. If the\n * target mesh is expected to cast shadows, then you can assign these to the mesh's `customDepthMaterial`\n * (for directional and spot lights) and/or `customDistanceMaterial` (for point lights) properties to\n * allow the cast shadow to honor your derived shader's vertex transforms and discarded fragments. These\n * will also set a custom `#define IS_DEPTH_MATERIAL` or `#define IS_DISTANCE_MATERIAL` that you can look\n * for in your derived shaders with `#ifdef` to customize their behavior for the depth or distance\n * scenarios, e.g. skipping antialiasing or expensive shader logic.\n */\nfunction createDerivedMaterial(baseMaterial, options) {\n  // Generate a key that is unique to the content of these `options`. We'll use this\n  // throughout for caching and for generating the upgraded shader code. This increases\n  // the likelihood that the resulting shaders will line up across multiple calls so\n  // their GL programs can be shared and cached.\n  const optionsKey = getKeyForOptions(options);\n\n  // First check to see if we've already derived from this baseMaterial using this\n  // unique set of options, and if so reuse the constructor to avoid some allocations.\n  let ctorsByDerivation = CONSTRUCTOR_CACHE.get(baseMaterial);\n  if (!ctorsByDerivation) {\n    CONSTRUCTOR_CACHE.set(baseMaterial, (ctorsByDerivation = Object.create(null)));\n  }\n  if (ctorsByDerivation[optionsKey]) {\n    return new ctorsByDerivation[optionsKey]()\n  }\n\n  const privateBeforeCompileProp = `_onBeforeCompile${optionsKey}`;\n\n  // Private onBeforeCompile handler that injects the modified shaders and uniforms when\n  // the renderer switches to this material's program\n  const onBeforeCompile = function (shaderInfo, renderer) {\n    baseMaterial.onBeforeCompile.call(this, shaderInfo, renderer);\n\n    // Upgrade the shaders, caching the result by incoming source code\n    const cacheKey = this.customProgramCacheKey() + '|' + shaderInfo.vertexShader + '|' + shaderInfo.fragmentShader;\n    let upgradedShaders = SHADER_UPGRADE_CACHE[cacheKey];\n    if (!upgradedShaders) {\n      const upgraded = upgradeShaders(this, shaderInfo, options, optionsKey);\n      upgradedShaders = SHADER_UPGRADE_CACHE[cacheKey] = upgraded;\n    }\n\n    // Inject upgraded shaders and uniforms into the program\n    shaderInfo.vertexShader = upgradedShaders.vertexShader;\n    shaderInfo.fragmentShader = upgradedShaders.fragmentShader;\n    assign(shaderInfo.uniforms, this.uniforms);\n\n    // Inject auto-updating time uniform if requested\n    if (options.timeUniform) {\n      shaderInfo.uniforms[options.timeUniform] = {\n        get value() {return Date.now() - epoch}\n      };\n    }\n\n    // Users can still add their own handlers on top of ours\n    if (this[privateBeforeCompileProp]) {\n      this[privateBeforeCompileProp](shaderInfo);\n    }\n  };\n\n  const DerivedMaterial = function DerivedMaterial() {\n    return derive(options.chained ? baseMaterial : baseMaterial.clone())\n  };\n\n  const derive = function(base) {\n    // Prototype chain to the base material\n    const derived = Object.create(base, descriptor);\n\n    // Store the baseMaterial for reference; this is always the original even when cloning\n    Object.defineProperty(derived, 'baseMaterial', { value: baseMaterial });\n\n    // Needs its own ids\n    Object.defineProperty(derived, 'id', { value: materialInstanceId++ });\n    derived.uuid = generateUUID();\n\n    // Merge uniforms, defines, and extensions\n    derived.uniforms = assign({}, base.uniforms, options.uniforms);\n    derived.defines = assign({}, base.defines, options.defines);\n    derived.defines[`TROIKA_DERIVED_MATERIAL_${optionsKey}`] = ''; //force a program change from the base material\n    derived.extensions = assign({}, base.extensions, options.extensions);\n\n    // Don't inherit EventDispatcher listeners\n    derived._listeners = undefined;\n\n    return derived\n  };\n\n  const descriptor = {\n    constructor: {value: DerivedMaterial},\n    isDerivedMaterial: {value: true},\n\n    type: {\n      get: () => baseMaterial.type,\n      set: (value) => {baseMaterial.type = value;}\n    },\n\n    isDerivedFrom: {\n      writable: true,\n      configurable: true,\n      value: function (testMaterial) {\n        const base = this.baseMaterial;\n        return testMaterial === base || (base.isDerivedMaterial && base.isDerivedFrom(testMaterial)) || false\n      }\n    },\n\n    customProgramCacheKey: {\n      writable: true,\n      configurable: true,\n      value: function () {\n        return baseMaterial.customProgramCacheKey() + '|' + optionsKey\n      }\n    },\n\n    onBeforeCompile: {\n      get() {\n        return onBeforeCompile\n      },\n      set(fn) {\n        this[privateBeforeCompileProp] = fn;\n      }\n    },\n\n    copy: {\n      writable: true,\n      configurable: true,\n      value: function (source) {\n        baseMaterial.copy.call(this, source);\n        if (!baseMaterial.isShaderMaterial && !baseMaterial.isDerivedMaterial) {\n          assign(this.extensions, source.extensions);\n          assign(this.defines, source.defines);\n          assign(this.uniforms, three__WEBPACK_IMPORTED_MODULE_1__.UniformsUtils.clone(source.uniforms));\n        }\n        return this\n      }\n    },\n\n    clone: {\n      writable: true,\n      configurable: true,\n      value: function () {\n        const newBase = new baseMaterial.constructor();\n        return derive(newBase).copy(this)\n      }\n    },\n\n    /**\n     * Utility to get a MeshDepthMaterial that will honor this derived material's vertex\n     * transformations and discarded fragments.\n     */\n    getDepthMaterial: {\n      writable: true,\n      configurable: true,\n      value: function() {\n        let depthMaterial = this._depthMaterial;\n        if (!depthMaterial) {\n          depthMaterial = this._depthMaterial = createDerivedMaterial(\n            baseMaterial.isDerivedMaterial\n              ? baseMaterial.getDepthMaterial()\n              : new three__WEBPACK_IMPORTED_MODULE_1__.MeshDepthMaterial({ depthPacking: three__WEBPACK_IMPORTED_MODULE_1__.RGBADepthPacking }),\n            options\n          );\n          depthMaterial.defines.IS_DEPTH_MATERIAL = '';\n          depthMaterial.uniforms = this.uniforms; //automatically recieve same uniform values\n        }\n        return depthMaterial\n      }\n    },\n\n    /**\n     * Utility to get a MeshDistanceMaterial that will honor this derived material's vertex\n     * transformations and discarded fragments.\n     */\n    getDistanceMaterial: {\n      writable: true,\n      configurable: true,\n      value: function() {\n        let distanceMaterial = this._distanceMaterial;\n        if (!distanceMaterial) {\n          distanceMaterial = this._distanceMaterial = createDerivedMaterial(\n            baseMaterial.isDerivedMaterial\n              ? baseMaterial.getDistanceMaterial()\n              : new three__WEBPACK_IMPORTED_MODULE_1__.MeshDistanceMaterial(),\n            options\n          );\n          distanceMaterial.defines.IS_DISTANCE_MATERIAL = '';\n          distanceMaterial.uniforms = this.uniforms; //automatically recieve same uniform values\n        }\n        return distanceMaterial\n      }\n    },\n\n    dispose: {\n      writable: true,\n      configurable: true,\n      value() {\n        const {_depthMaterial, _distanceMaterial} = this;\n        if (_depthMaterial) _depthMaterial.dispose();\n        if (_distanceMaterial) _distanceMaterial.dispose();\n        baseMaterial.dispose.call(this);\n      }\n    }\n  };\n\n  ctorsByDerivation[optionsKey] = DerivedMaterial;\n  return new DerivedMaterial()\n}\n\n\nfunction upgradeShaders(material, {vertexShader, fragmentShader}, options, key) {\n  let {\n    vertexDefs,\n    vertexMainIntro,\n    vertexMainOutro,\n    vertexTransform,\n    fragmentDefs,\n    fragmentMainIntro,\n    fragmentMainOutro,\n    fragmentColorTransform,\n    customRewriter,\n    timeUniform\n  } = options;\n\n  vertexDefs = vertexDefs || '';\n  vertexMainIntro = vertexMainIntro || '';\n  vertexMainOutro = vertexMainOutro || '';\n  fragmentDefs = fragmentDefs || '';\n  fragmentMainIntro = fragmentMainIntro || '';\n  fragmentMainOutro = fragmentMainOutro || '';\n\n  // Expand includes if needed\n  if (vertexTransform || customRewriter) {\n    vertexShader = expandShaderIncludes(vertexShader);\n  }\n  if (fragmentColorTransform || customRewriter) {\n    // We need to be able to find postprocessing chunks after include expansion in order to\n    // put them after the fragmentColorTransform, so mark them with comments first. Even if\n    // this particular derivation doesn't have a fragmentColorTransform, other derivations may,\n    // so we still mark them.\n    fragmentShader = fragmentShader.replace(\n      /^[ \\t]*#include <((?:tonemapping|encodings|colorspace|fog|premultiplied_alpha|dithering)_fragment)>/gm,\n      '\\n//!BEGIN_POST_CHUNK $1\\n$&\\n//!END_POST_CHUNK\\n'\n    );\n    fragmentShader = expandShaderIncludes(fragmentShader);\n  }\n\n  // Apply custom rewriter function\n  if (customRewriter) {\n    let res = customRewriter({vertexShader, fragmentShader});\n    vertexShader = res.vertexShader;\n    fragmentShader = res.fragmentShader;\n  }\n\n  // The fragmentColorTransform needs to go before any postprocessing chunks, so extract\n  // those and re-insert them into the outro in the correct place:\n  if (fragmentColorTransform) {\n    let postChunks = [];\n    fragmentShader = fragmentShader.replace(\n      /^\\/\\/!BEGIN_POST_CHUNK[^]+?^\\/\\/!END_POST_CHUNK/gm, // [^]+? = non-greedy match of any chars including newlines\n      match => {\n        postChunks.push(match);\n        return ''\n      }\n    );\n    fragmentMainOutro = `${fragmentColorTransform}\\n${postChunks.join('\\n')}\\n${fragmentMainOutro}`;\n  }\n\n  // Inject auto-updating time uniform if requested\n  if (timeUniform) {\n    const code = `\\nuniform float ${timeUniform};\\n`;\n    vertexDefs = code + vertexDefs;\n    fragmentDefs = code + fragmentDefs;\n  }\n\n  // Inject a function for the vertexTransform and rename all usages of position/normal/uv\n  if (vertexTransform) {\n    // Hoist these defs to the very top so they work in other function defs\n    vertexShader = `vec3 troika_position_${key};\nvec3 troika_normal_${key};\nvec2 troika_uv_${key};\n${vertexShader}\n`;\n    vertexDefs = `${vertexDefs}\nvoid troikaVertexTransform${key}(inout vec3 position, inout vec3 normal, inout vec2 uv) {\n  ${vertexTransform}\n}\n`;\n    vertexMainIntro = `\ntroika_position_${key} = vec3(position);\ntroika_normal_${key} = vec3(normal);\ntroika_uv_${key} = vec2(uv);\ntroikaVertexTransform${key}(troika_position_${key}, troika_normal_${key}, troika_uv_${key});\n${vertexMainIntro}\n`;\n    vertexShader = vertexShader.replace(/\\b(position|normal|uv)\\b/g, (match, match1, index, fullStr) => {\n      return /\\battribute\\s+vec[23]\\s+$/.test(fullStr.substr(0, index)) ? match1 : `troika_${match1}_${key}`\n    });\n\n    // Three r152 introduced the MAP_UV token, replace it too if it's pointing to the main 'uv'\n    // Perhaps the other textures too going forward?\n    if (!(material.map && material.map.channel > 0)) {\n      vertexShader = vertexShader.replace(/\\bMAP_UV\\b/g, `troika_uv_${key}`);\n    }\n  }\n\n  // Inject defs and intro/outro snippets\n  vertexShader = injectIntoShaderCode(vertexShader, key, vertexDefs, vertexMainIntro, vertexMainOutro);\n  fragmentShader = injectIntoShaderCode(fragmentShader, key, fragmentDefs, fragmentMainIntro, fragmentMainOutro);\n\n  return {\n    vertexShader,\n    fragmentShader\n  }\n}\n\nfunction injectIntoShaderCode(shaderCode, id, defs, intro, outro) {\n  if (intro || outro || defs) {\n    shaderCode = shaderCode.replace(voidMainRegExp, `\n${defs}\nvoid troikaOrigMain${id}() {`\n    );\n    shaderCode += `\nvoid main() {\n  ${intro}\n  troikaOrigMain${id}();\n  ${outro}\n}`;\n  }\n  return shaderCode\n}\n\n\nfunction optionsJsonReplacer(key, value) {\n  return key === 'uniforms' ? undefined : typeof value === 'function' ? value.toString() : value\n}\n\nlet _idCtr = 0;\nconst optionsHashesToIds = new Map();\nfunction getKeyForOptions(options) {\n  const optionsHash = JSON.stringify(options, optionsJsonReplacer);\n  let id = optionsHashesToIds.get(optionsHash);\n  if (id == null) {\n    optionsHashesToIds.set(optionsHash, (id = ++_idCtr));\n  }\n  return id\n}\n\n// Copied from threejs WebGLPrograms.js so we can resolve builtin materials to their shaders\n// TODO how can we keep this from getting stale?\nconst MATERIAL_TYPES_TO_SHADERS = {\n  MeshDepthMaterial: 'depth',\n  MeshDistanceMaterial: 'distanceRGBA',\n  MeshNormalMaterial: 'normal',\n  MeshBasicMaterial: 'basic',\n  MeshLambertMaterial: 'lambert',\n  MeshPhongMaterial: 'phong',\n  MeshToonMaterial: 'toon',\n  MeshStandardMaterial: 'physical',\n  MeshPhysicalMaterial: 'physical',\n  MeshMatcapMaterial: 'matcap',\n  LineBasicMaterial: 'basic',\n  LineDashedMaterial: 'dashed',\n  PointsMaterial: 'points',\n  ShadowMaterial: 'shadow',\n  SpriteMaterial: 'sprite'\n};\n\n/**\n * Given a Three.js `Material` instance, find the shaders/uniforms that will be\n * used to render that material.\n *\n * @param material - the Material instance\n * @return {object} - the material's shader info: `{uniforms:{}, fragmentShader:'', vertexShader:''}`\n */\nfunction getShadersForMaterial(material) {\n  let builtinType = MATERIAL_TYPES_TO_SHADERS[material.type];\n  return builtinType ? three__WEBPACK_IMPORTED_MODULE_0__.ShaderLib[builtinType] : material //TODO fallback for unknown type?\n}\n\n/**\n * Find all uniforms and their types within a shader code string.\n *\n * @param {string} shader - The shader code to parse\n * @return {object} mapping of uniform names to their glsl type\n */\nfunction getShaderUniformTypes(shader) {\n  let uniformRE = /\\buniform\\s+(int|float|vec[234]|mat[34])\\s+([A-Za-z_][\\w]*)/g;\n  let uniforms = Object.create(null);\n  let match;\n  while ((match = uniformRE.exec(shader)) !== null) {\n    uniforms[match[2]] = match[1];\n  }\n  return uniforms\n}\n\n/**\n * Helper for smoothing out the `m.getInverse(x)` --> `m.copy(x).invert()` conversion\n * that happened in ThreeJS r123.\n * @param {Matrix4} srcMatrix\n * @param {Matrix4} [tgtMatrix]\n */\nfunction invertMatrix4(srcMatrix, tgtMatrix = new three__WEBPACK_IMPORTED_MODULE_1__.Matrix4()) {\n  if (typeof tgtMatrix.invert === 'function') {\n    tgtMatrix.copy(srcMatrix).invert();\n  } else {\n    tgtMatrix.getInverse(srcMatrix);\n  }\n  return tgtMatrix\n}\n\n/*\nInput geometry is a cylinder with r=1, height in y dimension from 0 to 1,\ndivided into a reasonable number of height segments.\n*/\n\nconst vertexDefs = `\nuniform vec3 pointA;\nuniform vec3 controlA;\nuniform vec3 controlB;\nuniform vec3 pointB;\nuniform float radius;\nvarying float bezierT;\n\nvec3 cubicBezier(vec3 p1, vec3 c1, vec3 c2, vec3 p2, float t) {\n  float t2 = 1.0 - t;\n  float b0 = t2 * t2 * t2;\n  float b1 = 3.0 * t * t2 * t2;\n  float b2 = 3.0 * t * t * t2;\n  float b3 = t * t * t;\n  return b0 * p1 + b1 * c1 + b2 * c2 + b3 * p2;\n}\n\nvec3 cubicBezierDerivative(vec3 p1, vec3 c1, vec3 c2, vec3 p2, float t) {\n  float t2 = 1.0 - t;\n  return -3.0 * p1 * t2 * t2 +\n    c1 * (3.0 * t2 * t2 - 6.0 * t2 * t) +\n    c2 * (6.0 * t2 * t - 3.0 * t * t) +\n    3.0 * p2 * t * t;\n}\n`;\n\nconst vertexTransform = `\nfloat t = position.y;\nbezierT = t;\nvec3 bezierCenterPos = cubicBezier(pointA, controlA, controlB, pointB, t);\nvec3 bezierDir = normalize(cubicBezierDerivative(pointA, controlA, controlB, pointB, t));\n\n// Make \"sideways\" always perpendicular to the camera ray; this ensures that any twists\n// in the cylinder occur where you won't see them: \nvec3 viewDirection = normalMatrix * vec3(0.0, 0.0, 1.0);\nif (bezierDir == viewDirection) {\n  bezierDir = normalize(cubicBezierDerivative(pointA, controlA, controlB, pointB, t == 1.0 ? t - 0.0001 : t + 0.0001));\n}\nvec3 sideways = normalize(cross(bezierDir, viewDirection));\nvec3 upish = normalize(cross(sideways, bezierDir));\n\n// Build a matrix for transforming this disc in the cylinder:\nmat4 discTx;\ndiscTx[0].xyz = sideways * radius;\ndiscTx[1].xyz = bezierDir * radius;\ndiscTx[2].xyz = upish * radius;\ndiscTx[3].xyz = bezierCenterPos;\ndiscTx[3][3] = 1.0;\n\n// Apply transform, ignoring original y\nposition = (discTx * vec4(position.x, 0.0, position.z, 1.0)).xyz;\nnormal = normalize(mat3(discTx) * normal);\n`;\n\nconst fragmentDefs = `\nuniform vec3 dashing;\nvarying float bezierT;\n`;\n\nconst fragmentMainIntro = `\nif (dashing.x + dashing.y > 0.0) {\n  float dashFrac = mod(bezierT - dashing.z, dashing.x + dashing.y);\n  if (dashFrac > dashing.x) {\n    discard;\n  }\n}\n`;\n\n// Debugging: separate color for each of the 6 sides:\n// const fragmentColorTransform = `\n// float sideNum = floor(vUV.x * 6.0);\n// vec3 mixColor = sideNum < 1.0 ? vec3(1.0, 0.0, 0.0) :\n//   sideNum < 2.0 ? vec3(0.0, 1.0, 1.0) :\n//   sideNum < 3.0 ? vec3(1.0, 1.0, 0.0) :\n//   sideNum < 4.0 ? vec3(0.0, 0.0, 1.0) :\n//   sideNum < 5.0 ? vec3(0.0, 1.0, 0.0) :\n//   vec3(1.0, 0.0, 1.0);\n// gl_FragColor.xyz = mix(gl_FragColor.xyz, mixColor, 0.5);\n// `\n\n\n\nfunction createBezierMeshMaterial(baseMaterial) {\n  return createDerivedMaterial(\n    baseMaterial,\n    {\n      chained: true,\n      uniforms: {\n        pointA: {value: new three__WEBPACK_IMPORTED_MODULE_1__.Vector3()},\n        controlA: {value: new three__WEBPACK_IMPORTED_MODULE_1__.Vector3()},\n        controlB: {value: new three__WEBPACK_IMPORTED_MODULE_1__.Vector3()},\n        pointB: {value: new three__WEBPACK_IMPORTED_MODULE_1__.Vector3()},\n        radius: {value: 0.01},\n        dashing: {value: new three__WEBPACK_IMPORTED_MODULE_1__.Vector3()} //on, off, offset\n      },\n      vertexDefs,\n      vertexTransform,\n      fragmentDefs,\n      fragmentMainIntro\n    }\n  )\n}\n\nlet geometry = null;\n\nconst defaultBaseMaterial = /*#__PURE__*/new three__WEBPACK_IMPORTED_MODULE_1__.MeshStandardMaterial({color: 0xffffff, side: three__WEBPACK_IMPORTED_MODULE_1__.DoubleSide});\n\n\n/**\n * A ThreeJS `Mesh` that bends a tube shape along a 3D cubic bezier path. The bending is done\n * by deforming a straight cylindrical geometry in the vertex shader based on a set of four\n * control point uniforms. It patches the necessary GLSL into the mesh's assigned `material`\n * automatically.\n *\n * The cubiz bezier path is determined by its four `Vector3` properties:\n * - `pointA`\n * - `controlA`\n * - `controlB`\n * - `pointB`\n *\n * The tube's radius is controlled by its `radius` property, which defaults to `0.01`.\n *\n * You can also give the tube a dashed appearance with two properties:\n *\n * - `dashArray` - an array of two numbers, defining the length of \"on\" and \"off\" parts of\n *   the dash. Each is a 0-1 ratio of the entire path's length. (Actually this is the `t` length\n *   used as input to the cubic bezier function, not its visible length.)\n * - `dashOffset` - offset of where the dash starts. You can animate this to make the dashes move.\n *\n * Note that the dashes will appear like a hollow tube, not solid. This will be more apparent on\n * thicker tubes.\n *\n * TODO: proper geometry bounding sphere and raycasting\n * TODO: allow control of the geometry's segment counts\n */\nclass BezierMesh extends three__WEBPACK_IMPORTED_MODULE_1__.Mesh {\n  static getGeometry() {\n    return geometry || (geometry =\n      new three__WEBPACK_IMPORTED_MODULE_1__.CylinderGeometry(1, 1, 1, 6, 64).translate(0, 0.5, 0)\n    )\n  }\n\n  constructor() {\n    super(\n      BezierMesh.getGeometry(),\n      defaultBaseMaterial\n    );\n\n    this.pointA = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();\n    this.controlA = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();\n    this.controlB = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();\n    this.pointB = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();\n    this.radius = 0.01;\n    this.dashArray = new three__WEBPACK_IMPORTED_MODULE_1__.Vector2();\n    this.dashOffset = 0;\n\n    // TODO - disabling frustum culling until I figure out how to customize the\n    //  geometry's bounding sphere that gets used\n    this.frustumCulled = false;\n  }\n\n  // Handler for automatically wrapping the base material with our upgrades. We do the wrapping\n  // lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.\n  get material() {\n    let derivedMaterial = this._derivedMaterial;\n    const baseMaterial = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = defaultBaseMaterial.clone());\n    if (!derivedMaterial || derivedMaterial.baseMaterial !== baseMaterial) {\n      derivedMaterial = this._derivedMaterial = createBezierMeshMaterial(baseMaterial);\n      // dispose the derived material when its base material is disposed:\n      baseMaterial.addEventListener('dispose', function onDispose() {\n        baseMaterial.removeEventListener('dispose', onDispose);\n        derivedMaterial.dispose();\n      });\n    }\n    return derivedMaterial\n  }\n  set material(baseMaterial) {\n    this._baseMaterial = baseMaterial;\n  }\n\n  // Create and update material for shadows upon request:\n  get customDepthMaterial() {\n    return this.material.getDepthMaterial()\n  }\n  set customDepthMaterial(m) {\n    // future: let the user override with their own?\n  }\n  get customDistanceMaterial() {\n    return this.material.getDistanceMaterial()\n  }\n  set customDistanceMaterial(m) {\n    // future: let the user override with their own?\n  }\n\n  onBeforeRender() {\n    const {uniforms} = this.material;\n    const {pointA, controlA, controlB, pointB, radius, dashArray, dashOffset} = this;\n    uniforms.pointA.value.copy(pointA);\n    uniforms.controlA.value.copy(controlA);\n    uniforms.controlB.value.copy(controlB);\n    uniforms.pointB.value.copy(pointB);\n    uniforms.radius.value = radius;\n    uniforms.dashing.value.set(dashArray.x, dashArray.y, dashOffset || 0);\n  }\n\n  raycast(/*raycaster, intersects*/) {\n    // TODO - just fail for now\n  }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdHJvaWthLXRocmVlLXV0aWxzL2Rpc3QvdHJvaWthLXRocmVlLXV0aWxzLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBOE07O0FBRTlNO0FBQ0EscURBQXFEO0FBQ3JELFVBQVU7QUFDVjtBQUNBLG1EQUFtRDs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDhDQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFNBQVM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUyxrRUFBa0Usa0JBQWtCO0FBQ3hHLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVUsNENBQTRDO0FBQ2pFLFdBQVcsOENBQThDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNEQUFzRCxXQUFXOztBQUVqRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNkNBQTZDO0FBQzdDLHFEQUFxRCxxQkFBcUI7O0FBRTFFO0FBQ0EsMkNBQTJDLDZCQUE2QjtBQUN4RTs7QUFFQTtBQUNBLGdDQUFnQztBQUNoQywrQkFBK0I7QUFDL0IsK0NBQStDLFdBQVcsU0FBUztBQUNuRSxrQ0FBa0M7O0FBRWxDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQix1QkFBdUI7QUFDekMsd0JBQXdCLFlBQVk7O0FBRXBDO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGdEQUFhO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9EQUFpQixHQUFHLGNBQWMsbURBQWdCLEVBQUU7QUFDeEU7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdURBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQ0FBbUM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0EsbUNBQW1DLDZCQUE2QjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEIsNkJBQTZCO0FBQzNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHVCQUF1QixJQUFJLHNCQUFzQixJQUFJLGtCQUFrQjtBQUNsRzs7QUFFQTtBQUNBO0FBQ0Esb0NBQW9DLGFBQWE7QUFDakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQyxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLEVBQUU7QUFDRjtBQUNBLG9CQUFvQjtBQUNwQiw0QkFBNEIsSUFBSTtBQUNoQyxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLEtBQUs7QUFDdkIsZ0JBQWdCLEtBQUs7QUFDckIsWUFBWSxLQUFLO0FBQ2pCLHVCQUF1QixJQUFJLG1CQUFtQixJQUFJLGtCQUFrQixJQUFJLGNBQWMsSUFBSTtBQUMxRixFQUFFO0FBQ0Y7QUFDQTtBQUNBLDZGQUE2RixPQUFPLEdBQUcsSUFBSTtBQUMzRyxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxJQUFJO0FBQzFFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLHFCQUFxQixHQUFHLElBQUk7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLGtCQUFrQixHQUFHO0FBQ3JCLElBQUk7QUFDSixDQUFDO0FBQ0Q7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUSxnQ0FBZ0MsV0FBVyxxQ0FBcUM7QUFDcEc7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDRDQUFTO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQjtBQUNBLGtEQUFrRCwwQ0FBTztBQUN6RDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsV0FBVywwQ0FBTyxHQUFHO0FBQ3RDLG1CQUFtQixXQUFXLDBDQUFPLEdBQUc7QUFDeEMsbUJBQW1CLFdBQVcsMENBQU8sR0FBRztBQUN4QyxpQkFBaUIsV0FBVywwQ0FBTyxHQUFHO0FBQ3RDLGlCQUFpQixZQUFZO0FBQzdCLGtCQUFrQixXQUFXLDBDQUFPLElBQUk7QUFDeEMsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDZDQUE2Qyx1REFBb0IsRUFBRSx1QkFBdUIsNkNBQVUsQ0FBQzs7O0FBR3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1Q0FBSTtBQUM3QjtBQUNBO0FBQ0EsVUFBVSxtREFBZ0I7QUFDMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQiwwQ0FBTztBQUM3Qix3QkFBd0IsMENBQU87QUFDL0Isd0JBQXdCLDBDQUFPO0FBQy9CLHNCQUFzQiwwQ0FBTztBQUM3QjtBQUNBLHlCQUF5QiwwQ0FBTztBQUNoQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLG1FQUFtRTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL3Ryb2lrYS10aHJlZS11dGlscy9kaXN0L3Ryb2lrYS10aHJlZS11dGlscy5lc20uanM/YmQ5OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTaGFkZXJDaHVuaywgVW5pZm9ybXNVdGlscywgTWVzaERlcHRoTWF0ZXJpYWwsIFJHQkFEZXB0aFBhY2tpbmcsIE1lc2hEaXN0YW5jZU1hdGVyaWFsLCBTaGFkZXJMaWIsIE1hdHJpeDQsIFZlY3RvcjMsIE1lc2gsIEN5bGluZGVyR2VvbWV0cnksIFZlY3RvcjIsIE1lc2hTdGFuZGFyZE1hdGVyaWFsLCBEb3VibGVTaWRlIH0gZnJvbSAndGhyZWUnO1xuXG4vKipcbiAqIFJlZ3VsYXIgZXhwcmVzc2lvbiBmb3IgbWF0Y2hpbmcgdGhlIGB2b2lkIG1haW4oKSB7YCBvcGVuZXIgbGluZSBpbiBHTFNMLlxuICogQHR5cGUge1JlZ0V4cH1cbiAqL1xuY29uc3Qgdm9pZE1haW5SZWdFeHAgPSAvXFxidm9pZFxccyttYWluXFxzKlxcKFxccypcXClcXHMqey9nO1xuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IGV4cGFuZHMgYWxsIGAjaW5jbHVkZSA8eHl6PmAgc3RhdGVtZW50cyB3aXRoaW4gc3RyaW5nIG9mIHNoYWRlciBjb2RlLlxuICogQ29waWVkIGZyb20gdGhyZWUncyBXZWJHTFByb2dyYW0jcGFyc2VJbmNsdWRlcyBmb3IgZXh0ZXJuYWwgdXNlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2UgLSBUaGUgR0xTTCBzb3VyY2UgY29kZSB0byBldmFsdWF0ZVxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgR0xTTCBjb2RlIHdpdGggYWxsIGluY2x1ZGVzIGV4cGFuZGVkXG4gKi9cbmZ1bmN0aW9uIGV4cGFuZFNoYWRlckluY2x1ZGVzKCBzb3VyY2UgKSB7XG4gIGNvbnN0IHBhdHRlcm4gPSAvXlsgXFx0XSojaW5jbHVkZSArPChbXFx3XFxkLi9dKyk+L2dtO1xuICBmdW5jdGlvbiByZXBsYWNlKG1hdGNoLCBpbmNsdWRlKSB7XG4gICAgbGV0IGNodW5rID0gU2hhZGVyQ2h1bmtbaW5jbHVkZV07XG4gICAgcmV0dXJuIGNodW5rID8gZXhwYW5kU2hhZGVySW5jbHVkZXMoY2h1bmspIDogbWF0Y2hcbiAgfVxuICByZXR1cm4gc291cmNlLnJlcGxhY2UoIHBhdHRlcm4sIHJlcGxhY2UgKVxufVxuXG4vKlxuICogVGhpcyBpcyBhIGRpcmVjdCBjb3B5IG9mIE1hdGhVdGlscy5nZW5lcmF0ZVVVSUQgZnJvbSBUaHJlZS5qcywgdG8gcHJlc2VydmUgY29tcGF0aWJpbGl0eSB3aXRoIHRocmVlXG4gKiB2ZXJzaW9ucyBiZWZvcmUgMC4xMTMuMCBhcyBpdCB3YXMgY2hhbmdlZCBmcm9tIE1hdGggdG8gTWF0aFV0aWxzIGluIHRoYXQgdmVyc2lvbi5cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvYmxvYi9kZDhiNWFhM2IyNzBjMTcwOTZiOTA5NDVjZDJkNmQxYjEzYWFlYzUzL3NyYy9tYXRoL01hdGhVdGlscy5qcyNMMTZcbiAqL1xuXG5jb25zdCBfbHV0ID0gW107XG5cbmZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgX2x1dFtpXSA9IChpIDwgMTYgPyAnMCcgOiAnJykgKyAoaSkudG9TdHJpbmcoMTYpO1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZVVVSUQoKSB7XG5cbiAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMDUwMzQvaG93LXRvLWNyZWF0ZS1hLWd1aWQtdXVpZC1pbi1qYXZhc2NyaXB0LzIxOTYzMTM2IzIxOTYzMTM2XG5cbiAgY29uc3QgZDAgPSBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmZmZiB8IDA7XG4gIGNvbnN0IGQxID0gTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmZmYgfCAwO1xuICBjb25zdCBkMiA9IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZmZmIHwgMDtcbiAgY29uc3QgZDMgPSBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmZmZiB8IDA7XG4gIGNvbnN0IHV1aWQgPSBfbHV0W2QwICYgMHhmZl0gKyBfbHV0W2QwID4+IDggJiAweGZmXSArIF9sdXRbZDAgPj4gMTYgJiAweGZmXSArIF9sdXRbZDAgPj4gMjQgJiAweGZmXSArICctJyArXG4gICAgX2x1dFtkMSAmIDB4ZmZdICsgX2x1dFtkMSA+PiA4ICYgMHhmZl0gKyAnLScgKyBfbHV0W2QxID4+IDE2ICYgMHgwZiB8IDB4NDBdICsgX2x1dFtkMSA+PiAyNCAmIDB4ZmZdICsgJy0nICtcbiAgICBfbHV0W2QyICYgMHgzZiB8IDB4ODBdICsgX2x1dFtkMiA+PiA4ICYgMHhmZl0gKyAnLScgKyBfbHV0W2QyID4+IDE2ICYgMHhmZl0gKyBfbHV0W2QyID4+IDI0ICYgMHhmZl0gK1xuICAgIF9sdXRbZDMgJiAweGZmXSArIF9sdXRbZDMgPj4gOCAmIDB4ZmZdICsgX2x1dFtkMyA+PiAxNiAmIDB4ZmZdICsgX2x1dFtkMyA+PiAyNCAmIDB4ZmZdO1xuXG4gIC8vIC50b1VwcGVyQ2FzZSgpIGhlcmUgZmxhdHRlbnMgY29uY2F0ZW5hdGVkIHN0cmluZ3MgdG8gc2F2ZSBoZWFwIG1lbW9yeSBzcGFjZS5cbiAgcmV0dXJuIHV1aWQudG9VcHBlckNhc2UoKVxuXG59XG5cbi8vIExvY2FsIGFzc2lnbiBwb2x5ZmlsbCB0byBhdm9pZCBpbXBvcnRpbmcgdHJvaWthLWNvcmVcbmNvbnN0IGFzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24oLyp0YXJnZXQsIC4uLnNvdXJjZXMqLykge1xuICBsZXQgdGFyZ2V0ID0gYXJndW1lbnRzWzBdO1xuICBmb3IgKGxldCBpID0gMSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgbGV0IHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICBpZiAoc291cmNlKSB7XG4gICAgICBmb3IgKGxldCBwcm9wIGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwgcHJvcCkpIHtcbiAgICAgICAgICB0YXJnZXRbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhcmdldFxufTtcblxuXG5jb25zdCBlcG9jaCA9IERhdGUubm93KCk7XG5jb25zdCBDT05TVFJVQ1RPUl9DQUNIRSA9IG5ldyBXZWFrTWFwKCk7XG5jb25zdCBTSEFERVJfVVBHUkFERV9DQUNIRSA9IG5ldyBNYXAoKTtcblxuLy8gTWF0ZXJpYWwgaWRzIG11c3QgYmUgaW50ZWdlcnMsIGJ1dCB3ZSBjYW4ndCBhY2Nlc3MgdGhlIGluY3JlbWVudCBmcm9tIFRocmVlJ3MgYE1hdGVyaWFsYCBtb2R1bGUsXG4vLyBzbyBsZXQncyBjaG9vc2UgYSBzdWZmaWNpZW50bHkgbGFyZ2Ugc3RhcnRpbmcgdmFsdWUgdGhhdCBzaG91bGQgdGhlb3JldGljYWxseSBuZXZlciBjb2xsaWRlLlxubGV0IG1hdGVyaWFsSW5zdGFuY2VJZCA9IDFlMTA7XG5cbi8qKlxuICogQSB1dGlsaXR5IGZvciBjcmVhdGluZyBhIGN1c3RvbSBzaGFkZXIgbWF0ZXJpYWwgZGVyaXZlZCBmcm9tIGFub3RoZXIgbWF0ZXJpYWwnc1xuICogc2hhZGVycy4gVGhpcyBhbGxvd3MgeW91IHRvIGluamVjdCBjdXN0b20gc2hhZGVyIGxvZ2ljIGFuZCB0cmFuc2Zvcm1zIGludG8gdGhlXG4gKiBidWlsdGluIFRocmVlSlMgbWF0ZXJpYWxzIHdpdGhvdXQgaGF2aW5nIHRvIHJlY3JlYXRlIHRoZW0gZnJvbSBzY3JhdGNoLlxuICpcbiAqIEBwYXJhbSB7VEhSRUUuTWF0ZXJpYWx9IGJhc2VNYXRlcmlhbCAtIHRoZSBvcmlnaW5hbCBtYXRlcmlhbCB0byBkZXJpdmUgZnJvbVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gSG93IHRoZSBiYXNlIG1hdGVyaWFsIHNob3VsZCBiZSBtb2RpZmllZC5cbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9ucy5kZWZpbmVzIC0gQ3VzdG9tIGBkZWZpbmVzYCBmb3IgdGhlIG1hdGVyaWFsXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnMuZXh0ZW5zaW9ucyAtIEN1c3RvbSBgZXh0ZW5zaW9uc2AgZm9yIHRoZSBtYXRlcmlhbCwgZS5nLiBge2Rlcml2YXRpdmVzOiB0cnVlfWBcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9ucy51bmlmb3JtcyAtIEN1c3RvbSBgdW5pZm9ybXNgIGZvciB1c2UgaW4gdGhlIG1vZGlmaWVkIHNoYWRlci4gVGhlc2UgY2FuXG4gKiAgICAgICAgYmUgYWNjZXNzZWQgYW5kIG1hbmlwdWxhdGVkIHZpYSB0aGUgcmVzdWx0aW5nIG1hdGVyaWFsJ3MgYHVuaWZvcm1zYCBwcm9wZXJ0eSwganVzdCBsaWtlXG4gKiAgICAgICAgaW4gYSBTaGFkZXJNYXRlcmlhbC4gWW91IGRvIG5vdCBuZWVkIHRvIHJlcGVhdCB0aGUgYmFzZSBtYXRlcmlhbCdzIG93biB1bmlmb3JtcyBoZXJlLlxuICogQHBhcmFtIHtTdHJpbmc9fSBvcHRpb25zLnRpbWVVbmlmb3JtIC0gSWYgc3BlY2lmaWVkLCBhIHVuaWZvcm0gb2YgdGhpcyBuYW1lIHdpbGwgYmUgaW5qZWN0ZWQgaW50b1xuICogICAgICAgIGJvdGggc2hhZGVycywgYW5kIGl0IHdpbGwgYXV0b21hdGljYWxseSBiZSB1cGRhdGVkIG9uIGVhY2ggcmVuZGVyIGZyYW1lIHdpdGggYSBudW1iZXIgb2ZcbiAqICAgICAgICBlbGFwc2VkIG1pbGxpc2Vjb25kcy4gVGhlIFwiemVyb1wiIGVwb2NoIHRpbWUgaXMgbm90IHNpZ25pZmljYW50IHNvIGRvbid0IHJlbHkgb24gdGhpcyBhcyBhXG4gKiAgICAgICAgdHJ1ZSBjYWxlbmRhciB0aW1lLlxuICogQHBhcmFtIHtTdHJpbmc9fSBvcHRpb25zLnZlcnRleERlZnMgLSBDdXN0b20gR0xTTCBjb2RlIHRvIGluamVjdCBpbnRvIHRoZSB2ZXJ0ZXggc2hhZGVyJ3MgdG9wLWxldmVsXG4gKiAgICAgICAgZGVmaW5pdGlvbnMsIGFib3ZlIHRoZSBgdm9pZCBtYWluKClgIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtTdHJpbmc9fSBvcHRpb25zLnZlcnRleE1haW5JbnRybyAtIEN1c3RvbSBHTFNMIGNvZGUgdG8gaW5qZWN0IGF0IHRoZSB0b3Agb2YgdGhlIHZlcnRleFxuICogICAgICAgIHNoYWRlcidzIGB2b2lkIG1haW5gIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtTdHJpbmc9fSBvcHRpb25zLnZlcnRleE1haW5PdXRybyAtIEN1c3RvbSBHTFNMIGNvZGUgdG8gaW5qZWN0IGF0IHRoZSBlbmQgb2YgdGhlIHZlcnRleFxuICogICAgICAgIHNoYWRlcidzIGB2b2lkIG1haW5gIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtTdHJpbmc9fSBvcHRpb25zLnZlcnRleFRyYW5zZm9ybSAtIEN1c3RvbSBHTFNMIGNvZGUgdG8gbWFuaXB1bGF0ZSB0aGUgYHBvc2l0aW9uYCwgYG5vcm1hbGAsXG4gKiAgICAgICAgYW5kL29yIGB1dmAgdmVydGV4IGF0dHJpYnV0ZXMuIFRoaXMgY29kZSB3aWxsIGJlIHdyYXBwZWQgd2l0aGluIGEgc3RhbmRhbG9uZSBmdW5jdGlvbiB3aXRoXG4gKiAgICAgICAgdGhvc2UgYXR0cmlidXRlcyBleHBvc2VkIGJ5IHRoZWlyIG5vcm1hbCBuYW1lcyBhcyByZWFkL3dyaXRlIHZhbHVlcy5cbiAqIEBwYXJhbSB7U3RyaW5nPX0gb3B0aW9ucy5mcmFnbWVudERlZnMgLSBDdXN0b20gR0xTTCBjb2RlIHRvIGluamVjdCBpbnRvIHRoZSBmcmFnbWVudCBzaGFkZXIncyB0b3AtbGV2ZWxcbiAqICAgICAgICBkZWZpbml0aW9ucywgYWJvdmUgdGhlIGB2b2lkIG1haW4oKWAgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge1N0cmluZz19IG9wdGlvbnMuZnJhZ21lbnRNYWluSW50cm8gLSBDdXN0b20gR0xTTCBjb2RlIHRvIGluamVjdCBhdCB0aGUgdG9wIG9mIHRoZSBmcmFnbWVudFxuICogICAgICAgIHNoYWRlcidzIGB2b2lkIG1haW5gIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtTdHJpbmc9fSBvcHRpb25zLmZyYWdtZW50TWFpbk91dHJvIC0gQ3VzdG9tIEdMU0wgY29kZSB0byBpbmplY3QgYXQgdGhlIGVuZCBvZiB0aGUgZnJhZ21lbnRcbiAqICAgICAgICBzaGFkZXIncyBgdm9pZCBtYWluYCBmdW5jdGlvbi4gWW91IGNhbiBtYW5pcHVsYXRlIGBnbF9GcmFnQ29sb3JgIGhlcmUgYnV0IGtlZXAgaW4gbWluZCBpdCBnb2VzXG4gKiAgICAgICAgYWZ0ZXIgYW55IG9mIFRocmVlSlMncyBjb2xvciBwb3N0cHJvY2Vzc2luZyBzaGFkZXIgY2h1bmtzICh0b25lbWFwcGluZywgZm9nLCBldGMuKSwgc28gaWYgeW91XG4gKiAgICAgICAgd2FudCB0aG9zZSB0byBhcHBseSB0byB5b3VyIGNoYW5nZXMgdXNlIGBmcmFnbWVudENvbG9yVHJhbnNmb3JtYCBpbnN0ZWFkLlxuICogQHBhcmFtIHtTdHJpbmc9fSBvcHRpb25zLmZyYWdtZW50Q29sb3JUcmFuc2Zvcm0gLSBDdXN0b20gR0xTTCBjb2RlIHRvIG1hbmlwdWxhdGUgdGhlIGBnbF9GcmFnQ29sb3JgXG4gKiAgICAgICAgb3V0cHV0IHZhbHVlLiBXaWxsIGJlIGluamVjdGVkIG5lYXIgdGhlIGVuZCBvZiB0aGUgYHZvaWQgbWFpbmAgZnVuY3Rpb24sIGJ1dCBiZWZvcmUgYW55XG4gKiAgICAgICAgb2YgVGhyZWVKUydzIGNvbG9yIHBvc3Rwcm9jZXNzaW5nIHNoYWRlciBjaHVua3MgKHRvbmVtYXBwaW5nLCBmb2csIGV0Yy4pLCBhbmQgYmVmb3JlIHRoZVxuICogICAgICAgIGBmcmFnbWVudE1haW5PdXRyb2AuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHtmcmFnbWVudFNoYWRlcjogc3RyaW5nLCB2ZXJ0ZXhTaGFkZXI6c3RyaW5nfSk6XG4gKiAgICAgICAge2ZyYWdtZW50U2hhZGVyOiBzdHJpbmcsIHZlcnRleFNoYWRlcjpzdHJpbmd9fSBvcHRpb25zLmN1c3RvbVJld3JpdGVyIC0gQSBmdW5jdGlvblxuICogICAgICAgIGZvciBwZXJmb3JtaW5nIGN1c3RvbSByZXdyaXRlcyBvZiB0aGUgZnVsbCBzaGFkZXIgY29kZS4gVXNlZnVsIGlmIHlvdSBuZWVkIHRvIGRvIHNvbWV0aGluZ1xuICogICAgICAgIHNwZWNpYWwgdGhhdCdzIG5vdCBjb3ZlcmVkIGJ5IHRoZSBvdGhlciBidWlsdGluIG9wdGlvbnMuIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBleGVjdXRlZCBiZWZvcmVcbiAqICAgICAgICBhbnkgb3RoZXIgdHJhbnNmb3JtcyBhcmUgYXBwbGllZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdGlvbnMuY2hhaW5lZCAtIFNldCB0byBgdHJ1ZWAgdG8gcHJvdG90eXBlLWNoYWluIHRoZSBkZXJpdmVkIG1hdGVyaWFsIHRvIHRoZSBiYXNlXG4gKiAgICAgICAgbWF0ZXJpYWwsIHJhdGhlciB0aGFuIHRoZSBkZWZhdWx0IGJlaGF2aW9yIG9mIGNvcHlpbmcgaXQuIFRoaXMgYWxsb3dzIHRoZSBkZXJpdmVkIG1hdGVyaWFsIHRvXG4gKiAgICAgICAgYXV0b21hdGljYWxseSBwaWNrIHVwIGNoYW5nZXMgbWFkZSB0byB0aGUgYmFzZSBtYXRlcmlhbCBhbmQgaXRzIHByb3BlcnRpZXMuIFRoaXMgY2FuIGJlIHVzZWZ1bFxuICogICAgICAgIHdoZXJlIHRoZSBkZXJpdmVkIG1hdGVyaWFsIGlzIGhpZGRlbiBmcm9tIHRoZSB1c2VyIGFzIGFuIGltcGxlbWVudGF0aW9uIGRldGFpbCwgYWxsb3dpbmcgdGhlbVxuICogICAgICAgIHRvIHdvcmsgd2l0aCB0aGUgb3JpZ2luYWwgbWF0ZXJpYWwgbGlrZSBub3JtYWwuIEJ1dCBpdCBjYW4gcmVzdWx0IGluIHVuZXhwZWN0ZWQgYmVoYXZpb3IgaWYgbm90XG4gKiAgICAgICAgaGFuZGxlZCBjYXJlZnVsbHkuXG4gKlxuICogQHJldHVybiB7VEhSRUUuTWF0ZXJpYWx9XG4gKlxuICogVGhlIHJldHVybmVkIG1hdGVyaWFsIHdpbGwgYWxzbyBoYXZlIHR3byBuZXcgbWV0aG9kcywgYGdldERlcHRoTWF0ZXJpYWwoKWAgYW5kIGBnZXREaXN0YW5jZU1hdGVyaWFsKClgLFxuICogd2hpY2ggY2FuIGJlIGNhbGxlZCB0byBnZXQgYSB2YXJpYW50IG9mIHRoZSBkZXJpdmVkIG1hdGVyaWFsIGZvciB1c2UgaW4gc2hhZG93IGNhc3RpbmcuIElmIHRoZVxuICogdGFyZ2V0IG1lc2ggaXMgZXhwZWN0ZWQgdG8gY2FzdCBzaGFkb3dzLCB0aGVuIHlvdSBjYW4gYXNzaWduIHRoZXNlIHRvIHRoZSBtZXNoJ3MgYGN1c3RvbURlcHRoTWF0ZXJpYWxgXG4gKiAoZm9yIGRpcmVjdGlvbmFsIGFuZCBzcG90IGxpZ2h0cykgYW5kL29yIGBjdXN0b21EaXN0YW5jZU1hdGVyaWFsYCAoZm9yIHBvaW50IGxpZ2h0cykgcHJvcGVydGllcyB0b1xuICogYWxsb3cgdGhlIGNhc3Qgc2hhZG93IHRvIGhvbm9yIHlvdXIgZGVyaXZlZCBzaGFkZXIncyB2ZXJ0ZXggdHJhbnNmb3JtcyBhbmQgZGlzY2FyZGVkIGZyYWdtZW50cy4gVGhlc2VcbiAqIHdpbGwgYWxzbyBzZXQgYSBjdXN0b20gYCNkZWZpbmUgSVNfREVQVEhfTUFURVJJQUxgIG9yIGAjZGVmaW5lIElTX0RJU1RBTkNFX01BVEVSSUFMYCB0aGF0IHlvdSBjYW4gbG9va1xuICogZm9yIGluIHlvdXIgZGVyaXZlZCBzaGFkZXJzIHdpdGggYCNpZmRlZmAgdG8gY3VzdG9taXplIHRoZWlyIGJlaGF2aW9yIGZvciB0aGUgZGVwdGggb3IgZGlzdGFuY2VcbiAqIHNjZW5hcmlvcywgZS5nLiBza2lwcGluZyBhbnRpYWxpYXNpbmcgb3IgZXhwZW5zaXZlIHNoYWRlciBsb2dpYy5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRGVyaXZlZE1hdGVyaWFsKGJhc2VNYXRlcmlhbCwgb3B0aW9ucykge1xuICAvLyBHZW5lcmF0ZSBhIGtleSB0aGF0IGlzIHVuaXF1ZSB0byB0aGUgY29udGVudCBvZiB0aGVzZSBgb3B0aW9uc2AuIFdlJ2xsIHVzZSB0aGlzXG4gIC8vIHRocm91Z2hvdXQgZm9yIGNhY2hpbmcgYW5kIGZvciBnZW5lcmF0aW5nIHRoZSB1cGdyYWRlZCBzaGFkZXIgY29kZS4gVGhpcyBpbmNyZWFzZXNcbiAgLy8gdGhlIGxpa2VsaWhvb2QgdGhhdCB0aGUgcmVzdWx0aW5nIHNoYWRlcnMgd2lsbCBsaW5lIHVwIGFjcm9zcyBtdWx0aXBsZSBjYWxscyBzb1xuICAvLyB0aGVpciBHTCBwcm9ncmFtcyBjYW4gYmUgc2hhcmVkIGFuZCBjYWNoZWQuXG4gIGNvbnN0IG9wdGlvbnNLZXkgPSBnZXRLZXlGb3JPcHRpb25zKG9wdGlvbnMpO1xuXG4gIC8vIEZpcnN0IGNoZWNrIHRvIHNlZSBpZiB3ZSd2ZSBhbHJlYWR5IGRlcml2ZWQgZnJvbSB0aGlzIGJhc2VNYXRlcmlhbCB1c2luZyB0aGlzXG4gIC8vIHVuaXF1ZSBzZXQgb2Ygb3B0aW9ucywgYW5kIGlmIHNvIHJldXNlIHRoZSBjb25zdHJ1Y3RvciB0byBhdm9pZCBzb21lIGFsbG9jYXRpb25zLlxuICBsZXQgY3RvcnNCeURlcml2YXRpb24gPSBDT05TVFJVQ1RPUl9DQUNIRS5nZXQoYmFzZU1hdGVyaWFsKTtcbiAgaWYgKCFjdG9yc0J5RGVyaXZhdGlvbikge1xuICAgIENPTlNUUlVDVE9SX0NBQ0hFLnNldChiYXNlTWF0ZXJpYWwsIChjdG9yc0J5RGVyaXZhdGlvbiA9IE9iamVjdC5jcmVhdGUobnVsbCkpKTtcbiAgfVxuICBpZiAoY3RvcnNCeURlcml2YXRpb25bb3B0aW9uc0tleV0pIHtcbiAgICByZXR1cm4gbmV3IGN0b3JzQnlEZXJpdmF0aW9uW29wdGlvbnNLZXldKClcbiAgfVxuXG4gIGNvbnN0IHByaXZhdGVCZWZvcmVDb21waWxlUHJvcCA9IGBfb25CZWZvcmVDb21waWxlJHtvcHRpb25zS2V5fWA7XG5cbiAgLy8gUHJpdmF0ZSBvbkJlZm9yZUNvbXBpbGUgaGFuZGxlciB0aGF0IGluamVjdHMgdGhlIG1vZGlmaWVkIHNoYWRlcnMgYW5kIHVuaWZvcm1zIHdoZW5cbiAgLy8gdGhlIHJlbmRlcmVyIHN3aXRjaGVzIHRvIHRoaXMgbWF0ZXJpYWwncyBwcm9ncmFtXG4gIGNvbnN0IG9uQmVmb3JlQ29tcGlsZSA9IGZ1bmN0aW9uIChzaGFkZXJJbmZvLCByZW5kZXJlcikge1xuICAgIGJhc2VNYXRlcmlhbC5vbkJlZm9yZUNvbXBpbGUuY2FsbCh0aGlzLCBzaGFkZXJJbmZvLCByZW5kZXJlcik7XG5cbiAgICAvLyBVcGdyYWRlIHRoZSBzaGFkZXJzLCBjYWNoaW5nIHRoZSByZXN1bHQgYnkgaW5jb21pbmcgc291cmNlIGNvZGVcbiAgICBjb25zdCBjYWNoZUtleSA9IHRoaXMuY3VzdG9tUHJvZ3JhbUNhY2hlS2V5KCkgKyAnfCcgKyBzaGFkZXJJbmZvLnZlcnRleFNoYWRlciArICd8JyArIHNoYWRlckluZm8uZnJhZ21lbnRTaGFkZXI7XG4gICAgbGV0IHVwZ3JhZGVkU2hhZGVycyA9IFNIQURFUl9VUEdSQURFX0NBQ0hFW2NhY2hlS2V5XTtcbiAgICBpZiAoIXVwZ3JhZGVkU2hhZGVycykge1xuICAgICAgY29uc3QgdXBncmFkZWQgPSB1cGdyYWRlU2hhZGVycyh0aGlzLCBzaGFkZXJJbmZvLCBvcHRpb25zLCBvcHRpb25zS2V5KTtcbiAgICAgIHVwZ3JhZGVkU2hhZGVycyA9IFNIQURFUl9VUEdSQURFX0NBQ0hFW2NhY2hlS2V5XSA9IHVwZ3JhZGVkO1xuICAgIH1cblxuICAgIC8vIEluamVjdCB1cGdyYWRlZCBzaGFkZXJzIGFuZCB1bmlmb3JtcyBpbnRvIHRoZSBwcm9ncmFtXG4gICAgc2hhZGVySW5mby52ZXJ0ZXhTaGFkZXIgPSB1cGdyYWRlZFNoYWRlcnMudmVydGV4U2hhZGVyO1xuICAgIHNoYWRlckluZm8uZnJhZ21lbnRTaGFkZXIgPSB1cGdyYWRlZFNoYWRlcnMuZnJhZ21lbnRTaGFkZXI7XG4gICAgYXNzaWduKHNoYWRlckluZm8udW5pZm9ybXMsIHRoaXMudW5pZm9ybXMpO1xuXG4gICAgLy8gSW5qZWN0IGF1dG8tdXBkYXRpbmcgdGltZSB1bmlmb3JtIGlmIHJlcXVlc3RlZFxuICAgIGlmIChvcHRpb25zLnRpbWVVbmlmb3JtKSB7XG4gICAgICBzaGFkZXJJbmZvLnVuaWZvcm1zW29wdGlvbnMudGltZVVuaWZvcm1dID0ge1xuICAgICAgICBnZXQgdmFsdWUoKSB7cmV0dXJuIERhdGUubm93KCkgLSBlcG9jaH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gVXNlcnMgY2FuIHN0aWxsIGFkZCB0aGVpciBvd24gaGFuZGxlcnMgb24gdG9wIG9mIG91cnNcbiAgICBpZiAodGhpc1twcml2YXRlQmVmb3JlQ29tcGlsZVByb3BdKSB7XG4gICAgICB0aGlzW3ByaXZhdGVCZWZvcmVDb21waWxlUHJvcF0oc2hhZGVySW5mbyk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IERlcml2ZWRNYXRlcmlhbCA9IGZ1bmN0aW9uIERlcml2ZWRNYXRlcmlhbCgpIHtcbiAgICByZXR1cm4gZGVyaXZlKG9wdGlvbnMuY2hhaW5lZCA/IGJhc2VNYXRlcmlhbCA6IGJhc2VNYXRlcmlhbC5jbG9uZSgpKVxuICB9O1xuXG4gIGNvbnN0IGRlcml2ZSA9IGZ1bmN0aW9uKGJhc2UpIHtcbiAgICAvLyBQcm90b3R5cGUgY2hhaW4gdG8gdGhlIGJhc2UgbWF0ZXJpYWxcbiAgICBjb25zdCBkZXJpdmVkID0gT2JqZWN0LmNyZWF0ZShiYXNlLCBkZXNjcmlwdG9yKTtcblxuICAgIC8vIFN0b3JlIHRoZSBiYXNlTWF0ZXJpYWwgZm9yIHJlZmVyZW5jZTsgdGhpcyBpcyBhbHdheXMgdGhlIG9yaWdpbmFsIGV2ZW4gd2hlbiBjbG9uaW5nXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRlcml2ZWQsICdiYXNlTWF0ZXJpYWwnLCB7IHZhbHVlOiBiYXNlTWF0ZXJpYWwgfSk7XG5cbiAgICAvLyBOZWVkcyBpdHMgb3duIGlkc1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkZXJpdmVkLCAnaWQnLCB7IHZhbHVlOiBtYXRlcmlhbEluc3RhbmNlSWQrKyB9KTtcbiAgICBkZXJpdmVkLnV1aWQgPSBnZW5lcmF0ZVVVSUQoKTtcblxuICAgIC8vIE1lcmdlIHVuaWZvcm1zLCBkZWZpbmVzLCBhbmQgZXh0ZW5zaW9uc1xuICAgIGRlcml2ZWQudW5pZm9ybXMgPSBhc3NpZ24oe30sIGJhc2UudW5pZm9ybXMsIG9wdGlvbnMudW5pZm9ybXMpO1xuICAgIGRlcml2ZWQuZGVmaW5lcyA9IGFzc2lnbih7fSwgYmFzZS5kZWZpbmVzLCBvcHRpb25zLmRlZmluZXMpO1xuICAgIGRlcml2ZWQuZGVmaW5lc1tgVFJPSUtBX0RFUklWRURfTUFURVJJQUxfJHtvcHRpb25zS2V5fWBdID0gJyc7IC8vZm9yY2UgYSBwcm9ncmFtIGNoYW5nZSBmcm9tIHRoZSBiYXNlIG1hdGVyaWFsXG4gICAgZGVyaXZlZC5leHRlbnNpb25zID0gYXNzaWduKHt9LCBiYXNlLmV4dGVuc2lvbnMsIG9wdGlvbnMuZXh0ZW5zaW9ucyk7XG5cbiAgICAvLyBEb24ndCBpbmhlcml0IEV2ZW50RGlzcGF0Y2hlciBsaXN0ZW5lcnNcbiAgICBkZXJpdmVkLl9saXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbiAgICByZXR1cm4gZGVyaXZlZFxuICB9O1xuXG4gIGNvbnN0IGRlc2NyaXB0b3IgPSB7XG4gICAgY29uc3RydWN0b3I6IHt2YWx1ZTogRGVyaXZlZE1hdGVyaWFsfSxcbiAgICBpc0Rlcml2ZWRNYXRlcmlhbDoge3ZhbHVlOiB0cnVlfSxcblxuICAgIHR5cGU6IHtcbiAgICAgIGdldDogKCkgPT4gYmFzZU1hdGVyaWFsLnR5cGUsXG4gICAgICBzZXQ6ICh2YWx1ZSkgPT4ge2Jhc2VNYXRlcmlhbC50eXBlID0gdmFsdWU7fVxuICAgIH0sXG5cbiAgICBpc0Rlcml2ZWRGcm9tOiB7XG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiAodGVzdE1hdGVyaWFsKSB7XG4gICAgICAgIGNvbnN0IGJhc2UgPSB0aGlzLmJhc2VNYXRlcmlhbDtcbiAgICAgICAgcmV0dXJuIHRlc3RNYXRlcmlhbCA9PT0gYmFzZSB8fCAoYmFzZS5pc0Rlcml2ZWRNYXRlcmlhbCAmJiBiYXNlLmlzRGVyaXZlZEZyb20odGVzdE1hdGVyaWFsKSkgfHwgZmFsc2VcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgY3VzdG9tUHJvZ3JhbUNhY2hlS2V5OiB7XG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBiYXNlTWF0ZXJpYWwuY3VzdG9tUHJvZ3JhbUNhY2hlS2V5KCkgKyAnfCcgKyBvcHRpb25zS2V5XG4gICAgICB9XG4gICAgfSxcblxuICAgIG9uQmVmb3JlQ29tcGlsZToge1xuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gb25CZWZvcmVDb21waWxlXG4gICAgICB9LFxuICAgICAgc2V0KGZuKSB7XG4gICAgICAgIHRoaXNbcHJpdmF0ZUJlZm9yZUNvbXBpbGVQcm9wXSA9IGZuO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBjb3B5OiB7XG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgIGJhc2VNYXRlcmlhbC5jb3B5LmNhbGwodGhpcywgc291cmNlKTtcbiAgICAgICAgaWYgKCFiYXNlTWF0ZXJpYWwuaXNTaGFkZXJNYXRlcmlhbCAmJiAhYmFzZU1hdGVyaWFsLmlzRGVyaXZlZE1hdGVyaWFsKSB7XG4gICAgICAgICAgYXNzaWduKHRoaXMuZXh0ZW5zaW9ucywgc291cmNlLmV4dGVuc2lvbnMpO1xuICAgICAgICAgIGFzc2lnbih0aGlzLmRlZmluZXMsIHNvdXJjZS5kZWZpbmVzKTtcbiAgICAgICAgICBhc3NpZ24odGhpcy51bmlmb3JtcywgVW5pZm9ybXNVdGlscy5jbG9uZShzb3VyY2UudW5pZm9ybXMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBjbG9uZToge1xuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBuZXdCYXNlID0gbmV3IGJhc2VNYXRlcmlhbC5jb25zdHJ1Y3RvcigpO1xuICAgICAgICByZXR1cm4gZGVyaXZlKG5ld0Jhc2UpLmNvcHkodGhpcylcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXRpbGl0eSB0byBnZXQgYSBNZXNoRGVwdGhNYXRlcmlhbCB0aGF0IHdpbGwgaG9ub3IgdGhpcyBkZXJpdmVkIG1hdGVyaWFsJ3MgdmVydGV4XG4gICAgICogdHJhbnNmb3JtYXRpb25zIGFuZCBkaXNjYXJkZWQgZnJhZ21lbnRzLlxuICAgICAqL1xuICAgIGdldERlcHRoTWF0ZXJpYWw6IHtcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBsZXQgZGVwdGhNYXRlcmlhbCA9IHRoaXMuX2RlcHRoTWF0ZXJpYWw7XG4gICAgICAgIGlmICghZGVwdGhNYXRlcmlhbCkge1xuICAgICAgICAgIGRlcHRoTWF0ZXJpYWwgPSB0aGlzLl9kZXB0aE1hdGVyaWFsID0gY3JlYXRlRGVyaXZlZE1hdGVyaWFsKFxuICAgICAgICAgICAgYmFzZU1hdGVyaWFsLmlzRGVyaXZlZE1hdGVyaWFsXG4gICAgICAgICAgICAgID8gYmFzZU1hdGVyaWFsLmdldERlcHRoTWF0ZXJpYWwoKVxuICAgICAgICAgICAgICA6IG5ldyBNZXNoRGVwdGhNYXRlcmlhbCh7IGRlcHRoUGFja2luZzogUkdCQURlcHRoUGFja2luZyB9KSxcbiAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgICApO1xuICAgICAgICAgIGRlcHRoTWF0ZXJpYWwuZGVmaW5lcy5JU19ERVBUSF9NQVRFUklBTCA9ICcnO1xuICAgICAgICAgIGRlcHRoTWF0ZXJpYWwudW5pZm9ybXMgPSB0aGlzLnVuaWZvcm1zOyAvL2F1dG9tYXRpY2FsbHkgcmVjaWV2ZSBzYW1lIHVuaWZvcm0gdmFsdWVzXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlcHRoTWF0ZXJpYWxcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXRpbGl0eSB0byBnZXQgYSBNZXNoRGlzdGFuY2VNYXRlcmlhbCB0aGF0IHdpbGwgaG9ub3IgdGhpcyBkZXJpdmVkIG1hdGVyaWFsJ3MgdmVydGV4XG4gICAgICogdHJhbnNmb3JtYXRpb25zIGFuZCBkaXNjYXJkZWQgZnJhZ21lbnRzLlxuICAgICAqL1xuICAgIGdldERpc3RhbmNlTWF0ZXJpYWw6IHtcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBsZXQgZGlzdGFuY2VNYXRlcmlhbCA9IHRoaXMuX2Rpc3RhbmNlTWF0ZXJpYWw7XG4gICAgICAgIGlmICghZGlzdGFuY2VNYXRlcmlhbCkge1xuICAgICAgICAgIGRpc3RhbmNlTWF0ZXJpYWwgPSB0aGlzLl9kaXN0YW5jZU1hdGVyaWFsID0gY3JlYXRlRGVyaXZlZE1hdGVyaWFsKFxuICAgICAgICAgICAgYmFzZU1hdGVyaWFsLmlzRGVyaXZlZE1hdGVyaWFsXG4gICAgICAgICAgICAgID8gYmFzZU1hdGVyaWFsLmdldERpc3RhbmNlTWF0ZXJpYWwoKVxuICAgICAgICAgICAgICA6IG5ldyBNZXNoRGlzdGFuY2VNYXRlcmlhbCgpLFxuICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgICk7XG4gICAgICAgICAgZGlzdGFuY2VNYXRlcmlhbC5kZWZpbmVzLklTX0RJU1RBTkNFX01BVEVSSUFMID0gJyc7XG4gICAgICAgICAgZGlzdGFuY2VNYXRlcmlhbC51bmlmb3JtcyA9IHRoaXMudW5pZm9ybXM7IC8vYXV0b21hdGljYWxseSByZWNpZXZlIHNhbWUgdW5pZm9ybSB2YWx1ZXNcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGlzdGFuY2VNYXRlcmlhbFxuICAgICAgfVxuICAgIH0sXG5cbiAgICBkaXNwb3NlOiB7XG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlKCkge1xuICAgICAgICBjb25zdCB7X2RlcHRoTWF0ZXJpYWwsIF9kaXN0YW5jZU1hdGVyaWFsfSA9IHRoaXM7XG4gICAgICAgIGlmIChfZGVwdGhNYXRlcmlhbCkgX2RlcHRoTWF0ZXJpYWwuZGlzcG9zZSgpO1xuICAgICAgICBpZiAoX2Rpc3RhbmNlTWF0ZXJpYWwpIF9kaXN0YW5jZU1hdGVyaWFsLmRpc3Bvc2UoKTtcbiAgICAgICAgYmFzZU1hdGVyaWFsLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgY3RvcnNCeURlcml2YXRpb25bb3B0aW9uc0tleV0gPSBEZXJpdmVkTWF0ZXJpYWw7XG4gIHJldHVybiBuZXcgRGVyaXZlZE1hdGVyaWFsKClcbn1cblxuXG5mdW5jdGlvbiB1cGdyYWRlU2hhZGVycyhtYXRlcmlhbCwge3ZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXJ9LCBvcHRpb25zLCBrZXkpIHtcbiAgbGV0IHtcbiAgICB2ZXJ0ZXhEZWZzLFxuICAgIHZlcnRleE1haW5JbnRybyxcbiAgICB2ZXJ0ZXhNYWluT3V0cm8sXG4gICAgdmVydGV4VHJhbnNmb3JtLFxuICAgIGZyYWdtZW50RGVmcyxcbiAgICBmcmFnbWVudE1haW5JbnRybyxcbiAgICBmcmFnbWVudE1haW5PdXRybyxcbiAgICBmcmFnbWVudENvbG9yVHJhbnNmb3JtLFxuICAgIGN1c3RvbVJld3JpdGVyLFxuICAgIHRpbWVVbmlmb3JtXG4gIH0gPSBvcHRpb25zO1xuXG4gIHZlcnRleERlZnMgPSB2ZXJ0ZXhEZWZzIHx8ICcnO1xuICB2ZXJ0ZXhNYWluSW50cm8gPSB2ZXJ0ZXhNYWluSW50cm8gfHwgJyc7XG4gIHZlcnRleE1haW5PdXRybyA9IHZlcnRleE1haW5PdXRybyB8fCAnJztcbiAgZnJhZ21lbnREZWZzID0gZnJhZ21lbnREZWZzIHx8ICcnO1xuICBmcmFnbWVudE1haW5JbnRybyA9IGZyYWdtZW50TWFpbkludHJvIHx8ICcnO1xuICBmcmFnbWVudE1haW5PdXRybyA9IGZyYWdtZW50TWFpbk91dHJvIHx8ICcnO1xuXG4gIC8vIEV4cGFuZCBpbmNsdWRlcyBpZiBuZWVkZWRcbiAgaWYgKHZlcnRleFRyYW5zZm9ybSB8fCBjdXN0b21SZXdyaXRlcikge1xuICAgIHZlcnRleFNoYWRlciA9IGV4cGFuZFNoYWRlckluY2x1ZGVzKHZlcnRleFNoYWRlcik7XG4gIH1cbiAgaWYgKGZyYWdtZW50Q29sb3JUcmFuc2Zvcm0gfHwgY3VzdG9tUmV3cml0ZXIpIHtcbiAgICAvLyBXZSBuZWVkIHRvIGJlIGFibGUgdG8gZmluZCBwb3N0cHJvY2Vzc2luZyBjaHVua3MgYWZ0ZXIgaW5jbHVkZSBleHBhbnNpb24gaW4gb3JkZXIgdG9cbiAgICAvLyBwdXQgdGhlbSBhZnRlciB0aGUgZnJhZ21lbnRDb2xvclRyYW5zZm9ybSwgc28gbWFyayB0aGVtIHdpdGggY29tbWVudHMgZmlyc3QuIEV2ZW4gaWZcbiAgICAvLyB0aGlzIHBhcnRpY3VsYXIgZGVyaXZhdGlvbiBkb2Vzbid0IGhhdmUgYSBmcmFnbWVudENvbG9yVHJhbnNmb3JtLCBvdGhlciBkZXJpdmF0aW9ucyBtYXksXG4gICAgLy8gc28gd2Ugc3RpbGwgbWFyayB0aGVtLlxuICAgIGZyYWdtZW50U2hhZGVyID0gZnJhZ21lbnRTaGFkZXIucmVwbGFjZShcbiAgICAgIC9eWyBcXHRdKiNpbmNsdWRlIDwoKD86dG9uZW1hcHBpbmd8ZW5jb2RpbmdzfGNvbG9yc3BhY2V8Zm9nfHByZW11bHRpcGxpZWRfYWxwaGF8ZGl0aGVyaW5nKV9mcmFnbWVudCk+L2dtLFxuICAgICAgJ1xcbi8vIUJFR0lOX1BPU1RfQ0hVTksgJDFcXG4kJlxcbi8vIUVORF9QT1NUX0NIVU5LXFxuJ1xuICAgICk7XG4gICAgZnJhZ21lbnRTaGFkZXIgPSBleHBhbmRTaGFkZXJJbmNsdWRlcyhmcmFnbWVudFNoYWRlcik7XG4gIH1cblxuICAvLyBBcHBseSBjdXN0b20gcmV3cml0ZXIgZnVuY3Rpb25cbiAgaWYgKGN1c3RvbVJld3JpdGVyKSB7XG4gICAgbGV0IHJlcyA9IGN1c3RvbVJld3JpdGVyKHt2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyfSk7XG4gICAgdmVydGV4U2hhZGVyID0gcmVzLnZlcnRleFNoYWRlcjtcbiAgICBmcmFnbWVudFNoYWRlciA9IHJlcy5mcmFnbWVudFNoYWRlcjtcbiAgfVxuXG4gIC8vIFRoZSBmcmFnbWVudENvbG9yVHJhbnNmb3JtIG5lZWRzIHRvIGdvIGJlZm9yZSBhbnkgcG9zdHByb2Nlc3NpbmcgY2h1bmtzLCBzbyBleHRyYWN0XG4gIC8vIHRob3NlIGFuZCByZS1pbnNlcnQgdGhlbSBpbnRvIHRoZSBvdXRybyBpbiB0aGUgY29ycmVjdCBwbGFjZTpcbiAgaWYgKGZyYWdtZW50Q29sb3JUcmFuc2Zvcm0pIHtcbiAgICBsZXQgcG9zdENodW5rcyA9IFtdO1xuICAgIGZyYWdtZW50U2hhZGVyID0gZnJhZ21lbnRTaGFkZXIucmVwbGFjZShcbiAgICAgIC9eXFwvXFwvIUJFR0lOX1BPU1RfQ0hVTktbXl0rP15cXC9cXC8hRU5EX1BPU1RfQ0hVTksvZ20sIC8vIFteXSs/ID0gbm9uLWdyZWVkeSBtYXRjaCBvZiBhbnkgY2hhcnMgaW5jbHVkaW5nIG5ld2xpbmVzXG4gICAgICBtYXRjaCA9PiB7XG4gICAgICAgIHBvc3RDaHVua3MucHVzaChtYXRjaCk7XG4gICAgICAgIHJldHVybiAnJ1xuICAgICAgfVxuICAgICk7XG4gICAgZnJhZ21lbnRNYWluT3V0cm8gPSBgJHtmcmFnbWVudENvbG9yVHJhbnNmb3JtfVxcbiR7cG9zdENodW5rcy5qb2luKCdcXG4nKX1cXG4ke2ZyYWdtZW50TWFpbk91dHJvfWA7XG4gIH1cblxuICAvLyBJbmplY3QgYXV0by11cGRhdGluZyB0aW1lIHVuaWZvcm0gaWYgcmVxdWVzdGVkXG4gIGlmICh0aW1lVW5pZm9ybSkge1xuICAgIGNvbnN0IGNvZGUgPSBgXFxudW5pZm9ybSBmbG9hdCAke3RpbWVVbmlmb3JtfTtcXG5gO1xuICAgIHZlcnRleERlZnMgPSBjb2RlICsgdmVydGV4RGVmcztcbiAgICBmcmFnbWVudERlZnMgPSBjb2RlICsgZnJhZ21lbnREZWZzO1xuICB9XG5cbiAgLy8gSW5qZWN0IGEgZnVuY3Rpb24gZm9yIHRoZSB2ZXJ0ZXhUcmFuc2Zvcm0gYW5kIHJlbmFtZSBhbGwgdXNhZ2VzIG9mIHBvc2l0aW9uL25vcm1hbC91dlxuICBpZiAodmVydGV4VHJhbnNmb3JtKSB7XG4gICAgLy8gSG9pc3QgdGhlc2UgZGVmcyB0byB0aGUgdmVyeSB0b3Agc28gdGhleSB3b3JrIGluIG90aGVyIGZ1bmN0aW9uIGRlZnNcbiAgICB2ZXJ0ZXhTaGFkZXIgPSBgdmVjMyB0cm9pa2FfcG9zaXRpb25fJHtrZXl9O1xudmVjMyB0cm9pa2Ffbm9ybWFsXyR7a2V5fTtcbnZlYzIgdHJvaWthX3V2XyR7a2V5fTtcbiR7dmVydGV4U2hhZGVyfVxuYDtcbiAgICB2ZXJ0ZXhEZWZzID0gYCR7dmVydGV4RGVmc31cbnZvaWQgdHJvaWthVmVydGV4VHJhbnNmb3JtJHtrZXl9KGlub3V0IHZlYzMgcG9zaXRpb24sIGlub3V0IHZlYzMgbm9ybWFsLCBpbm91dCB2ZWMyIHV2KSB7XG4gICR7dmVydGV4VHJhbnNmb3JtfVxufVxuYDtcbiAgICB2ZXJ0ZXhNYWluSW50cm8gPSBgXG50cm9pa2FfcG9zaXRpb25fJHtrZXl9ID0gdmVjMyhwb3NpdGlvbik7XG50cm9pa2Ffbm9ybWFsXyR7a2V5fSA9IHZlYzMobm9ybWFsKTtcbnRyb2lrYV91dl8ke2tleX0gPSB2ZWMyKHV2KTtcbnRyb2lrYVZlcnRleFRyYW5zZm9ybSR7a2V5fSh0cm9pa2FfcG9zaXRpb25fJHtrZXl9LCB0cm9pa2Ffbm9ybWFsXyR7a2V5fSwgdHJvaWthX3V2XyR7a2V5fSk7XG4ke3ZlcnRleE1haW5JbnRyb31cbmA7XG4gICAgdmVydGV4U2hhZGVyID0gdmVydGV4U2hhZGVyLnJlcGxhY2UoL1xcYihwb3NpdGlvbnxub3JtYWx8dXYpXFxiL2csIChtYXRjaCwgbWF0Y2gxLCBpbmRleCwgZnVsbFN0cikgPT4ge1xuICAgICAgcmV0dXJuIC9cXGJhdHRyaWJ1dGVcXHMrdmVjWzIzXVxccyskLy50ZXN0KGZ1bGxTdHIuc3Vic3RyKDAsIGluZGV4KSkgPyBtYXRjaDEgOiBgdHJvaWthXyR7bWF0Y2gxfV8ke2tleX1gXG4gICAgfSk7XG5cbiAgICAvLyBUaHJlZSByMTUyIGludHJvZHVjZWQgdGhlIE1BUF9VViB0b2tlbiwgcmVwbGFjZSBpdCB0b28gaWYgaXQncyBwb2ludGluZyB0byB0aGUgbWFpbiAndXYnXG4gICAgLy8gUGVyaGFwcyB0aGUgb3RoZXIgdGV4dHVyZXMgdG9vIGdvaW5nIGZvcndhcmQ/XG4gICAgaWYgKCEobWF0ZXJpYWwubWFwICYmIG1hdGVyaWFsLm1hcC5jaGFubmVsID4gMCkpIHtcbiAgICAgIHZlcnRleFNoYWRlciA9IHZlcnRleFNoYWRlci5yZXBsYWNlKC9cXGJNQVBfVVZcXGIvZywgYHRyb2lrYV91dl8ke2tleX1gKTtcbiAgICB9XG4gIH1cblxuICAvLyBJbmplY3QgZGVmcyBhbmQgaW50cm8vb3V0cm8gc25pcHBldHNcbiAgdmVydGV4U2hhZGVyID0gaW5qZWN0SW50b1NoYWRlckNvZGUodmVydGV4U2hhZGVyLCBrZXksIHZlcnRleERlZnMsIHZlcnRleE1haW5JbnRybywgdmVydGV4TWFpbk91dHJvKTtcbiAgZnJhZ21lbnRTaGFkZXIgPSBpbmplY3RJbnRvU2hhZGVyQ29kZShmcmFnbWVudFNoYWRlciwga2V5LCBmcmFnbWVudERlZnMsIGZyYWdtZW50TWFpbkludHJvLCBmcmFnbWVudE1haW5PdXRybyk7XG5cbiAgcmV0dXJuIHtcbiAgICB2ZXJ0ZXhTaGFkZXIsXG4gICAgZnJhZ21lbnRTaGFkZXJcbiAgfVxufVxuXG5mdW5jdGlvbiBpbmplY3RJbnRvU2hhZGVyQ29kZShzaGFkZXJDb2RlLCBpZCwgZGVmcywgaW50cm8sIG91dHJvKSB7XG4gIGlmIChpbnRybyB8fCBvdXRybyB8fCBkZWZzKSB7XG4gICAgc2hhZGVyQ29kZSA9IHNoYWRlckNvZGUucmVwbGFjZSh2b2lkTWFpblJlZ0V4cCwgYFxuJHtkZWZzfVxudm9pZCB0cm9pa2FPcmlnTWFpbiR7aWR9KCkge2BcbiAgICApO1xuICAgIHNoYWRlckNvZGUgKz0gYFxudm9pZCBtYWluKCkge1xuICAke2ludHJvfVxuICB0cm9pa2FPcmlnTWFpbiR7aWR9KCk7XG4gICR7b3V0cm99XG59YDtcbiAgfVxuICByZXR1cm4gc2hhZGVyQ29kZVxufVxuXG5cbmZ1bmN0aW9uIG9wdGlvbnNKc29uUmVwbGFjZXIoa2V5LCB2YWx1ZSkge1xuICByZXR1cm4ga2V5ID09PSAndW5pZm9ybXMnID8gdW5kZWZpbmVkIDogdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nID8gdmFsdWUudG9TdHJpbmcoKSA6IHZhbHVlXG59XG5cbmxldCBfaWRDdHIgPSAwO1xuY29uc3Qgb3B0aW9uc0hhc2hlc1RvSWRzID0gbmV3IE1hcCgpO1xuZnVuY3Rpb24gZ2V0S2V5Rm9yT3B0aW9ucyhvcHRpb25zKSB7XG4gIGNvbnN0IG9wdGlvbnNIYXNoID0gSlNPTi5zdHJpbmdpZnkob3B0aW9ucywgb3B0aW9uc0pzb25SZXBsYWNlcik7XG4gIGxldCBpZCA9IG9wdGlvbnNIYXNoZXNUb0lkcy5nZXQob3B0aW9uc0hhc2gpO1xuICBpZiAoaWQgPT0gbnVsbCkge1xuICAgIG9wdGlvbnNIYXNoZXNUb0lkcy5zZXQob3B0aW9uc0hhc2gsIChpZCA9ICsrX2lkQ3RyKSk7XG4gIH1cbiAgcmV0dXJuIGlkXG59XG5cbi8vIENvcGllZCBmcm9tIHRocmVlanMgV2ViR0xQcm9ncmFtcy5qcyBzbyB3ZSBjYW4gcmVzb2x2ZSBidWlsdGluIG1hdGVyaWFscyB0byB0aGVpciBzaGFkZXJzXG4vLyBUT0RPIGhvdyBjYW4gd2Uga2VlcCB0aGlzIGZyb20gZ2V0dGluZyBzdGFsZT9cbmNvbnN0IE1BVEVSSUFMX1RZUEVTX1RPX1NIQURFUlMgPSB7XG4gIE1lc2hEZXB0aE1hdGVyaWFsOiAnZGVwdGgnLFxuICBNZXNoRGlzdGFuY2VNYXRlcmlhbDogJ2Rpc3RhbmNlUkdCQScsXG4gIE1lc2hOb3JtYWxNYXRlcmlhbDogJ25vcm1hbCcsXG4gIE1lc2hCYXNpY01hdGVyaWFsOiAnYmFzaWMnLFxuICBNZXNoTGFtYmVydE1hdGVyaWFsOiAnbGFtYmVydCcsXG4gIE1lc2hQaG9uZ01hdGVyaWFsOiAncGhvbmcnLFxuICBNZXNoVG9vbk1hdGVyaWFsOiAndG9vbicsXG4gIE1lc2hTdGFuZGFyZE1hdGVyaWFsOiAncGh5c2ljYWwnLFxuICBNZXNoUGh5c2ljYWxNYXRlcmlhbDogJ3BoeXNpY2FsJyxcbiAgTWVzaE1hdGNhcE1hdGVyaWFsOiAnbWF0Y2FwJyxcbiAgTGluZUJhc2ljTWF0ZXJpYWw6ICdiYXNpYycsXG4gIExpbmVEYXNoZWRNYXRlcmlhbDogJ2Rhc2hlZCcsXG4gIFBvaW50c01hdGVyaWFsOiAncG9pbnRzJyxcbiAgU2hhZG93TWF0ZXJpYWw6ICdzaGFkb3cnLFxuICBTcHJpdGVNYXRlcmlhbDogJ3Nwcml0ZSdcbn07XG5cbi8qKlxuICogR2l2ZW4gYSBUaHJlZS5qcyBgTWF0ZXJpYWxgIGluc3RhbmNlLCBmaW5kIHRoZSBzaGFkZXJzL3VuaWZvcm1zIHRoYXQgd2lsbCBiZVxuICogdXNlZCB0byByZW5kZXIgdGhhdCBtYXRlcmlhbC5cbiAqXG4gKiBAcGFyYW0gbWF0ZXJpYWwgLSB0aGUgTWF0ZXJpYWwgaW5zdGFuY2VcbiAqIEByZXR1cm4ge29iamVjdH0gLSB0aGUgbWF0ZXJpYWwncyBzaGFkZXIgaW5mbzogYHt1bmlmb3Jtczp7fSwgZnJhZ21lbnRTaGFkZXI6JycsIHZlcnRleFNoYWRlcjonJ31gXG4gKi9cbmZ1bmN0aW9uIGdldFNoYWRlcnNGb3JNYXRlcmlhbChtYXRlcmlhbCkge1xuICBsZXQgYnVpbHRpblR5cGUgPSBNQVRFUklBTF9UWVBFU19UT19TSEFERVJTW21hdGVyaWFsLnR5cGVdO1xuICByZXR1cm4gYnVpbHRpblR5cGUgPyBTaGFkZXJMaWJbYnVpbHRpblR5cGVdIDogbWF0ZXJpYWwgLy9UT0RPIGZhbGxiYWNrIGZvciB1bmtub3duIHR5cGU/XG59XG5cbi8qKlxuICogRmluZCBhbGwgdW5pZm9ybXMgYW5kIHRoZWlyIHR5cGVzIHdpdGhpbiBhIHNoYWRlciBjb2RlIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc2hhZGVyIC0gVGhlIHNoYWRlciBjb2RlIHRvIHBhcnNlXG4gKiBAcmV0dXJuIHtvYmplY3R9IG1hcHBpbmcgb2YgdW5pZm9ybSBuYW1lcyB0byB0aGVpciBnbHNsIHR5cGVcbiAqL1xuZnVuY3Rpb24gZ2V0U2hhZGVyVW5pZm9ybVR5cGVzKHNoYWRlcikge1xuICBsZXQgdW5pZm9ybVJFID0gL1xcYnVuaWZvcm1cXHMrKGludHxmbG9hdHx2ZWNbMjM0XXxtYXRbMzRdKVxccysoW0EtWmEtel9dW1xcd10qKS9nO1xuICBsZXQgdW5pZm9ybXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBsZXQgbWF0Y2g7XG4gIHdoaWxlICgobWF0Y2ggPSB1bmlmb3JtUkUuZXhlYyhzaGFkZXIpKSAhPT0gbnVsbCkge1xuICAgIHVuaWZvcm1zW21hdGNoWzJdXSA9IG1hdGNoWzFdO1xuICB9XG4gIHJldHVybiB1bmlmb3Jtc1xufVxuXG4vKipcbiAqIEhlbHBlciBmb3Igc21vb3RoaW5nIG91dCB0aGUgYG0uZ2V0SW52ZXJzZSh4KWAgLS0+IGBtLmNvcHkoeCkuaW52ZXJ0KClgIGNvbnZlcnNpb25cbiAqIHRoYXQgaGFwcGVuZWQgaW4gVGhyZWVKUyByMTIzLlxuICogQHBhcmFtIHtNYXRyaXg0fSBzcmNNYXRyaXhcbiAqIEBwYXJhbSB7TWF0cml4NH0gW3RndE1hdHJpeF1cbiAqL1xuZnVuY3Rpb24gaW52ZXJ0TWF0cml4NChzcmNNYXRyaXgsIHRndE1hdHJpeCA9IG5ldyBNYXRyaXg0KCkpIHtcbiAgaWYgKHR5cGVvZiB0Z3RNYXRyaXguaW52ZXJ0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGd0TWF0cml4LmNvcHkoc3JjTWF0cml4KS5pbnZlcnQoKTtcbiAgfSBlbHNlIHtcbiAgICB0Z3RNYXRyaXguZ2V0SW52ZXJzZShzcmNNYXRyaXgpO1xuICB9XG4gIHJldHVybiB0Z3RNYXRyaXhcbn1cblxuLypcbklucHV0IGdlb21ldHJ5IGlzIGEgY3lsaW5kZXIgd2l0aCByPTEsIGhlaWdodCBpbiB5IGRpbWVuc2lvbiBmcm9tIDAgdG8gMSxcbmRpdmlkZWQgaW50byBhIHJlYXNvbmFibGUgbnVtYmVyIG9mIGhlaWdodCBzZWdtZW50cy5cbiovXG5cbmNvbnN0IHZlcnRleERlZnMgPSBgXG51bmlmb3JtIHZlYzMgcG9pbnRBO1xudW5pZm9ybSB2ZWMzIGNvbnRyb2xBO1xudW5pZm9ybSB2ZWMzIGNvbnRyb2xCO1xudW5pZm9ybSB2ZWMzIHBvaW50QjtcbnVuaWZvcm0gZmxvYXQgcmFkaXVzO1xudmFyeWluZyBmbG9hdCBiZXppZXJUO1xuXG52ZWMzIGN1YmljQmV6aWVyKHZlYzMgcDEsIHZlYzMgYzEsIHZlYzMgYzIsIHZlYzMgcDIsIGZsb2F0IHQpIHtcbiAgZmxvYXQgdDIgPSAxLjAgLSB0O1xuICBmbG9hdCBiMCA9IHQyICogdDIgKiB0MjtcbiAgZmxvYXQgYjEgPSAzLjAgKiB0ICogdDIgKiB0MjtcbiAgZmxvYXQgYjIgPSAzLjAgKiB0ICogdCAqIHQyO1xuICBmbG9hdCBiMyA9IHQgKiB0ICogdDtcbiAgcmV0dXJuIGIwICogcDEgKyBiMSAqIGMxICsgYjIgKiBjMiArIGIzICogcDI7XG59XG5cbnZlYzMgY3ViaWNCZXppZXJEZXJpdmF0aXZlKHZlYzMgcDEsIHZlYzMgYzEsIHZlYzMgYzIsIHZlYzMgcDIsIGZsb2F0IHQpIHtcbiAgZmxvYXQgdDIgPSAxLjAgLSB0O1xuICByZXR1cm4gLTMuMCAqIHAxICogdDIgKiB0MiArXG4gICAgYzEgKiAoMy4wICogdDIgKiB0MiAtIDYuMCAqIHQyICogdCkgK1xuICAgIGMyICogKDYuMCAqIHQyICogdCAtIDMuMCAqIHQgKiB0KSArXG4gICAgMy4wICogcDIgKiB0ICogdDtcbn1cbmA7XG5cbmNvbnN0IHZlcnRleFRyYW5zZm9ybSA9IGBcbmZsb2F0IHQgPSBwb3NpdGlvbi55O1xuYmV6aWVyVCA9IHQ7XG52ZWMzIGJlemllckNlbnRlclBvcyA9IGN1YmljQmV6aWVyKHBvaW50QSwgY29udHJvbEEsIGNvbnRyb2xCLCBwb2ludEIsIHQpO1xudmVjMyBiZXppZXJEaXIgPSBub3JtYWxpemUoY3ViaWNCZXppZXJEZXJpdmF0aXZlKHBvaW50QSwgY29udHJvbEEsIGNvbnRyb2xCLCBwb2ludEIsIHQpKTtcblxuLy8gTWFrZSBcInNpZGV3YXlzXCIgYWx3YXlzIHBlcnBlbmRpY3VsYXIgdG8gdGhlIGNhbWVyYSByYXk7IHRoaXMgZW5zdXJlcyB0aGF0IGFueSB0d2lzdHNcbi8vIGluIHRoZSBjeWxpbmRlciBvY2N1ciB3aGVyZSB5b3Ugd29uJ3Qgc2VlIHRoZW06IFxudmVjMyB2aWV3RGlyZWN0aW9uID0gbm9ybWFsTWF0cml4ICogdmVjMygwLjAsIDAuMCwgMS4wKTtcbmlmIChiZXppZXJEaXIgPT0gdmlld0RpcmVjdGlvbikge1xuICBiZXppZXJEaXIgPSBub3JtYWxpemUoY3ViaWNCZXppZXJEZXJpdmF0aXZlKHBvaW50QSwgY29udHJvbEEsIGNvbnRyb2xCLCBwb2ludEIsIHQgPT0gMS4wID8gdCAtIDAuMDAwMSA6IHQgKyAwLjAwMDEpKTtcbn1cbnZlYzMgc2lkZXdheXMgPSBub3JtYWxpemUoY3Jvc3MoYmV6aWVyRGlyLCB2aWV3RGlyZWN0aW9uKSk7XG52ZWMzIHVwaXNoID0gbm9ybWFsaXplKGNyb3NzKHNpZGV3YXlzLCBiZXppZXJEaXIpKTtcblxuLy8gQnVpbGQgYSBtYXRyaXggZm9yIHRyYW5zZm9ybWluZyB0aGlzIGRpc2MgaW4gdGhlIGN5bGluZGVyOlxubWF0NCBkaXNjVHg7XG5kaXNjVHhbMF0ueHl6ID0gc2lkZXdheXMgKiByYWRpdXM7XG5kaXNjVHhbMV0ueHl6ID0gYmV6aWVyRGlyICogcmFkaXVzO1xuZGlzY1R4WzJdLnh5eiA9IHVwaXNoICogcmFkaXVzO1xuZGlzY1R4WzNdLnh5eiA9IGJlemllckNlbnRlclBvcztcbmRpc2NUeFszXVszXSA9IDEuMDtcblxuLy8gQXBwbHkgdHJhbnNmb3JtLCBpZ25vcmluZyBvcmlnaW5hbCB5XG5wb3NpdGlvbiA9IChkaXNjVHggKiB2ZWM0KHBvc2l0aW9uLngsIDAuMCwgcG9zaXRpb24ueiwgMS4wKSkueHl6O1xubm9ybWFsID0gbm9ybWFsaXplKG1hdDMoZGlzY1R4KSAqIG5vcm1hbCk7XG5gO1xuXG5jb25zdCBmcmFnbWVudERlZnMgPSBgXG51bmlmb3JtIHZlYzMgZGFzaGluZztcbnZhcnlpbmcgZmxvYXQgYmV6aWVyVDtcbmA7XG5cbmNvbnN0IGZyYWdtZW50TWFpbkludHJvID0gYFxuaWYgKGRhc2hpbmcueCArIGRhc2hpbmcueSA+IDAuMCkge1xuICBmbG9hdCBkYXNoRnJhYyA9IG1vZChiZXppZXJUIC0gZGFzaGluZy56LCBkYXNoaW5nLnggKyBkYXNoaW5nLnkpO1xuICBpZiAoZGFzaEZyYWMgPiBkYXNoaW5nLngpIHtcbiAgICBkaXNjYXJkO1xuICB9XG59XG5gO1xuXG4vLyBEZWJ1Z2dpbmc6IHNlcGFyYXRlIGNvbG9yIGZvciBlYWNoIG9mIHRoZSA2IHNpZGVzOlxuLy8gY29uc3QgZnJhZ21lbnRDb2xvclRyYW5zZm9ybSA9IGBcbi8vIGZsb2F0IHNpZGVOdW0gPSBmbG9vcih2VVYueCAqIDYuMCk7XG4vLyB2ZWMzIG1peENvbG9yID0gc2lkZU51bSA8IDEuMCA/IHZlYzMoMS4wLCAwLjAsIDAuMCkgOlxuLy8gICBzaWRlTnVtIDwgMi4wID8gdmVjMygwLjAsIDEuMCwgMS4wKSA6XG4vLyAgIHNpZGVOdW0gPCAzLjAgPyB2ZWMzKDEuMCwgMS4wLCAwLjApIDpcbi8vICAgc2lkZU51bSA8IDQuMCA/IHZlYzMoMC4wLCAwLjAsIDEuMCkgOlxuLy8gICBzaWRlTnVtIDwgNS4wID8gdmVjMygwLjAsIDEuMCwgMC4wKSA6XG4vLyAgIHZlYzMoMS4wLCAwLjAsIDEuMCk7XG4vLyBnbF9GcmFnQ29sb3IueHl6ID0gbWl4KGdsX0ZyYWdDb2xvci54eXosIG1peENvbG9yLCAwLjUpO1xuLy8gYFxuXG5cblxuZnVuY3Rpb24gY3JlYXRlQmV6aWVyTWVzaE1hdGVyaWFsKGJhc2VNYXRlcmlhbCkge1xuICByZXR1cm4gY3JlYXRlRGVyaXZlZE1hdGVyaWFsKFxuICAgIGJhc2VNYXRlcmlhbCxcbiAgICB7XG4gICAgICBjaGFpbmVkOiB0cnVlLFxuICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgcG9pbnRBOiB7dmFsdWU6IG5ldyBWZWN0b3IzKCl9LFxuICAgICAgICBjb250cm9sQToge3ZhbHVlOiBuZXcgVmVjdG9yMygpfSxcbiAgICAgICAgY29udHJvbEI6IHt2YWx1ZTogbmV3IFZlY3RvcjMoKX0sXG4gICAgICAgIHBvaW50Qjoge3ZhbHVlOiBuZXcgVmVjdG9yMygpfSxcbiAgICAgICAgcmFkaXVzOiB7dmFsdWU6IDAuMDF9LFxuICAgICAgICBkYXNoaW5nOiB7dmFsdWU6IG5ldyBWZWN0b3IzKCl9IC8vb24sIG9mZiwgb2Zmc2V0XG4gICAgICB9LFxuICAgICAgdmVydGV4RGVmcyxcbiAgICAgIHZlcnRleFRyYW5zZm9ybSxcbiAgICAgIGZyYWdtZW50RGVmcyxcbiAgICAgIGZyYWdtZW50TWFpbkludHJvXG4gICAgfVxuICApXG59XG5cbmxldCBnZW9tZXRyeSA9IG51bGw7XG5cbmNvbnN0IGRlZmF1bHRCYXNlTWF0ZXJpYWwgPSAvKiNfX1BVUkVfXyovbmV3IE1lc2hTdGFuZGFyZE1hdGVyaWFsKHtjb2xvcjogMHhmZmZmZmYsIHNpZGU6IERvdWJsZVNpZGV9KTtcblxuXG4vKipcbiAqIEEgVGhyZWVKUyBgTWVzaGAgdGhhdCBiZW5kcyBhIHR1YmUgc2hhcGUgYWxvbmcgYSAzRCBjdWJpYyBiZXppZXIgcGF0aC4gVGhlIGJlbmRpbmcgaXMgZG9uZVxuICogYnkgZGVmb3JtaW5nIGEgc3RyYWlnaHQgY3lsaW5kcmljYWwgZ2VvbWV0cnkgaW4gdGhlIHZlcnRleCBzaGFkZXIgYmFzZWQgb24gYSBzZXQgb2YgZm91clxuICogY29udHJvbCBwb2ludCB1bmlmb3Jtcy4gSXQgcGF0Y2hlcyB0aGUgbmVjZXNzYXJ5IEdMU0wgaW50byB0aGUgbWVzaCdzIGFzc2lnbmVkIGBtYXRlcmlhbGBcbiAqIGF1dG9tYXRpY2FsbHkuXG4gKlxuICogVGhlIGN1Yml6IGJlemllciBwYXRoIGlzIGRldGVybWluZWQgYnkgaXRzIGZvdXIgYFZlY3RvcjNgIHByb3BlcnRpZXM6XG4gKiAtIGBwb2ludEFgXG4gKiAtIGBjb250cm9sQWBcbiAqIC0gYGNvbnRyb2xCYFxuICogLSBgcG9pbnRCYFxuICpcbiAqIFRoZSB0dWJlJ3MgcmFkaXVzIGlzIGNvbnRyb2xsZWQgYnkgaXRzIGByYWRpdXNgIHByb3BlcnR5LCB3aGljaCBkZWZhdWx0cyB0byBgMC4wMWAuXG4gKlxuICogWW91IGNhbiBhbHNvIGdpdmUgdGhlIHR1YmUgYSBkYXNoZWQgYXBwZWFyYW5jZSB3aXRoIHR3byBwcm9wZXJ0aWVzOlxuICpcbiAqIC0gYGRhc2hBcnJheWAgLSBhbiBhcnJheSBvZiB0d28gbnVtYmVycywgZGVmaW5pbmcgdGhlIGxlbmd0aCBvZiBcIm9uXCIgYW5kIFwib2ZmXCIgcGFydHMgb2ZcbiAqICAgdGhlIGRhc2guIEVhY2ggaXMgYSAwLTEgcmF0aW8gb2YgdGhlIGVudGlyZSBwYXRoJ3MgbGVuZ3RoLiAoQWN0dWFsbHkgdGhpcyBpcyB0aGUgYHRgIGxlbmd0aFxuICogICB1c2VkIGFzIGlucHV0IHRvIHRoZSBjdWJpYyBiZXppZXIgZnVuY3Rpb24sIG5vdCBpdHMgdmlzaWJsZSBsZW5ndGguKVxuICogLSBgZGFzaE9mZnNldGAgLSBvZmZzZXQgb2Ygd2hlcmUgdGhlIGRhc2ggc3RhcnRzLiBZb3UgY2FuIGFuaW1hdGUgdGhpcyB0byBtYWtlIHRoZSBkYXNoZXMgbW92ZS5cbiAqXG4gKiBOb3RlIHRoYXQgdGhlIGRhc2hlcyB3aWxsIGFwcGVhciBsaWtlIGEgaG9sbG93IHR1YmUsIG5vdCBzb2xpZC4gVGhpcyB3aWxsIGJlIG1vcmUgYXBwYXJlbnQgb25cbiAqIHRoaWNrZXIgdHViZXMuXG4gKlxuICogVE9ETzogcHJvcGVyIGdlb21ldHJ5IGJvdW5kaW5nIHNwaGVyZSBhbmQgcmF5Y2FzdGluZ1xuICogVE9ETzogYWxsb3cgY29udHJvbCBvZiB0aGUgZ2VvbWV0cnkncyBzZWdtZW50IGNvdW50c1xuICovXG5jbGFzcyBCZXppZXJNZXNoIGV4dGVuZHMgTWVzaCB7XG4gIHN0YXRpYyBnZXRHZW9tZXRyeSgpIHtcbiAgICByZXR1cm4gZ2VvbWV0cnkgfHwgKGdlb21ldHJ5ID1cbiAgICAgIG5ldyBDeWxpbmRlckdlb21ldHJ5KDEsIDEsIDEsIDYsIDY0KS50cmFuc2xhdGUoMCwgMC41LCAwKVxuICAgIClcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFxuICAgICAgQmV6aWVyTWVzaC5nZXRHZW9tZXRyeSgpLFxuICAgICAgZGVmYXVsdEJhc2VNYXRlcmlhbFxuICAgICk7XG5cbiAgICB0aGlzLnBvaW50QSA9IG5ldyBWZWN0b3IzKCk7XG4gICAgdGhpcy5jb250cm9sQSA9IG5ldyBWZWN0b3IzKCk7XG4gICAgdGhpcy5jb250cm9sQiA9IG5ldyBWZWN0b3IzKCk7XG4gICAgdGhpcy5wb2ludEIgPSBuZXcgVmVjdG9yMygpO1xuICAgIHRoaXMucmFkaXVzID0gMC4wMTtcbiAgICB0aGlzLmRhc2hBcnJheSA9IG5ldyBWZWN0b3IyKCk7XG4gICAgdGhpcy5kYXNoT2Zmc2V0ID0gMDtcblxuICAgIC8vIFRPRE8gLSBkaXNhYmxpbmcgZnJ1c3R1bSBjdWxsaW5nIHVudGlsIEkgZmlndXJlIG91dCBob3cgdG8gY3VzdG9taXplIHRoZVxuICAgIC8vICBnZW9tZXRyeSdzIGJvdW5kaW5nIHNwaGVyZSB0aGF0IGdldHMgdXNlZFxuICAgIHRoaXMuZnJ1c3R1bUN1bGxlZCA9IGZhbHNlO1xuICB9XG5cbiAgLy8gSGFuZGxlciBmb3IgYXV0b21hdGljYWxseSB3cmFwcGluZyB0aGUgYmFzZSBtYXRlcmlhbCB3aXRoIG91ciB1cGdyYWRlcy4gV2UgZG8gdGhlIHdyYXBwaW5nXG4gIC8vIGxhemlseSBvbiBfcmVhZF8gcmF0aGVyIHRoYW4gd3JpdGUgdG8gYXZvaWQgdW5uZWNlc3Nhcnkgd3JhcHBpbmcgb24gdHJhbnNpZW50IHZhbHVlcy5cbiAgZ2V0IG1hdGVyaWFsKCkge1xuICAgIGxldCBkZXJpdmVkTWF0ZXJpYWwgPSB0aGlzLl9kZXJpdmVkTWF0ZXJpYWw7XG4gICAgY29uc3QgYmFzZU1hdGVyaWFsID0gdGhpcy5fYmFzZU1hdGVyaWFsIHx8IHRoaXMuX2RlZmF1bHRNYXRlcmlhbCB8fCAodGhpcy5fZGVmYXVsdE1hdGVyaWFsID0gZGVmYXVsdEJhc2VNYXRlcmlhbC5jbG9uZSgpKTtcbiAgICBpZiAoIWRlcml2ZWRNYXRlcmlhbCB8fCBkZXJpdmVkTWF0ZXJpYWwuYmFzZU1hdGVyaWFsICE9PSBiYXNlTWF0ZXJpYWwpIHtcbiAgICAgIGRlcml2ZWRNYXRlcmlhbCA9IHRoaXMuX2Rlcml2ZWRNYXRlcmlhbCA9IGNyZWF0ZUJlemllck1lc2hNYXRlcmlhbChiYXNlTWF0ZXJpYWwpO1xuICAgICAgLy8gZGlzcG9zZSB0aGUgZGVyaXZlZCBtYXRlcmlhbCB3aGVuIGl0cyBiYXNlIG1hdGVyaWFsIGlzIGRpc3Bvc2VkOlxuICAgICAgYmFzZU1hdGVyaWFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Rpc3Bvc2UnLCBmdW5jdGlvbiBvbkRpc3Bvc2UoKSB7XG4gICAgICAgIGJhc2VNYXRlcmlhbC5yZW1vdmVFdmVudExpc3RlbmVyKCdkaXNwb3NlJywgb25EaXNwb3NlKTtcbiAgICAgICAgZGVyaXZlZE1hdGVyaWFsLmRpc3Bvc2UoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZGVyaXZlZE1hdGVyaWFsXG4gIH1cbiAgc2V0IG1hdGVyaWFsKGJhc2VNYXRlcmlhbCkge1xuICAgIHRoaXMuX2Jhc2VNYXRlcmlhbCA9IGJhc2VNYXRlcmlhbDtcbiAgfVxuXG4gIC8vIENyZWF0ZSBhbmQgdXBkYXRlIG1hdGVyaWFsIGZvciBzaGFkb3dzIHVwb24gcmVxdWVzdDpcbiAgZ2V0IGN1c3RvbURlcHRoTWF0ZXJpYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0ZXJpYWwuZ2V0RGVwdGhNYXRlcmlhbCgpXG4gIH1cbiAgc2V0IGN1c3RvbURlcHRoTWF0ZXJpYWwobSkge1xuICAgIC8vIGZ1dHVyZTogbGV0IHRoZSB1c2VyIG92ZXJyaWRlIHdpdGggdGhlaXIgb3duP1xuICB9XG4gIGdldCBjdXN0b21EaXN0YW5jZU1hdGVyaWFsKCkge1xuICAgIHJldHVybiB0aGlzLm1hdGVyaWFsLmdldERpc3RhbmNlTWF0ZXJpYWwoKVxuICB9XG4gIHNldCBjdXN0b21EaXN0YW5jZU1hdGVyaWFsKG0pIHtcbiAgICAvLyBmdXR1cmU6IGxldCB0aGUgdXNlciBvdmVycmlkZSB3aXRoIHRoZWlyIG93bj9cbiAgfVxuXG4gIG9uQmVmb3JlUmVuZGVyKCkge1xuICAgIGNvbnN0IHt1bmlmb3Jtc30gPSB0aGlzLm1hdGVyaWFsO1xuICAgIGNvbnN0IHtwb2ludEEsIGNvbnRyb2xBLCBjb250cm9sQiwgcG9pbnRCLCByYWRpdXMsIGRhc2hBcnJheSwgZGFzaE9mZnNldH0gPSB0aGlzO1xuICAgIHVuaWZvcm1zLnBvaW50QS52YWx1ZS5jb3B5KHBvaW50QSk7XG4gICAgdW5pZm9ybXMuY29udHJvbEEudmFsdWUuY29weShjb250cm9sQSk7XG4gICAgdW5pZm9ybXMuY29udHJvbEIudmFsdWUuY29weShjb250cm9sQik7XG4gICAgdW5pZm9ybXMucG9pbnRCLnZhbHVlLmNvcHkocG9pbnRCKTtcbiAgICB1bmlmb3Jtcy5yYWRpdXMudmFsdWUgPSByYWRpdXM7XG4gICAgdW5pZm9ybXMuZGFzaGluZy52YWx1ZS5zZXQoZGFzaEFycmF5LngsIGRhc2hBcnJheS55LCBkYXNoT2Zmc2V0IHx8IDApO1xuICB9XG5cbiAgcmF5Y2FzdCgvKnJheWNhc3RlciwgaW50ZXJzZWN0cyovKSB7XG4gICAgLy8gVE9ETyAtIGp1c3QgZmFpbCBmb3Igbm93XG4gIH1cbn1cblxuZXhwb3J0IHsgQmV6aWVyTWVzaCwgY3JlYXRlRGVyaXZlZE1hdGVyaWFsLCBleHBhbmRTaGFkZXJJbmNsdWRlcywgZ2V0U2hhZGVyVW5pZm9ybVR5cGVzLCBnZXRTaGFkZXJzRm9yTWF0ZXJpYWwsIGludmVydE1hdHJpeDQsIHZvaWRNYWluUmVnRXhwIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/troika-three-utils/dist/troika-three-utils.esm.js\n");

/***/ })

};
;