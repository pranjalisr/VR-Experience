"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@react-three";
exports.ids = ["vendor-chunks/@react-three"];
exports.modules = {

/***/ "(ssr)/./node_modules/@react-three/drei/core/Environment.js":
/*!************************************************************!*\
  !*** ./node_modules/@react-three/drei/core/Environment.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Environment: () => (/* binding */ Environment),\n/* harmony export */   EnvironmentCube: () => (/* binding */ EnvironmentCube),\n/* harmony export */   EnvironmentMap: () => (/* binding */ EnvironmentMap),\n/* harmony export */   EnvironmentPortal: () => (/* binding */ EnvironmentPortal)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-three/fiber */ \"(ssr)/./node_modules/@react-three/fiber/dist/index-673ef987.esm.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n/* harmony import */ var three_stdlib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! three-stdlib */ \"(ssr)/./node_modules/three-stdlib/objects/GroundProjectedEnv.js\");\n/* harmony import */ var _useEnvironment_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./useEnvironment.js */ \"(ssr)/./node_modules/@react-three/drei/core/useEnvironment.js\");\n\n\n\n\n\n\nconst isRef = (obj)=>obj.current && obj.current.isScene;\nconst resolveScene = (scene)=>isRef(scene) ? scene.current : scene;\nfunction setEnvProps(background, scene, defaultScene, texture, sceneProps = {}) {\n    var _target$backgroundRot, _target$backgroundRot2, _target$environmentRo, _target$environmentRo2;\n    // defaults\n    sceneProps = {\n        backgroundBlurriness: 0,\n        backgroundIntensity: 1,\n        backgroundRotation: [\n            0,\n            0,\n            0\n        ],\n        environmentIntensity: 1,\n        environmentRotation: [\n            0,\n            0,\n            0\n        ],\n        ...sceneProps\n    };\n    const target = resolveScene(scene || defaultScene);\n    const oldbg = target.background;\n    const oldenv = target.environment;\n    const oldSceneProps = {\n        // @ts-ignore\n        backgroundBlurriness: target.backgroundBlurriness,\n        // @ts-ignore\n        backgroundIntensity: target.backgroundIntensity,\n        // @ts-ignore\n        backgroundRotation: (_target$backgroundRot = (_target$backgroundRot2 = target.backgroundRotation) == null || _target$backgroundRot2.clone == null ? void 0 : _target$backgroundRot2.clone()) !== null && _target$backgroundRot !== void 0 ? _target$backgroundRot : [\n            0,\n            0,\n            0\n        ],\n        // @ts-ignore\n        environmentIntensity: target.environmentIntensity,\n        // @ts-ignore\n        environmentRotation: (_target$environmentRo = (_target$environmentRo2 = target.environmentRotation) == null || _target$environmentRo2.clone == null ? void 0 : _target$environmentRo2.clone()) !== null && _target$environmentRo !== void 0 ? _target$environmentRo : [\n            0,\n            0,\n            0\n        ]\n    };\n    if (background !== \"only\") target.environment = texture;\n    if (background) target.background = texture;\n    (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.j)(target, sceneProps);\n    return ()=>{\n        if (background !== \"only\") target.environment = oldenv;\n        if (background) target.background = oldbg;\n        (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.j)(target, oldSceneProps);\n    };\n}\nfunction EnvironmentMap({ scene, background = false, map, ...config }) {\n    const defaultScene = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.z)((state)=>state.scene);\n    react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect(()=>{\n        if (map) return setEnvProps(background, scene, defaultScene, map, config);\n    });\n    return null;\n}\nfunction EnvironmentCube({ background = false, scene, blur, backgroundBlurriness, backgroundIntensity, backgroundRotation, environmentIntensity, environmentRotation, ...rest }) {\n    const texture = (0,_useEnvironment_js__WEBPACK_IMPORTED_MODULE_3__.useEnvironment)(rest);\n    const defaultScene = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.z)((state)=>state.scene);\n    react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect(()=>{\n        return setEnvProps(background, scene, defaultScene, texture, {\n            backgroundBlurriness: blur !== null && blur !== void 0 ? blur : backgroundBlurriness,\n            backgroundIntensity,\n            backgroundRotation,\n            environmentIntensity,\n            environmentRotation\n        });\n    });\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect(()=>{\n        return ()=>{\n            texture.dispose();\n        };\n    }, [\n        texture\n    ]);\n    return null;\n}\nfunction EnvironmentPortal({ children, near = 0.1, far = 1000, resolution = 256, frames = 1, map, background = false, blur, backgroundBlurriness, backgroundIntensity, backgroundRotation, environmentIntensity, environmentRotation, scene, files, path, preset = undefined, extensions }) {\n    const gl = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.z)((state)=>state.gl);\n    const defaultScene = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.z)((state)=>state.scene);\n    const camera = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n    const [virtualScene] = react__WEBPACK_IMPORTED_MODULE_1__.useState(()=>new three__WEBPACK_IMPORTED_MODULE_4__.Scene());\n    const fbo = react__WEBPACK_IMPORTED_MODULE_1__.useMemo(()=>{\n        const fbo = new three__WEBPACK_IMPORTED_MODULE_4__.WebGLCubeRenderTarget(resolution);\n        fbo.texture.type = three__WEBPACK_IMPORTED_MODULE_4__.HalfFloatType;\n        return fbo;\n    }, [\n        resolution\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect(()=>{\n        return ()=>{\n            fbo.dispose();\n        };\n    }, [\n        fbo\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect(()=>{\n        if (frames === 1) {\n            const autoClear = gl.autoClear;\n            gl.autoClear = true;\n            camera.current.update(gl, virtualScene);\n            gl.autoClear = autoClear;\n        }\n        return setEnvProps(background, scene, defaultScene, fbo.texture, {\n            backgroundBlurriness: blur !== null && blur !== void 0 ? blur : backgroundBlurriness,\n            backgroundIntensity,\n            backgroundRotation,\n            environmentIntensity,\n            environmentRotation\n        });\n    }, [\n        children,\n        virtualScene,\n        fbo.texture,\n        scene,\n        defaultScene,\n        background,\n        frames,\n        gl\n    ]);\n    let count = 1;\n    (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.A)(()=>{\n        if (frames === Infinity || count < frames) {\n            const autoClear = gl.autoClear;\n            gl.autoClear = true;\n            camera.current.update(gl, virtualScene);\n            gl.autoClear = autoClear;\n            count++;\n        }\n    });\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(react__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.g)(/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(react__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, children, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"cubeCamera\", {\n        ref: camera,\n        args: [\n            near,\n            far,\n            fbo\n        ]\n    }), files || preset ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(EnvironmentCube, {\n        background: true,\n        files: files,\n        preset: preset,\n        path: path,\n        extensions: extensions\n    }) : map ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(EnvironmentMap, {\n        background: true,\n        map: map,\n        extensions: extensions\n    }) : null), virtualScene));\n}\nfunction EnvironmentGround(props) {\n    var _props$ground, _props$ground2, _scale, _props$ground3;\n    const textureDefault = (0,_useEnvironment_js__WEBPACK_IMPORTED_MODULE_3__.useEnvironment)(props);\n    const texture = props.map || textureDefault;\n    react__WEBPACK_IMPORTED_MODULE_1__.useMemo(()=>(0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.e)({\n            GroundProjectedEnvImpl: three_stdlib__WEBPACK_IMPORTED_MODULE_5__.GroundProjectedEnv\n        }), []);\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect(()=>{\n        return ()=>{\n            textureDefault.dispose();\n        };\n    }, [\n        textureDefault\n    ]);\n    const args = react__WEBPACK_IMPORTED_MODULE_1__.useMemo(()=>[\n            texture\n        ], [\n        texture\n    ]);\n    const height = (_props$ground = props.ground) == null ? void 0 : _props$ground.height;\n    const radius = (_props$ground2 = props.ground) == null ? void 0 : _props$ground2.radius;\n    const scale = (_scale = (_props$ground3 = props.ground) == null ? void 0 : _props$ground3.scale) !== null && _scale !== void 0 ? _scale : 1000;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(react__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(EnvironmentMap, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, props, {\n        map: texture\n    })), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"groundProjectedEnvImpl\", {\n        args: args,\n        scale: scale,\n        height: height,\n        radius: radius\n    }));\n}\nfunction Environment(props) {\n    return props.ground ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(EnvironmentGround, props) : props.map ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(EnvironmentMap, props) : props.children ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(EnvironmentPortal, props) : /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(EnvironmentCube, props);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9FbnZpcm9ubWVudC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUEwRDtBQUMzQjtBQUMyRDtBQUN0QjtBQUNsQjtBQUNHO0FBRXJELE1BQU1ZLFFBQVFDLENBQUFBLE1BQU9BLElBQUlDLE9BQU8sSUFBSUQsSUFBSUMsT0FBTyxDQUFDQyxPQUFPO0FBQ3ZELE1BQU1DLGVBQWVDLENBQUFBLFFBQVNMLE1BQU1LLFNBQVNBLE1BQU1ILE9BQU8sR0FBR0c7QUFDN0QsU0FBU0MsWUFBWUMsVUFBVSxFQUFFRixLQUFLLEVBQUVHLFlBQVksRUFBRUMsT0FBTyxFQUFFQyxhQUFhLENBQUMsQ0FBQztJQUM1RSxJQUFJQyx1QkFBdUJDLHdCQUF3QkMsdUJBQXVCQztJQUMxRSxXQUFXO0lBQ1hKLGFBQWE7UUFDWEssc0JBQXNCO1FBQ3RCQyxxQkFBcUI7UUFDckJDLG9CQUFvQjtZQUFDO1lBQUc7WUFBRztTQUFFO1FBQzdCQyxzQkFBc0I7UUFDdEJDLHFCQUFxQjtZQUFDO1lBQUc7WUFBRztTQUFFO1FBQzlCLEdBQUdULFVBQVU7SUFDZjtJQUNBLE1BQU1VLFNBQVNoQixhQUFhQyxTQUFTRztJQUNyQyxNQUFNYSxRQUFRRCxPQUFPYixVQUFVO0lBQy9CLE1BQU1lLFNBQVNGLE9BQU9HLFdBQVc7SUFDakMsTUFBTUMsZ0JBQWdCO1FBQ3BCLGFBQWE7UUFDYlQsc0JBQXNCSyxPQUFPTCxvQkFBb0I7UUFDakQsYUFBYTtRQUNiQyxxQkFBcUJJLE9BQU9KLG1CQUFtQjtRQUMvQyxhQUFhO1FBQ2JDLG9CQUFvQixDQUFDTix3QkFBd0IsQ0FBQ0MseUJBQXlCUSxPQUFPSCxrQkFBa0IsS0FBSyxRQUFRTCx1QkFBdUJhLEtBQUssSUFBSSxPQUFPLEtBQUssSUFBSWIsdUJBQXVCYSxLQUFLLEVBQUMsTUFBTyxRQUFRZCwwQkFBMEIsS0FBSyxJQUFJQSx3QkFBd0I7WUFBQztZQUFHO1lBQUc7U0FB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bEI7SUFDUCxLQUFLLFdBQVcsR0FBRXBCLGdEQUFtQixDQUFDLDBCQUEwQjtRQUM5RHlFLE1BQU1BO1FBQ05ZLE9BQU9BO1FBQ1BILFFBQVFBO1FBQ1JFLFFBQVFBO0lBQ1Y7QUFDRjtBQUNBLFNBQVNFLFlBQVlYLEtBQUs7SUFDeEIsT0FBT0EsTUFBTVEsTUFBTSxHQUFHLFdBQVcsR0FBRW5GLGdEQUFtQixDQUFDMEUsbUJBQW1CQyxTQUFTQSxNQUFNckMsR0FBRyxHQUFHLFdBQVcsR0FBRXRDLGdEQUFtQixDQUFDcUMsZ0JBQWdCc0MsU0FBU0EsTUFBTTNCLFFBQVEsR0FBRyxXQUFXLEdBQUVoRCxnREFBbUIsQ0FBQytDLG1CQUFtQjRCLFNBQVMsV0FBVyxHQUFFM0UsZ0RBQW1CLENBQUMwQyxpQkFBaUJpQztBQUMzUjtBQUUyRSIsInNvdXJjZXMiOlsid2VicGFjazovL215VlJwcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL0ByZWFjdC10aHJlZS9kcmVpL2NvcmUvRW52aXJvbm1lbnQuanM/NjA0MSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgX2V4dGVuZHMgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kcyc7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VUaHJlZSwgdXNlRnJhbWUsIGNyZWF0ZVBvcnRhbCwgYXBwbHlQcm9wcywgZXh0ZW5kIH0gZnJvbSAnQHJlYWN0LXRocmVlL2ZpYmVyJztcbmltcG9ydCB7IFNjZW5lLCBXZWJHTEN1YmVSZW5kZXJUYXJnZXQsIEhhbGZGbG9hdFR5cGUgfSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgeyBHcm91bmRQcm9qZWN0ZWRFbnYgfSBmcm9tICd0aHJlZS1zdGRsaWInO1xuaW1wb3J0IHsgdXNlRW52aXJvbm1lbnQgfSBmcm9tICcuL3VzZUVudmlyb25tZW50LmpzJztcblxuY29uc3QgaXNSZWYgPSBvYmogPT4gb2JqLmN1cnJlbnQgJiYgb2JqLmN1cnJlbnQuaXNTY2VuZTtcbmNvbnN0IHJlc29sdmVTY2VuZSA9IHNjZW5lID0+IGlzUmVmKHNjZW5lKSA/IHNjZW5lLmN1cnJlbnQgOiBzY2VuZTtcbmZ1bmN0aW9uIHNldEVudlByb3BzKGJhY2tncm91bmQsIHNjZW5lLCBkZWZhdWx0U2NlbmUsIHRleHR1cmUsIHNjZW5lUHJvcHMgPSB7fSkge1xuICB2YXIgX3RhcmdldCRiYWNrZ3JvdW5kUm90LCBfdGFyZ2V0JGJhY2tncm91bmRSb3QyLCBfdGFyZ2V0JGVudmlyb25tZW50Um8sIF90YXJnZXQkZW52aXJvbm1lbnRSbzI7XG4gIC8vIGRlZmF1bHRzXG4gIHNjZW5lUHJvcHMgPSB7XG4gICAgYmFja2dyb3VuZEJsdXJyaW5lc3M6IDAsXG4gICAgYmFja2dyb3VuZEludGVuc2l0eTogMSxcbiAgICBiYWNrZ3JvdW5kUm90YXRpb246IFswLCAwLCAwXSxcbiAgICBlbnZpcm9ubWVudEludGVuc2l0eTogMSxcbiAgICBlbnZpcm9ubWVudFJvdGF0aW9uOiBbMCwgMCwgMF0sXG4gICAgLi4uc2NlbmVQcm9wc1xuICB9O1xuICBjb25zdCB0YXJnZXQgPSByZXNvbHZlU2NlbmUoc2NlbmUgfHwgZGVmYXVsdFNjZW5lKTtcbiAgY29uc3Qgb2xkYmcgPSB0YXJnZXQuYmFja2dyb3VuZDtcbiAgY29uc3Qgb2xkZW52ID0gdGFyZ2V0LmVudmlyb25tZW50O1xuICBjb25zdCBvbGRTY2VuZVByb3BzID0ge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBiYWNrZ3JvdW5kQmx1cnJpbmVzczogdGFyZ2V0LmJhY2tncm91bmRCbHVycmluZXNzLFxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBiYWNrZ3JvdW5kSW50ZW5zaXR5OiB0YXJnZXQuYmFja2dyb3VuZEludGVuc2l0eSxcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgYmFja2dyb3VuZFJvdGF0aW9uOiAoX3RhcmdldCRiYWNrZ3JvdW5kUm90ID0gKF90YXJnZXQkYmFja2dyb3VuZFJvdDIgPSB0YXJnZXQuYmFja2dyb3VuZFJvdGF0aW9uKSA9PSBudWxsIHx8IF90YXJnZXQkYmFja2dyb3VuZFJvdDIuY2xvbmUgPT0gbnVsbCA/IHZvaWQgMCA6IF90YXJnZXQkYmFja2dyb3VuZFJvdDIuY2xvbmUoKSkgIT09IG51bGwgJiYgX3RhcmdldCRiYWNrZ3JvdW5kUm90ICE9PSB2b2lkIDAgPyBfdGFyZ2V0JGJhY2tncm91bmRSb3QgOiBbMCwgMCwgMF0sXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGVudmlyb25tZW50SW50ZW5zaXR5OiB0YXJnZXQuZW52aXJvbm1lbnRJbnRlbnNpdHksXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGVudmlyb25tZW50Um90YXRpb246IChfdGFyZ2V0JGVudmlyb25tZW50Um8gPSAoX3RhcmdldCRlbnZpcm9ubWVudFJvMiA9IHRhcmdldC5lbnZpcm9ubWVudFJvdGF0aW9uKSA9PSBudWxsIHx8IF90YXJnZXQkZW52aXJvbm1lbnRSbzIuY2xvbmUgPT0gbnVsbCA/IHZvaWQgMCA6IF90YXJnZXQkZW52aXJvbm1lbnRSbzIuY2xvbmUoKSkgIT09IG51bGwgJiYgX3RhcmdldCRlbnZpcm9ubWVudFJvICE9PSB2b2lkIDAgPyBfdGFyZ2V0JGVudmlyb25tZW50Um8gOiBbMCwgMCwgMF1cbiAgfTtcbiAgaWYgKGJhY2tncm91bmQgIT09ICdvbmx5JykgdGFyZ2V0LmVudmlyb25tZW50ID0gdGV4dHVyZTtcbiAgaWYgKGJhY2tncm91bmQpIHRhcmdldC5iYWNrZ3JvdW5kID0gdGV4dHVyZTtcbiAgYXBwbHlQcm9wcyh0YXJnZXQsIHNjZW5lUHJvcHMpO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGlmIChiYWNrZ3JvdW5kICE9PSAnb25seScpIHRhcmdldC5lbnZpcm9ubWVudCA9IG9sZGVudjtcbiAgICBpZiAoYmFja2dyb3VuZCkgdGFyZ2V0LmJhY2tncm91bmQgPSBvbGRiZztcbiAgICBhcHBseVByb3BzKHRhcmdldCwgb2xkU2NlbmVQcm9wcyk7XG4gIH07XG59XG5mdW5jdGlvbiBFbnZpcm9ubWVudE1hcCh7XG4gIHNjZW5lLFxuICBiYWNrZ3JvdW5kID0gZmFsc2UsXG4gIG1hcCxcbiAgLi4uY29uZmlnXG59KSB7XG4gIGNvbnN0IGRlZmF1bHRTY2VuZSA9IHVzZVRocmVlKHN0YXRlID0+IHN0YXRlLnNjZW5lKTtcbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAobWFwKSByZXR1cm4gc2V0RW52UHJvcHMoYmFja2dyb3VuZCwgc2NlbmUsIGRlZmF1bHRTY2VuZSwgbWFwLCBjb25maWcpO1xuICB9KTtcbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBFbnZpcm9ubWVudEN1YmUoe1xuICBiYWNrZ3JvdW5kID0gZmFsc2UsXG4gIHNjZW5lLFxuICBibHVyLFxuICBiYWNrZ3JvdW5kQmx1cnJpbmVzcyxcbiAgYmFja2dyb3VuZEludGVuc2l0eSxcbiAgYmFja2dyb3VuZFJvdGF0aW9uLFxuICBlbnZpcm9ubWVudEludGVuc2l0eSxcbiAgZW52aXJvbm1lbnRSb3RhdGlvbixcbiAgLi4ucmVzdFxufSkge1xuICBjb25zdCB0ZXh0dXJlID0gdXNlRW52aXJvbm1lbnQocmVzdCk7XG4gIGNvbnN0IGRlZmF1bHRTY2VuZSA9IHVzZVRocmVlKHN0YXRlID0+IHN0YXRlLnNjZW5lKTtcbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gc2V0RW52UHJvcHMoYmFja2dyb3VuZCwgc2NlbmUsIGRlZmF1bHRTY2VuZSwgdGV4dHVyZSwge1xuICAgICAgYmFja2dyb3VuZEJsdXJyaW5lc3M6IGJsdXIgIT09IG51bGwgJiYgYmx1ciAhPT0gdm9pZCAwID8gYmx1ciA6IGJhY2tncm91bmRCbHVycmluZXNzLFxuICAgICAgYmFja2dyb3VuZEludGVuc2l0eSxcbiAgICAgIGJhY2tncm91bmRSb3RhdGlvbixcbiAgICAgIGVudmlyb25tZW50SW50ZW5zaXR5LFxuICAgICAgZW52aXJvbm1lbnRSb3RhdGlvblxuICAgIH0pO1xuICB9KTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgdGV4dHVyZS5kaXNwb3NlKCk7XG4gICAgfTtcbiAgfSwgW3RleHR1cmVdKTtcbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBFbnZpcm9ubWVudFBvcnRhbCh7XG4gIGNoaWxkcmVuLFxuICBuZWFyID0gMC4xLFxuICBmYXIgPSAxMDAwLFxuICByZXNvbHV0aW9uID0gMjU2LFxuICBmcmFtZXMgPSAxLFxuICBtYXAsXG4gIGJhY2tncm91bmQgPSBmYWxzZSxcbiAgYmx1cixcbiAgYmFja2dyb3VuZEJsdXJyaW5lc3MsXG4gIGJhY2tncm91bmRJbnRlbnNpdHksXG4gIGJhY2tncm91bmRSb3RhdGlvbixcbiAgZW52aXJvbm1lbnRJbnRlbnNpdHksXG4gIGVudmlyb25tZW50Um90YXRpb24sXG4gIHNjZW5lLFxuICBmaWxlcyxcbiAgcGF0aCxcbiAgcHJlc2V0ID0gdW5kZWZpbmVkLFxuICBleHRlbnNpb25zXG59KSB7XG4gIGNvbnN0IGdsID0gdXNlVGhyZWUoc3RhdGUgPT4gc3RhdGUuZ2wpO1xuICBjb25zdCBkZWZhdWx0U2NlbmUgPSB1c2VUaHJlZShzdGF0ZSA9PiBzdGF0ZS5zY2VuZSk7XG4gIGNvbnN0IGNhbWVyYSA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgW3ZpcnR1YWxTY2VuZV0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiBuZXcgU2NlbmUoKSk7XG4gIGNvbnN0IGZibyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IGZibyA9IG5ldyBXZWJHTEN1YmVSZW5kZXJUYXJnZXQocmVzb2x1dGlvbik7XG4gICAgZmJvLnRleHR1cmUudHlwZSA9IEhhbGZGbG9hdFR5cGU7XG4gICAgcmV0dXJuIGZibztcbiAgfSwgW3Jlc29sdXRpb25dKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgZmJvLmRpc3Bvc2UoKTtcbiAgICB9O1xuICB9LCBbZmJvXSk7XG4gIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGZyYW1lcyA9PT0gMSkge1xuICAgICAgY29uc3QgYXV0b0NsZWFyID0gZ2wuYXV0b0NsZWFyO1xuICAgICAgZ2wuYXV0b0NsZWFyID0gdHJ1ZTtcbiAgICAgIGNhbWVyYS5jdXJyZW50LnVwZGF0ZShnbCwgdmlydHVhbFNjZW5lKTtcbiAgICAgIGdsLmF1dG9DbGVhciA9IGF1dG9DbGVhcjtcbiAgICB9XG4gICAgcmV0dXJuIHNldEVudlByb3BzKGJhY2tncm91bmQsIHNjZW5lLCBkZWZhdWx0U2NlbmUsIGZiby50ZXh0dXJlLCB7XG4gICAgICBiYWNrZ3JvdW5kQmx1cnJpbmVzczogYmx1ciAhPT0gbnVsbCAmJiBibHVyICE9PSB2b2lkIDAgPyBibHVyIDogYmFja2dyb3VuZEJsdXJyaW5lc3MsXG4gICAgICBiYWNrZ3JvdW5kSW50ZW5zaXR5LFxuICAgICAgYmFja2dyb3VuZFJvdGF0aW9uLFxuICAgICAgZW52aXJvbm1lbnRJbnRlbnNpdHksXG4gICAgICBlbnZpcm9ubWVudFJvdGF0aW9uXG4gICAgfSk7XG4gIH0sIFtjaGlsZHJlbiwgdmlydHVhbFNjZW5lLCBmYm8udGV4dHVyZSwgc2NlbmUsIGRlZmF1bHRTY2VuZSwgYmFja2dyb3VuZCwgZnJhbWVzLCBnbF0pO1xuICBsZXQgY291bnQgPSAxO1xuICB1c2VGcmFtZSgoKSA9PiB7XG4gICAgaWYgKGZyYW1lcyA9PT0gSW5maW5pdHkgfHwgY291bnQgPCBmcmFtZXMpIHtcbiAgICAgIGNvbnN0IGF1dG9DbGVhciA9IGdsLmF1dG9DbGVhcjtcbiAgICAgIGdsLmF1dG9DbGVhciA9IHRydWU7XG4gICAgICBjYW1lcmEuY3VycmVudC51cGRhdGUoZ2wsIHZpcnR1YWxTY2VuZSk7XG4gICAgICBnbC5hdXRvQ2xlYXIgPSBhdXRvQ2xlYXI7XG4gICAgICBjb3VudCsrO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgY3JlYXRlUG9ydGFsKC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCBjaGlsZHJlbiwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJjdWJlQ2FtZXJhXCIsIHtcbiAgICByZWY6IGNhbWVyYSxcbiAgICBhcmdzOiBbbmVhciwgZmFyLCBmYm9dXG4gIH0pLCBmaWxlcyB8fCBwcmVzZXQgPyAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChFbnZpcm9ubWVudEN1YmUsIHtcbiAgICBiYWNrZ3JvdW5kOiB0cnVlLFxuICAgIGZpbGVzOiBmaWxlcyxcbiAgICBwcmVzZXQ6IHByZXNldCxcbiAgICBwYXRoOiBwYXRoLFxuICAgIGV4dGVuc2lvbnM6IGV4dGVuc2lvbnNcbiAgfSkgOiBtYXAgPyAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChFbnZpcm9ubWVudE1hcCwge1xuICAgIGJhY2tncm91bmQ6IHRydWUsXG4gICAgbWFwOiBtYXAsXG4gICAgZXh0ZW5zaW9uczogZXh0ZW5zaW9uc1xuICB9KSA6IG51bGwpLCB2aXJ0dWFsU2NlbmUpKTtcbn1cbmZ1bmN0aW9uIEVudmlyb25tZW50R3JvdW5kKHByb3BzKSB7XG4gIHZhciBfcHJvcHMkZ3JvdW5kLCBfcHJvcHMkZ3JvdW5kMiwgX3NjYWxlLCBfcHJvcHMkZ3JvdW5kMztcbiAgY29uc3QgdGV4dHVyZURlZmF1bHQgPSB1c2VFbnZpcm9ubWVudChwcm9wcyk7XG4gIGNvbnN0IHRleHR1cmUgPSBwcm9wcy5tYXAgfHwgdGV4dHVyZURlZmF1bHQ7XG4gIFJlYWN0LnVzZU1lbW8oKCkgPT4gZXh0ZW5kKHtcbiAgICBHcm91bmRQcm9qZWN0ZWRFbnZJbXBsOiBHcm91bmRQcm9qZWN0ZWRFbnZcbiAgfSksIFtdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgdGV4dHVyZURlZmF1bHQuZGlzcG9zZSgpO1xuICAgIH07XG4gIH0sIFt0ZXh0dXJlRGVmYXVsdF0pO1xuICBjb25zdCBhcmdzID0gUmVhY3QudXNlTWVtbygoKSA9PiBbdGV4dHVyZV0sIFt0ZXh0dXJlXSk7XG4gIGNvbnN0IGhlaWdodCA9IChfcHJvcHMkZ3JvdW5kID0gcHJvcHMuZ3JvdW5kKSA9PSBudWxsID8gdm9pZCAwIDogX3Byb3BzJGdyb3VuZC5oZWlnaHQ7XG4gIGNvbnN0IHJhZGl1cyA9IChfcHJvcHMkZ3JvdW5kMiA9IHByb3BzLmdyb3VuZCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9wcm9wcyRncm91bmQyLnJhZGl1cztcbiAgY29uc3Qgc2NhbGUgPSAoX3NjYWxlID0gKF9wcm9wcyRncm91bmQzID0gcHJvcHMuZ3JvdW5kKSA9PSBudWxsID8gdm9pZCAwIDogX3Byb3BzJGdyb3VuZDMuc2NhbGUpICE9PSBudWxsICYmIF9zY2FsZSAhPT0gdm9pZCAwID8gX3NjYWxlIDogMTAwMDtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChFbnZpcm9ubWVudE1hcCwgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgbWFwOiB0ZXh0dXJlXG4gIH0pKSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJncm91bmRQcm9qZWN0ZWRFbnZJbXBsXCIsIHtcbiAgICBhcmdzOiBhcmdzLFxuICAgIHNjYWxlOiBzY2FsZSxcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICByYWRpdXM6IHJhZGl1c1xuICB9KSk7XG59XG5mdW5jdGlvbiBFbnZpcm9ubWVudChwcm9wcykge1xuICByZXR1cm4gcHJvcHMuZ3JvdW5kID8gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRW52aXJvbm1lbnRHcm91bmQsIHByb3BzKSA6IHByb3BzLm1hcCA/IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEVudmlyb25tZW50TWFwLCBwcm9wcykgOiBwcm9wcy5jaGlsZHJlbiA/IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEVudmlyb25tZW50UG9ydGFsLCBwcm9wcykgOiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChFbnZpcm9ubWVudEN1YmUsIHByb3BzKTtcbn1cblxuZXhwb3J0IHsgRW52aXJvbm1lbnQsIEVudmlyb25tZW50Q3ViZSwgRW52aXJvbm1lbnRNYXAsIEVudmlyb25tZW50UG9ydGFsIH07XG4iXSwibmFtZXMiOlsiX2V4dGVuZHMiLCJSZWFjdCIsInVzZVRocmVlIiwidXNlRnJhbWUiLCJjcmVhdGVQb3J0YWwiLCJhcHBseVByb3BzIiwiZXh0ZW5kIiwiU2NlbmUiLCJXZWJHTEN1YmVSZW5kZXJUYXJnZXQiLCJIYWxmRmxvYXRUeXBlIiwiR3JvdW5kUHJvamVjdGVkRW52IiwidXNlRW52aXJvbm1lbnQiLCJpc1JlZiIsIm9iaiIsImN1cnJlbnQiLCJpc1NjZW5lIiwicmVzb2x2ZVNjZW5lIiwic2NlbmUiLCJzZXRFbnZQcm9wcyIsImJhY2tncm91bmQiLCJkZWZhdWx0U2NlbmUiLCJ0ZXh0dXJlIiwic2NlbmVQcm9wcyIsIl90YXJnZXQkYmFja2dyb3VuZFJvdCIsIl90YXJnZXQkYmFja2dyb3VuZFJvdDIiLCJfdGFyZ2V0JGVudmlyb25tZW50Um8iLCJfdGFyZ2V0JGVudmlyb25tZW50Um8yIiwiYmFja2dyb3VuZEJsdXJyaW5lc3MiLCJiYWNrZ3JvdW5kSW50ZW5zaXR5IiwiYmFja2dyb3VuZFJvdGF0aW9uIiwiZW52aXJvbm1lbnRJbnRlbnNpdHkiLCJlbnZpcm9ubWVudFJvdGF0aW9uIiwidGFyZ2V0Iiwib2xkYmciLCJvbGRlbnYiLCJlbnZpcm9ubWVudCIsIm9sZFNjZW5lUHJvcHMiLCJjbG9uZSIsIkVudmlyb25tZW50TWFwIiwibWFwIiwiY29uZmlnIiwic3RhdGUiLCJ1c2VMYXlvdXRFZmZlY3QiLCJFbnZpcm9ubWVudEN1YmUiLCJibHVyIiwicmVzdCIsInVzZUVmZmVjdCIsImRpc3Bvc2UiLCJFbnZpcm9ubWVudFBvcnRhbCIsImNoaWxkcmVuIiwibmVhciIsImZhciIsInJlc29sdXRpb24iLCJmcmFtZXMiLCJmaWxlcyIsInBhdGgiLCJwcmVzZXQiLCJ1bmRlZmluZWQiLCJleHRlbnNpb25zIiwiZ2wiLCJjYW1lcmEiLCJ1c2VSZWYiLCJ2aXJ0dWFsU2NlbmUiLCJ1c2VTdGF0ZSIsImZibyIsInVzZU1lbW8iLCJ0eXBlIiwiYXV0b0NsZWFyIiwidXBkYXRlIiwiY291bnQiLCJJbmZpbml0eSIsImNyZWF0ZUVsZW1lbnQiLCJGcmFnbWVudCIsInJlZiIsImFyZ3MiLCJFbnZpcm9ubWVudEdyb3VuZCIsInByb3BzIiwiX3Byb3BzJGdyb3VuZCIsIl9wcm9wcyRncm91bmQyIiwiX3NjYWxlIiwiX3Byb3BzJGdyb3VuZDMiLCJ0ZXh0dXJlRGVmYXVsdCIsIkdyb3VuZFByb2plY3RlZEVudkltcGwiLCJoZWlnaHQiLCJncm91bmQiLCJyYWRpdXMiLCJzY2FsZSIsIkVudmlyb25tZW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/core/Environment.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/core/OrbitControls.js":
/*!**************************************************************!*\
  !*** ./node_modules/@react-three/drei/core/OrbitControls.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OrbitControls: () => (/* binding */ OrbitControls)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-three/fiber */ \"(ssr)/./node_modules/@react-three/fiber/dist/index-673ef987.esm.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var three_stdlib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three-stdlib */ \"(ssr)/./node_modules/three-stdlib/controls/OrbitControls.js\");\n\n\n\n\nconst OrbitControls = /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(({ makeDefault, camera, regress, domElement, enableDamping = true, keyEvents = false, onChange, onStart, onEnd, ...restProps }, ref)=>{\n    const invalidate = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.z)((state)=>state.invalidate);\n    const defaultCamera = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.z)((state)=>state.camera);\n    const gl = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.z)((state)=>state.gl);\n    const events = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.z)((state)=>state.events);\n    const setEvents = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.z)((state)=>state.setEvents);\n    const set = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.z)((state)=>state.set);\n    const get = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.z)((state)=>state.get);\n    const performance = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.z)((state)=>state.performance);\n    const explCamera = camera || defaultCamera;\n    const explDomElement = domElement || events.connected || gl.domElement;\n    const controls = react__WEBPACK_IMPORTED_MODULE_1__.useMemo(()=>new three_stdlib__WEBPACK_IMPORTED_MODULE_3__.OrbitControls(explCamera), [\n        explCamera\n    ]);\n    (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.A)(()=>{\n        if (controls.enabled) controls.update();\n    }, -1);\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect(()=>{\n        if (keyEvents) {\n            controls.connect(keyEvents === true ? explDomElement : keyEvents);\n        }\n        controls.connect(explDomElement);\n        return ()=>void controls.dispose();\n    }, [\n        keyEvents,\n        explDomElement,\n        regress,\n        controls,\n        invalidate\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect(()=>{\n        const callback = (e)=>{\n            invalidate();\n            if (regress) performance.regress();\n            if (onChange) onChange(e);\n        };\n        const onStartCb = (e)=>{\n            if (onStart) onStart(e);\n        };\n        const onEndCb = (e)=>{\n            if (onEnd) onEnd(e);\n        };\n        controls.addEventListener(\"change\", callback);\n        controls.addEventListener(\"start\", onStartCb);\n        controls.addEventListener(\"end\", onEndCb);\n        return ()=>{\n            controls.removeEventListener(\"start\", onStartCb);\n            controls.removeEventListener(\"end\", onEndCb);\n            controls.removeEventListener(\"change\", callback);\n        };\n    }, [\n        onChange,\n        onStart,\n        onEnd,\n        controls,\n        invalidate,\n        setEvents\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect(()=>{\n        if (makeDefault) {\n            const old = get().controls;\n            // @ts-ignore https://github.com/three-types/three-ts-types/pull/1398\n            set({\n                controls\n            });\n            return ()=>set({\n                    controls: old\n                });\n        }\n    }, [\n        makeDefault,\n        controls\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"primitive\", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        ref: ref,\n        object: controls,\n        enableDamping: enableDamping\n    }, restProps));\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9PcmJpdENvbnRyb2xzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUEwRDtBQUNGO0FBQ3pCO0FBQ2lDO0FBRWhFLE1BQU1JLGdCQUFnQixhQUFhLGlCQUFFRCw2Q0FBZ0IsQ0FBQyxDQUFDLEVBQ3JESSxXQUFXLEVBQ1hDLE1BQU0sRUFDTkMsT0FBTyxFQUNQQyxVQUFVLEVBQ1ZDLGdCQUFnQixJQUFJLEVBQ3BCQyxZQUFZLEtBQUssRUFDakJDLFFBQVEsRUFDUkMsT0FBTyxFQUNQQyxLQUFLLEVBQ0wsR0FBR0MsV0FDSixFQUFFQztJQUNELE1BQU1DLGFBQWFqQixxREFBUUEsQ0FBQ2tCLENBQUFBLFFBQVNBLE1BQU1ELFVBQVU7SUFDckQsTUFBTUUsZ0JBQWdCbkIscURBQVFBLENBQUNrQixDQUFBQSxRQUFTQSxNQUFNWCxNQUFNO0lBQ3BELE1BQU1hLEtBQUtwQixxREFBUUEsQ0FBQ2tCLENBQUFBLFFBQVNBLE1BQU1FLEVBQUU7SUFDckMsTUFBTUMsU0FBU3JCLHFEQUFRQSxDQUFDa0IsQ0FBQUEsUUFBU0EsTUFBTUcsTUFBTTtJQUM3QyxNQUFNQyxZQUFZdEIscURBQVFBLENBQUNrQixDQUFBQSxRQUFTQSxNQUFNSSxTQUFTO0lBQ25ELE1BQU1DLE1BQU12QixxREFBUUEsQ0FBQ2tCLENBQUFBLFFBQVNBLE1BQU1LLEdBQUc7SUFDdkMsTUFBTUMsTUFBTXhCLHFEQUFRQSxDQUFDa0IsQ0FBQUEsUUFBU0EsTUFBTU0sR0FBRztJQUN2QyxNQUFNQyxjQUFjekIscURBQVFBLENBQUNrQixDQUFBQSxRQUFTQSxNQUFNTyxXQUFXO0lBQ3ZELE1BQU1DLGFBQWFuQixVQUFVWTtJQUM3QixNQUFNUSxpQkFBaUJsQixjQUFjWSxPQUFPTyxTQUFTLElBQUlSLEdBQUdYLFVBQVU7SUFDdEUsTUFBTW9CLFdBQVczQiwwQ0FBYSxDQUFDLElBQU0sSUFBSUUsdURBQWVBLENBQUNzQixhQUFhO1FBQUNBO0tBQVc7SUFDbEZ6QixxREFBUUEsQ0FBQztRQUNQLElBQUk0QixTQUFTRSxPQUFPLEVBQUVGLFNBQVNHLE1BQU07SUFDdkMsR0FBRyxDQUFDO0lBQ0o5Qiw0Q0FBZSxDQUFDO1FBQ2QsSUFBSVMsV0FBVztZQUNia0IsU0FBU0ssT0FBTyxDQUFDdkIsY0FBYyxPQUFPZ0IsaUJBQWlCaEI7UUFDekQ7UUFDQWtCLFNBQVNLLE9BQU8sQ0FBQ1A7UUFDakIsT0FBTyxJQUFNLEtBQUtFLFNBQVNNLE9BQU87SUFDcEMsR0FBRztRQUFDeEI7UUFBV2dCO1FBQWdCbkI7UUFBU3FCO1FBQVVaO0tBQVc7SUFDN0RmLDRDQUFlLENBQUM7UUFDZCxNQUFNa0MsV0FBV0MsQ0FBQUE7WUFDZnBCO1lBQ0EsSUFBSVQsU0FBU2lCLFlBQVlqQixPQUFPO1lBQ2hDLElBQUlJLFVBQVVBLFNBQVN5QjtRQUN6QjtRQUNBLE1BQU1DLFlBQVlELENBQUFBO1lBQ2hCLElBQUl4QixTQUFTQSxRQUFRd0I7UUFDdkI7UUFDQSxNQUFNRSxVQUFVRixDQUFBQTtZQUNkLElBQUl2QixPQUFPQSxNQUFNdUI7UUFDbkI7UUFDQVIsU0FBU1csZ0JBQWdCLENBQUMsVUFBVUo7UUFDcENQLFNBQVNXLGdCQUFnQixDQUFDLFNBQVNGO1FBQ25DVCxTQUFTVyxnQkFBZ0IsQ0FBQyxPQUFPRDtRQUNqQyxPQUFPO1lBQ0xWLFNBQVNZLG1CQUFtQixDQUFDLFNBQVNIO1lBQ3RDVCxTQUFTWSxtQkFBbUIsQ0FBQyxPQUFPRjtZQUNwQ1YsU0FBU1ksbUJBQW1CLENBQUMsVUFBVUw7UUFDekM7SUFDRixHQUFHO1FBQUN4QjtRQUFVQztRQUFTQztRQUFPZTtRQUFVWjtRQUFZSztLQUFVO0lBQzlEcEIsNENBQWUsQ0FBQztRQUNkLElBQUlJLGFBQWE7WUFDZixNQUFNb0MsTUFBTWxCLE1BQU1LLFFBQVE7WUFDMUIscUVBQXFFO1lBQ3JFTixJQUFJO2dCQUNGTTtZQUNGO1lBQ0EsT0FBTyxJQUFNTixJQUFJO29CQUNmTSxVQUFVYTtnQkFDWjtRQUNGO0lBQ0YsR0FBRztRQUFDcEM7UUFBYXVCO0tBQVM7SUFDMUIsT0FBTyxXQUFXLEdBQUUzQixnREFBbUIsQ0FBQyxhQUFhSCw4RUFBUUEsQ0FBQztRQUM1RGlCLEtBQUtBO1FBQ0w0QixRQUFRZjtRQUNSbkIsZUFBZUE7SUFDakIsR0FBR0s7QUFDTDtBQUV5QiIsInNvdXJjZXMiOlsid2VicGFjazovL215VlJwcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL0ByZWFjdC10aHJlZS9kcmVpL2NvcmUvT3JiaXRDb250cm9scy5qcz9jOGU1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfZXh0ZW5kcyBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzJztcbmltcG9ydCB7IHVzZVRocmVlLCB1c2VGcmFtZSB9IGZyb20gJ0ByZWFjdC10aHJlZS9maWJlcic7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBPcmJpdENvbnRyb2xzIGFzIE9yYml0Q29udHJvbHMkMSB9IGZyb20gJ3RocmVlLXN0ZGxpYic7XG5cbmNvbnN0IE9yYml0Q29udHJvbHMgPSAvKiBAX19QVVJFX18gKi9SZWFjdC5mb3J3YXJkUmVmKCh7XG4gIG1ha2VEZWZhdWx0LFxuICBjYW1lcmEsXG4gIHJlZ3Jlc3MsXG4gIGRvbUVsZW1lbnQsXG4gIGVuYWJsZURhbXBpbmcgPSB0cnVlLFxuICBrZXlFdmVudHMgPSBmYWxzZSxcbiAgb25DaGFuZ2UsXG4gIG9uU3RhcnQsXG4gIG9uRW5kLFxuICAuLi5yZXN0UHJvcHNcbn0sIHJlZikgPT4ge1xuICBjb25zdCBpbnZhbGlkYXRlID0gdXNlVGhyZWUoc3RhdGUgPT4gc3RhdGUuaW52YWxpZGF0ZSk7XG4gIGNvbnN0IGRlZmF1bHRDYW1lcmEgPSB1c2VUaHJlZShzdGF0ZSA9PiBzdGF0ZS5jYW1lcmEpO1xuICBjb25zdCBnbCA9IHVzZVRocmVlKHN0YXRlID0+IHN0YXRlLmdsKTtcbiAgY29uc3QgZXZlbnRzID0gdXNlVGhyZWUoc3RhdGUgPT4gc3RhdGUuZXZlbnRzKTtcbiAgY29uc3Qgc2V0RXZlbnRzID0gdXNlVGhyZWUoc3RhdGUgPT4gc3RhdGUuc2V0RXZlbnRzKTtcbiAgY29uc3Qgc2V0ID0gdXNlVGhyZWUoc3RhdGUgPT4gc3RhdGUuc2V0KTtcbiAgY29uc3QgZ2V0ID0gdXNlVGhyZWUoc3RhdGUgPT4gc3RhdGUuZ2V0KTtcbiAgY29uc3QgcGVyZm9ybWFuY2UgPSB1c2VUaHJlZShzdGF0ZSA9PiBzdGF0ZS5wZXJmb3JtYW5jZSk7XG4gIGNvbnN0IGV4cGxDYW1lcmEgPSBjYW1lcmEgfHwgZGVmYXVsdENhbWVyYTtcbiAgY29uc3QgZXhwbERvbUVsZW1lbnQgPSBkb21FbGVtZW50IHx8IGV2ZW50cy5jb25uZWN0ZWQgfHwgZ2wuZG9tRWxlbWVudDtcbiAgY29uc3QgY29udHJvbHMgPSBSZWFjdC51c2VNZW1vKCgpID0+IG5ldyBPcmJpdENvbnRyb2xzJDEoZXhwbENhbWVyYSksIFtleHBsQ2FtZXJhXSk7XG4gIHVzZUZyYW1lKCgpID0+IHtcbiAgICBpZiAoY29udHJvbHMuZW5hYmxlZCkgY29udHJvbHMudXBkYXRlKCk7XG4gIH0sIC0xKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoa2V5RXZlbnRzKSB7XG4gICAgICBjb250cm9scy5jb25uZWN0KGtleUV2ZW50cyA9PT0gdHJ1ZSA/IGV4cGxEb21FbGVtZW50IDoga2V5RXZlbnRzKTtcbiAgICB9XG4gICAgY29udHJvbHMuY29ubmVjdChleHBsRG9tRWxlbWVudCk7XG4gICAgcmV0dXJuICgpID0+IHZvaWQgY29udHJvbHMuZGlzcG9zZSgpO1xuICB9LCBba2V5RXZlbnRzLCBleHBsRG9tRWxlbWVudCwgcmVncmVzcywgY29udHJvbHMsIGludmFsaWRhdGVdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBjYWxsYmFjayA9IGUgPT4ge1xuICAgICAgaW52YWxpZGF0ZSgpO1xuICAgICAgaWYgKHJlZ3Jlc3MpIHBlcmZvcm1hbmNlLnJlZ3Jlc3MoKTtcbiAgICAgIGlmIChvbkNoYW5nZSkgb25DaGFuZ2UoZSk7XG4gICAgfTtcbiAgICBjb25zdCBvblN0YXJ0Q2IgPSBlID0+IHtcbiAgICAgIGlmIChvblN0YXJ0KSBvblN0YXJ0KGUpO1xuICAgIH07XG4gICAgY29uc3Qgb25FbmRDYiA9IGUgPT4ge1xuICAgICAgaWYgKG9uRW5kKSBvbkVuZChlKTtcbiAgICB9O1xuICAgIGNvbnRyb2xzLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGNhbGxiYWNrKTtcbiAgICBjb250cm9scy5hZGRFdmVudExpc3RlbmVyKCdzdGFydCcsIG9uU3RhcnRDYik7XG4gICAgY29udHJvbHMuYWRkRXZlbnRMaXN0ZW5lcignZW5kJywgb25FbmRDYik7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNvbnRyb2xzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3N0YXJ0Jywgb25TdGFydENiKTtcbiAgICAgIGNvbnRyb2xzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VuZCcsIG9uRW5kQ2IpO1xuICAgICAgY29udHJvbHMucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgY2FsbGJhY2spO1xuICAgIH07XG4gIH0sIFtvbkNoYW5nZSwgb25TdGFydCwgb25FbmQsIGNvbnRyb2xzLCBpbnZhbGlkYXRlLCBzZXRFdmVudHNdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAobWFrZURlZmF1bHQpIHtcbiAgICAgIGNvbnN0IG9sZCA9IGdldCgpLmNvbnRyb2xzO1xuICAgICAgLy8gQHRzLWlnbm9yZSBodHRwczovL2dpdGh1Yi5jb20vdGhyZWUtdHlwZXMvdGhyZWUtdHMtdHlwZXMvcHVsbC8xMzk4XG4gICAgICBzZXQoe1xuICAgICAgICBjb250cm9sc1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gKCkgPT4gc2V0KHtcbiAgICAgICAgY29udHJvbHM6IG9sZFxuICAgICAgfSk7XG4gICAgfVxuICB9LCBbbWFrZURlZmF1bHQsIGNvbnRyb2xzXSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInByaW1pdGl2ZVwiLCBfZXh0ZW5kcyh7XG4gICAgcmVmOiByZWYsXG4gICAgb2JqZWN0OiBjb250cm9scyxcbiAgICBlbmFibGVEYW1waW5nOiBlbmFibGVEYW1waW5nXG4gIH0sIHJlc3RQcm9wcykpO1xufSk7XG5cbmV4cG9ydCB7IE9yYml0Q29udHJvbHMgfTtcbiJdLCJuYW1lcyI6WyJfZXh0ZW5kcyIsInVzZVRocmVlIiwidXNlRnJhbWUiLCJSZWFjdCIsIk9yYml0Q29udHJvbHMiLCJPcmJpdENvbnRyb2xzJDEiLCJmb3J3YXJkUmVmIiwibWFrZURlZmF1bHQiLCJjYW1lcmEiLCJyZWdyZXNzIiwiZG9tRWxlbWVudCIsImVuYWJsZURhbXBpbmciLCJrZXlFdmVudHMiLCJvbkNoYW5nZSIsIm9uU3RhcnQiLCJvbkVuZCIsInJlc3RQcm9wcyIsInJlZiIsImludmFsaWRhdGUiLCJzdGF0ZSIsImRlZmF1bHRDYW1lcmEiLCJnbCIsImV2ZW50cyIsInNldEV2ZW50cyIsInNldCIsImdldCIsInBlcmZvcm1hbmNlIiwiZXhwbENhbWVyYSIsImV4cGxEb21FbGVtZW50IiwiY29ubmVjdGVkIiwiY29udHJvbHMiLCJ1c2VNZW1vIiwiZW5hYmxlZCIsInVwZGF0ZSIsInVzZUVmZmVjdCIsImNvbm5lY3QiLCJkaXNwb3NlIiwiY2FsbGJhY2siLCJlIiwib25TdGFydENiIiwib25FbmRDYiIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwib2xkIiwiY3JlYXRlRWxlbWVudCIsIm9iamVjdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/core/OrbitControls.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/core/Text.js":
/*!*****************************************************!*\
  !*** ./node_modules/@react-three/drei/core/Text.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Text: () => (/* binding */ Text)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var troika_three_text__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! troika-three-text */ \"(ssr)/./node_modules/troika-three-text/dist/troika-three-text.esm.js\");\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-three/fiber */ \"(ssr)/./node_modules/@react-three/fiber/dist/index-673ef987.esm.js\");\n/* harmony import */ var suspend_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! suspend-react */ \"(ssr)/./node_modules/suspend-react/index.js\");\n\n\n\n\n\nconst Text = /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(({ sdfGlyphSize = 64, anchorX = \"center\", anchorY = \"middle\", font, fontSize = 1, children, characters, onSync, ...props }, ref)=>{\n    const invalidate = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.z)(({ invalidate })=>invalidate);\n    const [troikaMesh] = react__WEBPACK_IMPORTED_MODULE_1__.useState(()=>new troika_three_text__WEBPACK_IMPORTED_MODULE_3__.Text());\n    const [nodes, text] = react__WEBPACK_IMPORTED_MODULE_1__.useMemo(()=>{\n        const n = [];\n        let t = \"\";\n        react__WEBPACK_IMPORTED_MODULE_1__.Children.forEach(children, (child)=>{\n            if (typeof child === \"string\" || typeof child === \"number\") {\n                t += child;\n            } else {\n                n.push(child);\n            }\n        });\n        return [\n            n,\n            t\n        ];\n    }, [\n        children\n    ]);\n    (0,suspend_react__WEBPACK_IMPORTED_MODULE_4__.suspend)(()=>new Promise((res)=>(0,troika_three_text__WEBPACK_IMPORTED_MODULE_3__.preloadFont)({\n                font,\n                characters\n            }, res)), [\n        \"troika-text\",\n        font,\n        characters\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect(()=>void troikaMesh.sync(()=>{\n            invalidate();\n            if (onSync) onSync(troikaMesh);\n        }));\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect(()=>{\n        return ()=>troikaMesh.dispose();\n    }, [\n        troikaMesh\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"primitive\", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        object: troikaMesh,\n        ref: ref,\n        font: font,\n        text: text,\n        anchorX: anchorX,\n        anchorY: anchorY,\n        fontSize: fontSize,\n        sdfGlyphSize: sdfGlyphSize\n    }, props), nodes);\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9UZXh0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBMEQ7QUFDM0I7QUFDaUM7QUFDbEI7QUFDTjtBQUV4QyxNQUFNRSxPQUFPLGFBQWEsaUJBQUVELDZDQUFnQixDQUFDLENBQUMsRUFDNUNPLGVBQWUsRUFBRSxFQUNqQkMsVUFBVSxRQUFRLEVBQ2xCQyxVQUFVLFFBQVEsRUFDbEJDLElBQUksRUFDSkMsV0FBVyxDQUFDLEVBQ1pDLFFBQVEsRUFDUkMsVUFBVSxFQUNWQyxNQUFNLEVBQ04sR0FBR0MsT0FDSixFQUFFQztJQUNELE1BQU1DLGFBQWFiLHFEQUFRQSxDQUFDLENBQUMsRUFDM0JhLFVBQVUsRUFDWCxHQUFLQTtJQUNOLE1BQU0sQ0FBQ0MsV0FBVyxHQUFHbEIsMkNBQWMsQ0FBQyxJQUFNLElBQUlFLG1EQUFNQTtJQUNwRCxNQUFNLENBQUNrQixPQUFPQyxLQUFLLEdBQUdyQiwwQ0FBYSxDQUFDO1FBQ2xDLE1BQU11QixJQUFJLEVBQUU7UUFDWixJQUFJQyxJQUFJO1FBQ1J4QiwyQ0FBYyxDQUFDMEIsT0FBTyxDQUFDZCxVQUFVZSxDQUFBQTtZQUMvQixJQUFJLE9BQU9BLFVBQVUsWUFBWSxPQUFPQSxVQUFVLFVBQVU7Z0JBQzFESCxLQUFLRztZQUNQLE9BQU87Z0JBQ0xKLEVBQUVLLElBQUksQ0FBQ0Q7WUFDVDtRQUNGO1FBQ0EsT0FBTztZQUFDSjtZQUFHQztTQUFFO0lBQ2YsR0FBRztRQUFDWjtLQUFTO0lBQ2JQLHNEQUFPQSxDQUFDLElBQU0sSUFBSXdCLFFBQVFDLENBQUFBLE1BQU8zQiw4REFBV0EsQ0FBQztnQkFDM0NPO2dCQUNBRztZQUNGLEdBQUdpQixPQUFPO1FBQUM7UUFBZXBCO1FBQU1HO0tBQVc7SUFDM0NiLGtEQUFxQixDQUFDLElBQU0sS0FBS2tCLFdBQVdjLElBQUksQ0FBQztZQUMvQ2Y7WUFDQSxJQUFJSCxRQUFRQSxPQUFPSTtRQUNyQjtJQUNBbEIsNENBQWUsQ0FBQztRQUNkLE9BQU8sSUFBTWtCLFdBQVdnQixPQUFPO0lBQ2pDLEdBQUc7UUFBQ2hCO0tBQVc7SUFDZixPQUFPLFdBQVcsR0FBRWxCLGdEQUFtQixDQUFDLGFBQWFELDhFQUFRQSxDQUFDO1FBQzVEcUMsUUFBUWxCO1FBQ1JGLEtBQUtBO1FBQ0xOLE1BQU1BO1FBQ05XLE1BQU1BO1FBQ05iLFNBQVNBO1FBQ1RDLFNBQVNBO1FBQ1RFLFVBQVVBO1FBQ1ZKLGNBQWNBO0lBQ2hCLEdBQUdRLFFBQVFLO0FBQ2I7QUFFZ0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teVZScHJvamVjdC8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZHJlaS9jb3JlL1RleHQuanM/Y2M5ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgX2V4dGVuZHMgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kcyc7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBUZXh0IGFzIFRleHQkMSwgcHJlbG9hZEZvbnQgfSBmcm9tICd0cm9pa2EtdGhyZWUtdGV4dCc7XG5pbXBvcnQgeyB1c2VUaHJlZSB9IGZyb20gJ0ByZWFjdC10aHJlZS9maWJlcic7XG5pbXBvcnQgeyBzdXNwZW5kIH0gZnJvbSAnc3VzcGVuZC1yZWFjdCc7XG5cbmNvbnN0IFRleHQgPSAvKiBAX19QVVJFX18gKi9SZWFjdC5mb3J3YXJkUmVmKCh7XG4gIHNkZkdseXBoU2l6ZSA9IDY0LFxuICBhbmNob3JYID0gJ2NlbnRlcicsXG4gIGFuY2hvclkgPSAnbWlkZGxlJyxcbiAgZm9udCxcbiAgZm9udFNpemUgPSAxLFxuICBjaGlsZHJlbixcbiAgY2hhcmFjdGVycyxcbiAgb25TeW5jLFxuICAuLi5wcm9wc1xufSwgcmVmKSA9PiB7XG4gIGNvbnN0IGludmFsaWRhdGUgPSB1c2VUaHJlZSgoe1xuICAgIGludmFsaWRhdGVcbiAgfSkgPT4gaW52YWxpZGF0ZSk7XG4gIGNvbnN0IFt0cm9pa2FNZXNoXSA9IFJlYWN0LnVzZVN0YXRlKCgpID0+IG5ldyBUZXh0JDEoKSk7XG4gIGNvbnN0IFtub2RlcywgdGV4dF0gPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBjb25zdCBuID0gW107XG4gICAgbGV0IHQgPSAnJztcbiAgICBSZWFjdC5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCBjaGlsZCA9PiB7XG4gICAgICBpZiAodHlwZW9mIGNoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgY2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHQgKz0gY2hpbGQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuLnB1c2goY2hpbGQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBbbiwgdF07XG4gIH0sIFtjaGlsZHJlbl0pO1xuICBzdXNwZW5kKCgpID0+IG5ldyBQcm9taXNlKHJlcyA9PiBwcmVsb2FkRm9udCh7XG4gICAgZm9udCxcbiAgICBjaGFyYWN0ZXJzXG4gIH0sIHJlcykpLCBbJ3Ryb2lrYS10ZXh0JywgZm9udCwgY2hhcmFjdGVyc10pO1xuICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4gdm9pZCB0cm9pa2FNZXNoLnN5bmMoKCkgPT4ge1xuICAgIGludmFsaWRhdGUoKTtcbiAgICBpZiAob25TeW5jKSBvblN5bmModHJvaWthTWVzaCk7XG4gIH0pKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gKCkgPT4gdHJvaWthTWVzaC5kaXNwb3NlKCk7XG4gIH0sIFt0cm9pa2FNZXNoXSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInByaW1pdGl2ZVwiLCBfZXh0ZW5kcyh7XG4gICAgb2JqZWN0OiB0cm9pa2FNZXNoLFxuICAgIHJlZjogcmVmLFxuICAgIGZvbnQ6IGZvbnQsXG4gICAgdGV4dDogdGV4dCxcbiAgICBhbmNob3JYOiBhbmNob3JYLFxuICAgIGFuY2hvclk6IGFuY2hvclksXG4gICAgZm9udFNpemU6IGZvbnRTaXplLFxuICAgIHNkZkdseXBoU2l6ZTogc2RmR2x5cGhTaXplXG4gIH0sIHByb3BzKSwgbm9kZXMpO1xufSk7XG5cbmV4cG9ydCB7IFRleHQgfTtcbiJdLCJuYW1lcyI6WyJfZXh0ZW5kcyIsIlJlYWN0IiwiVGV4dCIsIlRleHQkMSIsInByZWxvYWRGb250IiwidXNlVGhyZWUiLCJzdXNwZW5kIiwiZm9yd2FyZFJlZiIsInNkZkdseXBoU2l6ZSIsImFuY2hvclgiLCJhbmNob3JZIiwiZm9udCIsImZvbnRTaXplIiwiY2hpbGRyZW4iLCJjaGFyYWN0ZXJzIiwib25TeW5jIiwicHJvcHMiLCJyZWYiLCJpbnZhbGlkYXRlIiwidHJvaWthTWVzaCIsInVzZVN0YXRlIiwibm9kZXMiLCJ0ZXh0IiwidXNlTWVtbyIsIm4iLCJ0IiwiQ2hpbGRyZW4iLCJmb3JFYWNoIiwiY2hpbGQiLCJwdXNoIiwiUHJvbWlzZSIsInJlcyIsInVzZUxheW91dEVmZmVjdCIsInN5bmMiLCJ1c2VFZmZlY3QiLCJkaXNwb3NlIiwiY3JlYXRlRWxlbWVudCIsIm9iamVjdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/core/Text.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/core/shapes.js":
/*!*******************************************************!*\
  !*** ./node_modules/@react-three/drei/core/shapes.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Box: () => (/* binding */ Box),\n/* harmony export */   Capsule: () => (/* binding */ Capsule),\n/* harmony export */   Circle: () => (/* binding */ Circle),\n/* harmony export */   Cone: () => (/* binding */ Cone),\n/* harmony export */   Cylinder: () => (/* binding */ Cylinder),\n/* harmony export */   Dodecahedron: () => (/* binding */ Dodecahedron),\n/* harmony export */   Extrude: () => (/* binding */ Extrude),\n/* harmony export */   Icosahedron: () => (/* binding */ Icosahedron),\n/* harmony export */   Lathe: () => (/* binding */ Lathe),\n/* harmony export */   Octahedron: () => (/* binding */ Octahedron),\n/* harmony export */   Plane: () => (/* binding */ Plane),\n/* harmony export */   Polyhedron: () => (/* binding */ Polyhedron),\n/* harmony export */   Ring: () => (/* binding */ Ring),\n/* harmony export */   Shape: () => (/* binding */ Shape),\n/* harmony export */   Sphere: () => (/* binding */ Sphere),\n/* harmony export */   Tetrahedron: () => (/* binding */ Tetrahedron),\n/* harmony export */   Torus: () => (/* binding */ Torus),\n/* harmony export */   TorusKnot: () => (/* binding */ TorusKnot),\n/* harmony export */   Tube: () => (/* binding */ Tube)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n\n\n\nfunction create(type, effect) {\n    const El = type + \"Geometry\";\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(({ args, children, ...props }, fref)=>{\n        const ref = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n        react__WEBPACK_IMPORTED_MODULE_1__.useImperativeHandle(fref, ()=>ref.current);\n        react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect(()=>void (effect == null ? void 0 : effect(ref.current)));\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"mesh\", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n            ref: ref\n        }, props), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(El, {\n            attach: \"geometry\",\n            args: args\n        }), children);\n    });\n}\nconst Box = /* @__PURE__ */ create(\"box\");\nconst Circle = /* @__PURE__ */ create(\"circle\");\nconst Cone = /* @__PURE__ */ create(\"cone\");\nconst Cylinder = /* @__PURE__ */ create(\"cylinder\");\nconst Sphere = /* @__PURE__ */ create(\"sphere\");\nconst Plane = /* @__PURE__ */ create(\"plane\");\nconst Tube = /* @__PURE__ */ create(\"tube\");\nconst Torus = /* @__PURE__ */ create(\"torus\");\nconst TorusKnot = /* @__PURE__ */ create(\"torusKnot\");\nconst Tetrahedron = /* @__PURE__ */ create(\"tetrahedron\");\nconst Ring = /* @__PURE__ */ create(\"ring\");\nconst Polyhedron = /* @__PURE__ */ create(\"polyhedron\");\nconst Icosahedron = /* @__PURE__ */ create(\"icosahedron\");\nconst Octahedron = /* @__PURE__ */ create(\"octahedron\");\nconst Dodecahedron = /* @__PURE__ */ create(\"dodecahedron\");\nconst Extrude = /* @__PURE__ */ create(\"extrude\");\nconst Lathe = /* @__PURE__ */ create(\"lathe\");\nconst Capsule = /* @__PURE__ */ create(\"capsule\");\nconst Shape = /* @__PURE__ */ create(\"shape\", ({ geometry })=>{\n    // Calculate UVs (by https://discourse.threejs.org/u/prisoner849)\n    // https://discourse.threejs.org/t/custom-shape-in-image-not-working/49348/10\n    const pos = geometry.attributes.position;\n    const b3 = new three__WEBPACK_IMPORTED_MODULE_2__.Box3().setFromBufferAttribute(pos);\n    const b3size = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n    b3.getSize(b3size);\n    const uv = [];\n    let x = 0, y = 0, u = 0, v = 0;\n    for(let i = 0; i < pos.count; i++){\n        x = pos.getX(i);\n        y = pos.getY(i);\n        u = (x - b3.min.x) / b3size.x;\n        v = (y - b3.min.y) / b3size.y;\n        uv.push(u, v);\n    }\n    geometry.setAttribute(\"uv\", new three__WEBPACK_IMPORTED_MODULE_2__.Float32BufferAttribute(uv, 2));\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9zaGFwZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBMEQ7QUFDM0I7QUFDQTtBQUUvQixTQUFTRyxPQUFPQyxJQUFJLEVBQUVDLE1BQU07SUFDMUIsTUFBTUMsS0FBS0YsT0FBTztJQUNsQixPQUFPLFdBQVcsR0FBRUgsNkNBQWdCLENBQUMsQ0FBQyxFQUNwQ08sSUFBSSxFQUNKQyxRQUFRLEVBQ1IsR0FBR0MsT0FDSixFQUFFQztRQUNELE1BQU1DLE1BQU1YLHlDQUFZLENBQUM7UUFDekJBLHNEQUF5QixDQUFDVSxNQUFNLElBQU1DLElBQUlHLE9BQU87UUFDakRkLGtEQUFxQixDQUFDLElBQU0sS0FBTUksQ0FBQUEsVUFBVSxPQUFPLEtBQUssSUFBSUEsT0FBT08sSUFBSUcsT0FBTztRQUM5RSxPQUFPLFdBQVcsR0FBRWQsZ0RBQW1CLENBQUMsUUFBUUQsOEVBQVFBLENBQUM7WUFDdkRZLEtBQUtBO1FBQ1AsR0FBR0YsUUFBUSxXQUFXLEdBQUVULGdEQUFtQixDQUFDSyxJQUFJO1lBQzlDWSxRQUFRO1lBQ1JWLE1BQU1BO1FBQ1IsSUFBSUM7SUFDTjtBQUNGO0FBQ0EsTUFBTVUsTUFBTSxhQUFhLEdBQUVoQixPQUFPO0FBQ2xDLE1BQU1pQixTQUFTLGFBQWEsR0FBRWpCLE9BQU87QUFDckMsTUFBTWtCLE9BQU8sYUFBYSxHQUFFbEIsT0FBTztBQUNuQyxNQUFNbUIsV0FBVyxhQUFhLEdBQUVuQixPQUFPO0FBQ3ZDLE1BQU1vQixTQUFTLGFBQWEsR0FBRXBCLE9BQU87QUFDckMsTUFBTXFCLFFBQVEsYUFBYSxHQUFFckIsT0FBTztBQUNwQyxNQUFNc0IsT0FBTyxhQUFhLEdBQUV0QixPQUFPO0FBQ25DLE1BQU11QixRQUFRLGFBQWEsR0FBRXZCLE9BQU87QUFDcEMsTUFBTXdCLFlBQVksYUFBYSxHQUFFeEIsT0FBTztBQUN4QyxNQUFNeUIsY0FBYyxhQUFhLEdBQUV6QixPQUFPO0FBQzFDLE1BQU0wQixPQUFPLGFBQWEsR0FBRTFCLE9BQU87QUFDbkMsTUFBTTJCLGFBQWEsYUFBYSxHQUFFM0IsT0FBTztBQUN6QyxNQUFNNEIsY0FBYyxhQUFhLEdBQUU1QixPQUFPO0FBQzFDLE1BQU02QixhQUFhLGFBQWEsR0FBRTdCLE9BQU87QUFDekMsTUFBTThCLGVBQWUsYUFBYSxHQUFFOUIsT0FBTztBQUMzQyxNQUFNK0IsVUFBVSxhQUFhLEdBQUUvQixPQUFPO0FBQ3RDLE1BQU1nQyxRQUFRLGFBQWEsR0FBRWhDLE9BQU87QUFDcEMsTUFBTWlDLFVBQVUsYUFBYSxHQUFFakMsT0FBTztBQUN0QyxNQUFNa0MsUUFBUSxhQUFhLEdBQUVsQyxPQUFPLFNBQVMsQ0FBQyxFQUM1Q21DLFFBQVEsRUFDVDtJQUNDLGlFQUFpRTtJQUNqRSw2RUFBNkU7SUFDN0UsTUFBTUMsTUFBTUQsU0FBU0UsVUFBVSxDQUFDQyxRQUFRO0lBQ3hDLE1BQU1DLEtBQUssSUFBSXhDLHVDQUFVLEdBQUcwQyxzQkFBc0IsQ0FBQ0w7SUFDbkQsTUFBTU0sU0FBUyxJQUFJM0MsMENBQWE7SUFDaEN3QyxHQUFHSyxPQUFPLENBQUNGO0lBQ1gsTUFBTUcsS0FBSyxFQUFFO0lBQ2IsSUFBSUMsSUFBSSxHQUNOQyxJQUFJLEdBQ0pDLElBQUksR0FDSkMsSUFBSTtJQUNOLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJZCxJQUFJZSxLQUFLLEVBQUVELElBQUs7UUFDbENKLElBQUlWLElBQUlnQixJQUFJLENBQUNGO1FBQ2JILElBQUlYLElBQUlpQixJQUFJLENBQUNIO1FBQ2JGLElBQUksQ0FBQ0YsSUFBSVAsR0FBR2UsR0FBRyxDQUFDUixDQUFDLElBQUlKLE9BQU9JLENBQUM7UUFDN0JHLElBQUksQ0FBQ0YsSUFBSVIsR0FBR2UsR0FBRyxDQUFDUCxDQUFDLElBQUlMLE9BQU9LLENBQUM7UUFDN0JGLEdBQUdVLElBQUksQ0FBQ1AsR0FBR0M7SUFDYjtJQUNBZCxTQUFTcUIsWUFBWSxDQUFDLE1BQU0sSUFBSXpELHlEQUE0QixDQUFDOEMsSUFBSTtBQUNuRTtBQUVvTCIsInNvdXJjZXMiOlsid2VicGFjazovL215VlJwcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL0ByZWFjdC10aHJlZS9kcmVpL2NvcmUvc2hhcGVzLmpzP2FmZWYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF9leHRlbmRzIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHMnO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnO1xuXG5mdW5jdGlvbiBjcmVhdGUodHlwZSwgZWZmZWN0KSB7XG4gIGNvbnN0IEVsID0gdHlwZSArICdHZW9tZXRyeSc7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZigoe1xuICAgIGFyZ3MsXG4gICAgY2hpbGRyZW4sXG4gICAgLi4ucHJvcHNcbiAgfSwgZnJlZikgPT4ge1xuICAgIGNvbnN0IHJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgICBSZWFjdC51c2VJbXBlcmF0aXZlSGFuZGxlKGZyZWYsICgpID0+IHJlZi5jdXJyZW50KTtcbiAgICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4gdm9pZCAoZWZmZWN0ID09IG51bGwgPyB2b2lkIDAgOiBlZmZlY3QocmVmLmN1cnJlbnQpKSk7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwibWVzaFwiLCBfZXh0ZW5kcyh7XG4gICAgICByZWY6IHJlZlxuICAgIH0sIHByb3BzKSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRWwsIHtcbiAgICAgIGF0dGFjaDogXCJnZW9tZXRyeVwiLFxuICAgICAgYXJnczogYXJnc1xuICAgIH0pLCBjaGlsZHJlbik7XG4gIH0pO1xufVxuY29uc3QgQm94ID0gLyogQF9fUFVSRV9fICovY3JlYXRlKCdib3gnKTtcbmNvbnN0IENpcmNsZSA9IC8qIEBfX1BVUkVfXyAqL2NyZWF0ZSgnY2lyY2xlJyk7XG5jb25zdCBDb25lID0gLyogQF9fUFVSRV9fICovY3JlYXRlKCdjb25lJyk7XG5jb25zdCBDeWxpbmRlciA9IC8qIEBfX1BVUkVfXyAqL2NyZWF0ZSgnY3lsaW5kZXInKTtcbmNvbnN0IFNwaGVyZSA9IC8qIEBfX1BVUkVfXyAqL2NyZWF0ZSgnc3BoZXJlJyk7XG5jb25zdCBQbGFuZSA9IC8qIEBfX1BVUkVfXyAqL2NyZWF0ZSgncGxhbmUnKTtcbmNvbnN0IFR1YmUgPSAvKiBAX19QVVJFX18gKi9jcmVhdGUoJ3R1YmUnKTtcbmNvbnN0IFRvcnVzID0gLyogQF9fUFVSRV9fICovY3JlYXRlKCd0b3J1cycpO1xuY29uc3QgVG9ydXNLbm90ID0gLyogQF9fUFVSRV9fICovY3JlYXRlKCd0b3J1c0tub3QnKTtcbmNvbnN0IFRldHJhaGVkcm9uID0gLyogQF9fUFVSRV9fICovY3JlYXRlKCd0ZXRyYWhlZHJvbicpO1xuY29uc3QgUmluZyA9IC8qIEBfX1BVUkVfXyAqL2NyZWF0ZSgncmluZycpO1xuY29uc3QgUG9seWhlZHJvbiA9IC8qIEBfX1BVUkVfXyAqL2NyZWF0ZSgncG9seWhlZHJvbicpO1xuY29uc3QgSWNvc2FoZWRyb24gPSAvKiBAX19QVVJFX18gKi9jcmVhdGUoJ2ljb3NhaGVkcm9uJyk7XG5jb25zdCBPY3RhaGVkcm9uID0gLyogQF9fUFVSRV9fICovY3JlYXRlKCdvY3RhaGVkcm9uJyk7XG5jb25zdCBEb2RlY2FoZWRyb24gPSAvKiBAX19QVVJFX18gKi9jcmVhdGUoJ2RvZGVjYWhlZHJvbicpO1xuY29uc3QgRXh0cnVkZSA9IC8qIEBfX1BVUkVfXyAqL2NyZWF0ZSgnZXh0cnVkZScpO1xuY29uc3QgTGF0aGUgPSAvKiBAX19QVVJFX18gKi9jcmVhdGUoJ2xhdGhlJyk7XG5jb25zdCBDYXBzdWxlID0gLyogQF9fUFVSRV9fICovY3JlYXRlKCdjYXBzdWxlJyk7XG5jb25zdCBTaGFwZSA9IC8qIEBfX1BVUkVfXyAqL2NyZWF0ZSgnc2hhcGUnLCAoe1xuICBnZW9tZXRyeVxufSkgPT4ge1xuICAvLyBDYWxjdWxhdGUgVVZzIChieSBodHRwczovL2Rpc2NvdXJzZS50aHJlZWpzLm9yZy91L3ByaXNvbmVyODQ5KVxuICAvLyBodHRwczovL2Rpc2NvdXJzZS50aHJlZWpzLm9yZy90L2N1c3RvbS1zaGFwZS1pbi1pbWFnZS1ub3Qtd29ya2luZy80OTM0OC8xMFxuICBjb25zdCBwb3MgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuICBjb25zdCBiMyA9IG5ldyBUSFJFRS5Cb3gzKCkuc2V0RnJvbUJ1ZmZlckF0dHJpYnV0ZShwb3MpO1xuICBjb25zdCBiM3NpemUgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICBiMy5nZXRTaXplKGIzc2l6ZSk7XG4gIGNvbnN0IHV2ID0gW107XG4gIGxldCB4ID0gMCxcbiAgICB5ID0gMCxcbiAgICB1ID0gMCxcbiAgICB2ID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb3MuY291bnQ7IGkrKykge1xuICAgIHggPSBwb3MuZ2V0WChpKTtcbiAgICB5ID0gcG9zLmdldFkoaSk7XG4gICAgdSA9ICh4IC0gYjMubWluLngpIC8gYjNzaXplLng7XG4gICAgdiA9ICh5IC0gYjMubWluLnkpIC8gYjNzaXplLnk7XG4gICAgdXYucHVzaCh1LCB2KTtcbiAgfVxuICBnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ3V2JywgbmV3IFRIUkVFLkZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUodXYsIDIpKTtcbn0pO1xuXG5leHBvcnQgeyBCb3gsIENhcHN1bGUsIENpcmNsZSwgQ29uZSwgQ3lsaW5kZXIsIERvZGVjYWhlZHJvbiwgRXh0cnVkZSwgSWNvc2FoZWRyb24sIExhdGhlLCBPY3RhaGVkcm9uLCBQbGFuZSwgUG9seWhlZHJvbiwgUmluZywgU2hhcGUsIFNwaGVyZSwgVGV0cmFoZWRyb24sIFRvcnVzLCBUb3J1c0tub3QsIFR1YmUgfTtcbiJdLCJuYW1lcyI6WyJfZXh0ZW5kcyIsIlJlYWN0IiwiVEhSRUUiLCJjcmVhdGUiLCJ0eXBlIiwiZWZmZWN0IiwiRWwiLCJmb3J3YXJkUmVmIiwiYXJncyIsImNoaWxkcmVuIiwicHJvcHMiLCJmcmVmIiwicmVmIiwidXNlUmVmIiwidXNlSW1wZXJhdGl2ZUhhbmRsZSIsImN1cnJlbnQiLCJ1c2VMYXlvdXRFZmZlY3QiLCJjcmVhdGVFbGVtZW50IiwiYXR0YWNoIiwiQm94IiwiQ2lyY2xlIiwiQ29uZSIsIkN5bGluZGVyIiwiU3BoZXJlIiwiUGxhbmUiLCJUdWJlIiwiVG9ydXMiLCJUb3J1c0tub3QiLCJUZXRyYWhlZHJvbiIsIlJpbmciLCJQb2x5aGVkcm9uIiwiSWNvc2FoZWRyb24iLCJPY3RhaGVkcm9uIiwiRG9kZWNhaGVkcm9uIiwiRXh0cnVkZSIsIkxhdGhlIiwiQ2Fwc3VsZSIsIlNoYXBlIiwiZ2VvbWV0cnkiLCJwb3MiLCJhdHRyaWJ1dGVzIiwicG9zaXRpb24iLCJiMyIsIkJveDMiLCJzZXRGcm9tQnVmZmVyQXR0cmlidXRlIiwiYjNzaXplIiwiVmVjdG9yMyIsImdldFNpemUiLCJ1diIsIngiLCJ5IiwidSIsInYiLCJpIiwiY291bnQiLCJnZXRYIiwiZ2V0WSIsIm1pbiIsInB1c2giLCJzZXRBdHRyaWJ1dGUiLCJGbG9hdDMyQnVmZmVyQXR0cmlidXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/core/shapes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/core/useEnvironment.js":
/*!***************************************************************!*\
  !*** ./node_modules/@react-three/drei/core/useEnvironment.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useEnvironment: () => (/* binding */ useEnvironment)\n/* harmony export */ });\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-three/fiber */ \"(ssr)/./node_modules/@react-three/fiber/dist/index-673ef987.esm.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n/* harmony import */ var three_stdlib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! three-stdlib */ \"(ssr)/./node_modules/three-stdlib/loaders/RGBELoader.js\");\n/* harmony import */ var three_stdlib__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! three-stdlib */ \"(ssr)/./node_modules/three-stdlib/loaders/EXRLoader.js\");\n/* harmony import */ var _monogrid_gainmap_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @monogrid/gainmap-js */ \"(ssr)/./node_modules/@monogrid/gainmap-js/dist/decode.js\");\n/* harmony import */ var _helpers_environment_assets_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/environment-assets.js */ \"(ssr)/./node_modules/@react-three/drei/helpers/environment-assets.js\");\n/* harmony import */ var _helpers_deprecated_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../helpers/deprecated.js */ \"(ssr)/./node_modules/@react-three/drei/helpers/deprecated.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n\n\n\n\n\n\nconst CUBEMAP_ROOT = \"https://raw.githack.com/pmndrs/drei-assets/456060a26bbeb8fdf79326f224b6d99b8bcce736/hdri/\";\nconst isArray = (arr)=>Array.isArray(arr);\nconst defaultFiles = [\n    \"/px.png\",\n    \"/nx.png\",\n    \"/py.png\",\n    \"/ny.png\",\n    \"/pz.png\",\n    \"/nz.png\"\n];\nfunction useEnvironment({ files = defaultFiles, path = \"\", preset = undefined, encoding = undefined, extensions } = {}) {\n    let loader = null;\n    let multiFile = false;\n    if (preset) {\n        validatePreset(preset);\n        files = _helpers_environment_assets_js__WEBPACK_IMPORTED_MODULE_1__.presetsObj[preset];\n        path = CUBEMAP_ROOT;\n    }\n    // Everything else\n    multiFile = isArray(files);\n    const { extension, isCubemap } = getExtension(files);\n    loader = getLoader(extension);\n    if (!loader) throw new Error(\"useEnvironment: Unrecognized file extension: \" + files);\n    const gl = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.z)((state)=>state.gl);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(()=>{\n        // Only required for gainmap\n        if (extension !== \"webp\" && extension !== \"jpg\" && extension !== \"jpeg\") return;\n        function clearGainmapTexture() {\n            _react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.D.clear(// @ts-expect-error\n            loader, multiFile ? [\n                files\n            ] : files);\n        }\n        gl.domElement.addEventListener(\"webglcontextlost\", clearGainmapTexture, {\n            once: true\n        });\n    }, [\n        files,\n        gl.domElement\n    ]);\n    const loaderResult = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.D)(// @ts-expect-error\n    loader, multiFile ? [\n        files\n    ] : files, (loader)=>{\n        // Gainmap requires a renderer\n        if (extension === \"webp\" || extension === \"jpg\" || extension === \"jpeg\") {\n            loader.setRenderer(gl);\n        }\n        loader.setPath == null || loader.setPath(path);\n        if (extensions) extensions(loader);\n    });\n    let texture = multiFile ? // @ts-ignore\n    loaderResult[0] : loaderResult;\n    if (extension === \"jpg\" || extension === \"jpeg\" || extension === \"webp\") {\n        var _renderTarget;\n        texture = (_renderTarget = texture.renderTarget) == null ? void 0 : _renderTarget.texture;\n    }\n    texture.mapping = isCubemap ? three__WEBPACK_IMPORTED_MODULE_3__.CubeReflectionMapping : three__WEBPACK_IMPORTED_MODULE_3__.EquirectangularReflectionMapping;\n    if (\"colorSpace\" in texture) texture.colorSpace = (encoding !== null && encoding !== void 0 ? encoding : isCubemap) ? \"srgb\" : \"srgb-linear\";\n    else texture.encoding = (encoding !== null && encoding !== void 0 ? encoding : isCubemap) ? _helpers_deprecated_js__WEBPACK_IMPORTED_MODULE_4__.sRGBEncoding : _helpers_deprecated_js__WEBPACK_IMPORTED_MODULE_4__.LinearEncoding;\n    return texture;\n}\nconst preloadDefaultOptions = {\n    files: defaultFiles,\n    path: \"\",\n    preset: undefined,\n    extensions: undefined\n};\nuseEnvironment.preload = (preloadOptions)=>{\n    const options = {\n        ...preloadDefaultOptions,\n        ...preloadOptions\n    };\n    let { files, path = \"\" } = options;\n    const { preset, extensions } = options;\n    if (preset) {\n        validatePreset(preset);\n        files = _helpers_environment_assets_js__WEBPACK_IMPORTED_MODULE_1__.presetsObj[preset];\n        path = CUBEMAP_ROOT;\n    }\n    const { extension } = getExtension(files);\n    if (extension === \"webp\" || extension === \"jpg\" || extension === \"jpeg\") {\n        throw new Error(\"useEnvironment: Preloading gainmaps is not supported\");\n    }\n    const loader = getLoader(extension);\n    if (!loader) throw new Error(\"useEnvironment: Unrecognized file extension: \" + files);\n    _react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.D.preload(// @ts-expect-error\n    loader, isArray(files) ? [\n        files\n    ] : files, (loader)=>{\n        loader.setPath == null || loader.setPath(path);\n        if (extensions) extensions(loader);\n    });\n};\nconst clearDefaultOptins = {\n    files: defaultFiles,\n    preset: undefined\n};\nuseEnvironment.clear = (clearOptions)=>{\n    const options = {\n        ...clearDefaultOptins,\n        ...clearOptions\n    };\n    let { files } = options;\n    const { preset } = options;\n    if (preset) {\n        validatePreset(preset);\n        files = _helpers_environment_assets_js__WEBPACK_IMPORTED_MODULE_1__.presetsObj[preset];\n    }\n    const { extension } = getExtension(files);\n    const loader = getLoader(extension);\n    if (!loader) throw new Error(\"useEnvironment: Unrecognized file extension: \" + files);\n    _react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.D.clear(// @ts-expect-error\n    loader, isArray(files) ? [\n        files\n    ] : files);\n};\nfunction validatePreset(preset) {\n    if (!(preset in _helpers_environment_assets_js__WEBPACK_IMPORTED_MODULE_1__.presetsObj)) throw new Error(\"Preset must be one of: \" + Object.keys(_helpers_environment_assets_js__WEBPACK_IMPORTED_MODULE_1__.presetsObj).join(\", \"));\n}\nfunction getExtension(files) {\n    var _firstEntry$split$pop;\n    const isCubemap = isArray(files) && files.length === 6;\n    const isGainmap = isArray(files) && files.length === 3 && files.some((file)=>file.endsWith(\"json\"));\n    const firstEntry = isArray(files) ? files[0] : files;\n    // Everything else\n    const extension = isCubemap ? \"cube\" : isGainmap ? \"webp\" : firstEntry.startsWith(\"data:application/exr\") ? \"exr\" : firstEntry.startsWith(\"data:application/hdr\") ? \"hdr\" : firstEntry.startsWith(\"data:image/jpeg\") ? \"jpg\" : (_firstEntry$split$pop = firstEntry.split(\".\").pop()) == null || (_firstEntry$split$pop = _firstEntry$split$pop.split(\"?\")) == null || (_firstEntry$split$pop = _firstEntry$split$pop.shift()) == null ? void 0 : _firstEntry$split$pop.toLowerCase();\n    return {\n        extension,\n        isCubemap,\n        isGainmap\n    };\n}\nfunction getLoader(extension) {\n    const loader = extension === \"cube\" ? three__WEBPACK_IMPORTED_MODULE_3__.CubeTextureLoader : extension === \"hdr\" ? three_stdlib__WEBPACK_IMPORTED_MODULE_5__.RGBELoader : extension === \"exr\" ? three_stdlib__WEBPACK_IMPORTED_MODULE_6__.EXRLoader : extension === \"jpg\" || extension === \"jpeg\" ? _monogrid_gainmap_js__WEBPACK_IMPORTED_MODULE_7__.HDRJPGLoader : extension === \"webp\" ? _monogrid_gainmap_js__WEBPACK_IMPORTED_MODULE_7__.GainMapLoader : null;\n    return loader;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS91c2VFbnZpcm9ubWVudC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQXlEO0FBQzBDO0FBQzlDO0FBQ2M7QUFDTDtBQUNVO0FBQ2hDO0FBRXhDLE1BQU1hLGVBQWU7QUFDckIsTUFBTUMsVUFBVUMsQ0FBQUEsTUFBT0MsTUFBTUYsT0FBTyxDQUFDQztBQUNyQyxNQUFNRSxlQUFlO0lBQUM7SUFBVztJQUFXO0lBQVc7SUFBVztJQUFXO0NBQVU7QUFDdkYsU0FBU0MsZUFBZSxFQUN0QkMsUUFBUUYsWUFBWSxFQUNwQkcsT0FBTyxFQUFFLEVBQ1RDLFNBQVNDLFNBQVMsRUFDbEJDLFdBQVdELFNBQVMsRUFDcEJFLFVBQVUsRUFDWCxHQUFHLENBQUMsQ0FBQztJQUNKLElBQUlDLFNBQVM7SUFDYixJQUFJQyxZQUFZO0lBQ2hCLElBQUlMLFFBQVE7UUFDVk0sZUFBZU47UUFDZkYsUUFBUVYsc0VBQVUsQ0FBQ1ksT0FBTztRQUMxQkQsT0FBT1A7SUFDVDtJQUVBLGtCQUFrQjtJQUNsQmEsWUFBWVosUUFBUUs7SUFDcEIsTUFBTSxFQUNKUyxTQUFTLEVBQ1RDLFNBQVMsRUFDVixHQUFHQyxhQUFhWDtJQUNqQk0sU0FBU00sVUFBVUg7SUFDbkIsSUFBSSxDQUFDSCxRQUFRLE1BQU0sSUFBSU8sTUFBTSxrREFBa0RiO0lBQy9FLE1BQU1jLEtBQUtqQyxxREFBUUEsQ0FBQ2tDLENBQUFBLFFBQVNBLE1BQU1ELEVBQUU7SUFDckNyQixzREFBZUEsQ0FBQztRQUNkLDRCQUE0QjtRQUM1QixJQUFJZ0IsY0FBYyxVQUFVQSxjQUFjLFNBQVNBLGNBQWMsUUFBUTtRQUN6RSxTQUFTTztZQUNQbEMsaURBQVNBLENBQUNtQyxLQUFLLENBQ2YsbUJBQW1CO1lBQ25CWCxRQUFRQyxZQUFZO2dCQUFDUDthQUFNLEdBQUdBO1FBQ2hDO1FBQ0FjLEdBQUdJLFVBQVUsQ0FBQ0MsZ0JBQWdCLENBQUMsb0JB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LG9EQUFpQkEsR0FBR3dCLGNBQWMsUUFBUXZCLG9EQUFVQSxHQUFHdUIsY0FBYyxRQUFRdEIsbURBQVNBLEdBQUdzQixjQUFjLFNBQVNBLGNBQWMsU0FBU3JCLDhEQUFZQSxHQUFHcUIsY0FBYyxTQUFTcEIsK0RBQWFBLEdBQUc7SUFDbk8sT0FBT2lCO0FBQ1Q7QUFFMEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teVZScHJvamVjdC8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZHJlaS9jb3JlL3VzZUVudmlyb25tZW50LmpzPzcwYzkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlVGhyZWUsIHVzZUxvYWRlciB9IGZyb20gJ0ByZWFjdC10aHJlZS9maWJlcic7XG5pbXBvcnQgeyBDdWJlUmVmbGVjdGlvbk1hcHBpbmcsIEVxdWlyZWN0YW5ndWxhclJlZmxlY3Rpb25NYXBwaW5nLCBDdWJlVGV4dHVyZUxvYWRlciB9IGZyb20gJ3RocmVlJztcbmltcG9ydCB7IFJHQkVMb2FkZXIsIEVYUkxvYWRlciB9IGZyb20gJ3RocmVlLXN0ZGxpYic7XG5pbXBvcnQgeyBIRFJKUEdMb2FkZXIsIEdhaW5NYXBMb2FkZXIgfSBmcm9tICdAbW9ub2dyaWQvZ2Fpbm1hcC1qcyc7XG5pbXBvcnQgeyBwcmVzZXRzT2JqIH0gZnJvbSAnLi4vaGVscGVycy9lbnZpcm9ubWVudC1hc3NldHMuanMnO1xuaW1wb3J0IHsgc1JHQkVuY29kaW5nLCBMaW5lYXJFbmNvZGluZyB9IGZyb20gJy4uL2hlbHBlcnMvZGVwcmVjYXRlZC5qcyc7XG5pbXBvcnQgeyB1c2VMYXlvdXRFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5cbmNvbnN0IENVQkVNQVBfUk9PVCA9ICdodHRwczovL3Jhdy5naXRoYWNrLmNvbS9wbW5kcnMvZHJlaS1hc3NldHMvNDU2MDYwYTI2YmJlYjhmZGY3OTMyNmYyMjRiNmQ5OWI4YmNjZTczNi9oZHJpLyc7XG5jb25zdCBpc0FycmF5ID0gYXJyID0+IEFycmF5LmlzQXJyYXkoYXJyKTtcbmNvbnN0IGRlZmF1bHRGaWxlcyA9IFsnL3B4LnBuZycsICcvbngucG5nJywgJy9weS5wbmcnLCAnL255LnBuZycsICcvcHoucG5nJywgJy9uei5wbmcnXTtcbmZ1bmN0aW9uIHVzZUVudmlyb25tZW50KHtcbiAgZmlsZXMgPSBkZWZhdWx0RmlsZXMsXG4gIHBhdGggPSAnJyxcbiAgcHJlc2V0ID0gdW5kZWZpbmVkLFxuICBlbmNvZGluZyA9IHVuZGVmaW5lZCxcbiAgZXh0ZW5zaW9uc1xufSA9IHt9KSB7XG4gIGxldCBsb2FkZXIgPSBudWxsO1xuICBsZXQgbXVsdGlGaWxlID0gZmFsc2U7XG4gIGlmIChwcmVzZXQpIHtcbiAgICB2YWxpZGF0ZVByZXNldChwcmVzZXQpO1xuICAgIGZpbGVzID0gcHJlc2V0c09ialtwcmVzZXRdO1xuICAgIHBhdGggPSBDVUJFTUFQX1JPT1Q7XG4gIH1cblxuICAvLyBFdmVyeXRoaW5nIGVsc2VcbiAgbXVsdGlGaWxlID0gaXNBcnJheShmaWxlcyk7XG4gIGNvbnN0IHtcbiAgICBleHRlbnNpb24sXG4gICAgaXNDdWJlbWFwXG4gIH0gPSBnZXRFeHRlbnNpb24oZmlsZXMpO1xuICBsb2FkZXIgPSBnZXRMb2FkZXIoZXh0ZW5zaW9uKTtcbiAgaWYgKCFsb2FkZXIpIHRocm93IG5ldyBFcnJvcigndXNlRW52aXJvbm1lbnQ6IFVucmVjb2duaXplZCBmaWxlIGV4dGVuc2lvbjogJyArIGZpbGVzKTtcbiAgY29uc3QgZ2wgPSB1c2VUaHJlZShzdGF0ZSA9PiBzdGF0ZS5nbCk7XG4gIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgLy8gT25seSByZXF1aXJlZCBmb3IgZ2Fpbm1hcFxuICAgIGlmIChleHRlbnNpb24gIT09ICd3ZWJwJyAmJiBleHRlbnNpb24gIT09ICdqcGcnICYmIGV4dGVuc2lvbiAhPT0gJ2pwZWcnKSByZXR1cm47XG4gICAgZnVuY3Rpb24gY2xlYXJHYWlubWFwVGV4dHVyZSgpIHtcbiAgICAgIHVzZUxvYWRlci5jbGVhcihcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgIGxvYWRlciwgbXVsdGlGaWxlID8gW2ZpbGVzXSA6IGZpbGVzKTtcbiAgICB9XG4gICAgZ2wuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd3ZWJnbGNvbnRleHRsb3N0JywgY2xlYXJHYWlubWFwVGV4dHVyZSwge1xuICAgICAgb25jZTogdHJ1ZVxuICAgIH0pO1xuICB9LCBbZmlsZXMsIGdsLmRvbUVsZW1lbnRdKTtcbiAgY29uc3QgbG9hZGVyUmVzdWx0ID0gdXNlTG9hZGVyKFxuICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gIGxvYWRlciwgbXVsdGlGaWxlID8gW2ZpbGVzXSA6IGZpbGVzLCBsb2FkZXIgPT4ge1xuICAgIC8vIEdhaW5tYXAgcmVxdWlyZXMgYSByZW5kZXJlclxuICAgIGlmIChleHRlbnNpb24gPT09ICd3ZWJwJyB8fCBleHRlbnNpb24gPT09ICdqcGcnIHx8IGV4dGVuc2lvbiA9PT0gJ2pwZWcnKSB7XG4gICAgICBsb2FkZXIuc2V0UmVuZGVyZXIoZ2wpO1xuICAgIH1cbiAgICBsb2FkZXIuc2V0UGF0aCA9PSBudWxsIHx8IGxvYWRlci5zZXRQYXRoKHBhdGgpO1xuICAgIGlmIChleHRlbnNpb25zKSBleHRlbnNpb25zKGxvYWRlcik7XG4gIH0pO1xuICBsZXQgdGV4dHVyZSA9IG11bHRpRmlsZSA/XG4gIC8vIEB0cy1pZ25vcmVcbiAgbG9hZGVyUmVzdWx0WzBdIDogbG9hZGVyUmVzdWx0O1xuICBpZiAoZXh0ZW5zaW9uID09PSAnanBnJyB8fCBleHRlbnNpb24gPT09ICdqcGVnJyB8fCBleHRlbnNpb24gPT09ICd3ZWJwJykge1xuICAgIHZhciBfcmVuZGVyVGFyZ2V0O1xuICAgIHRleHR1cmUgPSAoX3JlbmRlclRhcmdldCA9IHRleHR1cmUucmVuZGVyVGFyZ2V0KSA9PSBudWxsID8gdm9pZCAwIDogX3JlbmRlclRhcmdldC50ZXh0dXJlO1xuICB9XG4gIHRleHR1cmUubWFwcGluZyA9IGlzQ3ViZW1hcCA/IEN1YmVSZWZsZWN0aW9uTWFwcGluZyA6IEVxdWlyZWN0YW5ndWxhclJlZmxlY3Rpb25NYXBwaW5nO1xuICBpZiAoJ2NvbG9yU3BhY2UnIGluIHRleHR1cmUpIHRleHR1cmUuY29sb3JTcGFjZSA9IChlbmNvZGluZyAhPT0gbnVsbCAmJiBlbmNvZGluZyAhPT0gdm9pZCAwID8gZW5jb2RpbmcgOiBpc0N1YmVtYXApID8gJ3NyZ2InIDogJ3NyZ2ItbGluZWFyJztlbHNlIHRleHR1cmUuZW5jb2RpbmcgPSAoZW5jb2RpbmcgIT09IG51bGwgJiYgZW5jb2RpbmcgIT09IHZvaWQgMCA/IGVuY29kaW5nIDogaXNDdWJlbWFwKSA/IHNSR0JFbmNvZGluZyA6IExpbmVhckVuY29kaW5nO1xuICByZXR1cm4gdGV4dHVyZTtcbn1cbmNvbnN0IHByZWxvYWREZWZhdWx0T3B0aW9ucyA9IHtcbiAgZmlsZXM6IGRlZmF1bHRGaWxlcyxcbiAgcGF0aDogJycsXG4gIHByZXNldDogdW5kZWZpbmVkLFxuICBleHRlbnNpb25zOiB1bmRlZmluZWRcbn07XG51c2VFbnZpcm9ubWVudC5wcmVsb2FkID0gcHJlbG9hZE9wdGlvbnMgPT4ge1xuICBjb25zdCBvcHRpb25zID0ge1xuICAgIC4uLnByZWxvYWREZWZhdWx0T3B0aW9ucyxcbiAgICAuLi5wcmVsb2FkT3B0aW9uc1xuICB9O1xuICBsZXQge1xuICAgIGZpbGVzLFxuICAgIHBhdGggPSAnJ1xuICB9ID0gb3B0aW9ucztcbiAgY29uc3Qge1xuICAgIHByZXNldCxcbiAgICBleHRlbnNpb25zXG4gIH0gPSBvcHRpb25zO1xuICBpZiAocHJlc2V0KSB7XG4gICAgdmFsaWRhdGVQcmVzZXQocHJlc2V0KTtcbiAgICBmaWxlcyA9IHByZXNldHNPYmpbcHJlc2V0XTtcbiAgICBwYXRoID0gQ1VCRU1BUF9ST09UO1xuICB9XG4gIGNvbnN0IHtcbiAgICBleHRlbnNpb25cbiAgfSA9IGdldEV4dGVuc2lvbihmaWxlcyk7XG4gIGlmIChleHRlbnNpb24gPT09ICd3ZWJwJyB8fCBleHRlbnNpb24gPT09ICdqcGcnIHx8IGV4dGVuc2lvbiA9PT0gJ2pwZWcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1c2VFbnZpcm9ubWVudDogUHJlbG9hZGluZyBnYWlubWFwcyBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gIH1cbiAgY29uc3QgbG9hZGVyID0gZ2V0TG9hZGVyKGV4dGVuc2lvbik7XG4gIGlmICghbG9hZGVyKSB0aHJvdyBuZXcgRXJyb3IoJ3VzZUVudmlyb25tZW50OiBVbnJlY29nbml6ZWQgZmlsZSBleHRlbnNpb246ICcgKyBmaWxlcyk7XG4gIHVzZUxvYWRlci5wcmVsb2FkKFxuICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gIGxvYWRlciwgaXNBcnJheShmaWxlcykgPyBbZmlsZXNdIDogZmlsZXMsIGxvYWRlciA9PiB7XG4gICAgbG9hZGVyLnNldFBhdGggPT0gbnVsbCB8fCBsb2FkZXIuc2V0UGF0aChwYXRoKTtcbiAgICBpZiAoZXh0ZW5zaW9ucykgZXh0ZW5zaW9ucyhsb2FkZXIpO1xuICB9KTtcbn07XG5jb25zdCBjbGVhckRlZmF1bHRPcHRpbnMgPSB7XG4gIGZpbGVzOiBkZWZhdWx0RmlsZXMsXG4gIHByZXNldDogdW5kZWZpbmVkXG59O1xudXNlRW52aXJvbm1lbnQuY2xlYXIgPSBjbGVhck9wdGlvbnMgPT4ge1xuICBjb25zdCBvcHRpb25zID0ge1xuICAgIC4uLmNsZWFyRGVmYXVsdE9wdGlucyxcbiAgICAuLi5jbGVhck9wdGlvbnNcbiAgfTtcbiAgbGV0IHtcbiAgICBmaWxlc1xuICB9ID0gb3B0aW9ucztcbiAgY29uc3Qge1xuICAgIHByZXNldFxuICB9ID0gb3B0aW9ucztcbiAgaWYgKHByZXNldCkge1xuICAgIHZhbGlkYXRlUHJlc2V0KHByZXNldCk7XG4gICAgZmlsZXMgPSBwcmVzZXRzT2JqW3ByZXNldF07XG4gIH1cbiAgY29uc3Qge1xuICAgIGV4dGVuc2lvblxuICB9ID0gZ2V0RXh0ZW5zaW9uKGZpbGVzKTtcbiAgY29uc3QgbG9hZGVyID0gZ2V0TG9hZGVyKGV4dGVuc2lvbik7XG4gIGlmICghbG9hZGVyKSB0aHJvdyBuZXcgRXJyb3IoJ3VzZUVudmlyb25tZW50OiBVbnJlY29nbml6ZWQgZmlsZSBleHRlbnNpb246ICcgKyBmaWxlcyk7XG4gIHVzZUxvYWRlci5jbGVhcihcbiAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICBsb2FkZXIsIGlzQXJyYXkoZmlsZXMpID8gW2ZpbGVzXSA6IGZpbGVzKTtcbn07XG5mdW5jdGlvbiB2YWxpZGF0ZVByZXNldChwcmVzZXQpIHtcbiAgaWYgKCEocHJlc2V0IGluIHByZXNldHNPYmopKSB0aHJvdyBuZXcgRXJyb3IoJ1ByZXNldCBtdXN0IGJlIG9uZSBvZjogJyArIE9iamVjdC5rZXlzKHByZXNldHNPYmopLmpvaW4oJywgJykpO1xufVxuZnVuY3Rpb24gZ2V0RXh0ZW5zaW9uKGZpbGVzKSB7XG4gIHZhciBfZmlyc3RFbnRyeSRzcGxpdCRwb3A7XG4gIGNvbnN0IGlzQ3ViZW1hcCA9IGlzQXJyYXkoZmlsZXMpICYmIGZpbGVzLmxlbmd0aCA9PT0gNjtcbiAgY29uc3QgaXNHYWlubWFwID0gaXNBcnJheShmaWxlcykgJiYgZmlsZXMubGVuZ3RoID09PSAzICYmIGZpbGVzLnNvbWUoZmlsZSA9PiBmaWxlLmVuZHNXaXRoKCdqc29uJykpO1xuICBjb25zdCBmaXJzdEVudHJ5ID0gaXNBcnJheShmaWxlcykgPyBmaWxlc1swXSA6IGZpbGVzO1xuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZVxuICBjb25zdCBleHRlbnNpb24gPSBpc0N1YmVtYXAgPyAnY3ViZScgOiBpc0dhaW5tYXAgPyAnd2VicCcgOiBmaXJzdEVudHJ5LnN0YXJ0c1dpdGgoJ2RhdGE6YXBwbGljYXRpb24vZXhyJykgPyAnZXhyJyA6IGZpcnN0RW50cnkuc3RhcnRzV2l0aCgnZGF0YTphcHBsaWNhdGlvbi9oZHInKSA/ICdoZHInIDogZmlyc3RFbnRyeS5zdGFydHNXaXRoKCdkYXRhOmltYWdlL2pwZWcnKSA/ICdqcGcnIDogKF9maXJzdEVudHJ5JHNwbGl0JHBvcCA9IGZpcnN0RW50cnkuc3BsaXQoJy4nKS5wb3AoKSkgPT0gbnVsbCB8fCAoX2ZpcnN0RW50cnkkc3BsaXQkcG9wID0gX2ZpcnN0RW50cnkkc3BsaXQkcG9wLnNwbGl0KCc/JykpID09IG51bGwgfHwgKF9maXJzdEVudHJ5JHNwbGl0JHBvcCA9IF9maXJzdEVudHJ5JHNwbGl0JHBvcC5zaGlmdCgpKSA9PSBudWxsID8gdm9pZCAwIDogX2ZpcnN0RW50cnkkc3BsaXQkcG9wLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiB7XG4gICAgZXh0ZW5zaW9uLFxuICAgIGlzQ3ViZW1hcCxcbiAgICBpc0dhaW5tYXBcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldExvYWRlcihleHRlbnNpb24pIHtcbiAgY29uc3QgbG9hZGVyID0gZXh0ZW5zaW9uID09PSAnY3ViZScgPyBDdWJlVGV4dHVyZUxvYWRlciA6IGV4dGVuc2lvbiA9PT0gJ2hkcicgPyBSR0JFTG9hZGVyIDogZXh0ZW5zaW9uID09PSAnZXhyJyA/IEVYUkxvYWRlciA6IGV4dGVuc2lvbiA9PT0gJ2pwZycgfHwgZXh0ZW5zaW9uID09PSAnanBlZycgPyBIRFJKUEdMb2FkZXIgOiBleHRlbnNpb24gPT09ICd3ZWJwJyA/IEdhaW5NYXBMb2FkZXIgOiBudWxsO1xuICByZXR1cm4gbG9hZGVyO1xufVxuXG5leHBvcnQgeyB1c2VFbnZpcm9ubWVudCB9O1xuIl0sIm5hbWVzIjpbInVzZVRocmVlIiwidXNlTG9hZGVyIiwiQ3ViZVJlZmxlY3Rpb25NYXBwaW5nIiwiRXF1aXJlY3Rhbmd1bGFyUmVmbGVjdGlvbk1hcHBpbmciLCJDdWJlVGV4dHVyZUxvYWRlciIsIlJHQkVMb2FkZXIiLCJFWFJMb2FkZXIiLCJIRFJKUEdMb2FkZXIiLCJHYWluTWFwTG9hZGVyIiwicHJlc2V0c09iaiIsInNSR0JFbmNvZGluZyIsIkxpbmVhckVuY29kaW5nIiwidXNlTGF5b3V0RWZmZWN0IiwiQ1VCRU1BUF9ST09UIiwiaXNBcnJheSIsImFyciIsIkFycmF5IiwiZGVmYXVsdEZpbGVzIiwidXNlRW52aXJvbm1lbnQiLCJmaWxlcyIsInBhdGgiLCJwcmVzZXQiLCJ1bmRlZmluZWQiLCJlbmNvZGluZyIsImV4dGVuc2lvbnMiLCJsb2FkZXIiLCJtdWx0aUZpbGUiLCJ2YWxpZGF0ZVByZXNldCIsImV4dGVuc2lvbiIsImlzQ3ViZW1hcCIsImdldEV4dGVuc2lvbiIsImdldExvYWRlciIsIkVycm9yIiwiZ2wiLCJzdGF0ZSIsImNsZWFyR2Fpbm1hcFRleHR1cmUiLCJjbGVhciIsImRvbUVsZW1lbnQiLCJhZGRFdmVudExpc3RlbmVyIiwib25jZSIsImxvYWRlclJlc3VsdCIsInNldFJlbmRlcmVyIiwic2V0UGF0aCIsInRleHR1cmUiLCJfcmVuZGVyVGFyZ2V0IiwicmVuZGVyVGFyZ2V0IiwibWFwcGluZyIsImNvbG9yU3BhY2UiLCJwcmVsb2FkRGVmYXVsdE9wdGlvbnMiLCJwcmVsb2FkIiwicHJlbG9hZE9wdGlvbnMiLCJvcHRpb25zIiwiY2xlYXJEZWZhdWx0T3B0aW5zIiwiY2xlYXJPcHRpb25zIiwiT2JqZWN0Iiwia2V5cyIsImpvaW4iLCJfZmlyc3RFbnRyeSRzcGxpdCRwb3AiLCJsZW5ndGgiLCJpc0dhaW5tYXAiLCJzb21lIiwiZmlsZSIsImVuZHNXaXRoIiwiZmlyc3RFbnRyeSIsInN0YXJ0c1dpdGgiLCJzcGxpdCIsInBvcCIsInNoaWZ0IiwidG9Mb3dlckNhc2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/core/useEnvironment.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/helpers/deprecated.js":
/*!**************************************************************!*\
  !*** ./node_modules/@react-three/drei/helpers/deprecated.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LinearEncoding: () => (/* binding */ LinearEncoding),\n/* harmony export */   sRGBEncoding: () => (/* binding */ sRGBEncoding),\n/* harmony export */   setUpdateRange: () => (/* binding */ setUpdateRange)\n/* harmony export */ });\n/**\n * Sets `BufferAttribute.updateRange` since r159.\n */ const setUpdateRange = (attribute, updateRange)=>{\n    if (\"updateRanges\" in attribute) {\n        // r159\n        // @ts-ignore\n        attribute.updateRanges[0] = updateRange;\n    } else {\n        attribute.updateRange = updateRange;\n    }\n};\nconst LinearEncoding = 3000;\nconst sRGBEncoding = 3001;\n/**\n * TextureEncoding was deprecated in r152, and removed in r162.\n */ \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvaGVscGVycy9kZXByZWNhdGVkLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOztDQUVDLEdBQ0QsTUFBTUEsaUJBQWlCLENBQUNDLFdBQVdDO0lBQ2pDLElBQUksa0JBQWtCRCxXQUFXO1FBQy9CLE9BQU87UUFDUCxhQUFhO1FBQ2JBLFVBQVVFLFlBQVksQ0FBQyxFQUFFLEdBQUdEO0lBQzlCLE9BQU87UUFDTEQsVUFBVUMsV0FBVyxHQUFHQTtJQUMxQjtBQUNGO0FBQ0EsTUFBTUUsaUJBQWlCO0FBQ3ZCLE1BQU1DLGVBQWU7QUFFckI7O0NBRUMsR0FFdUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teVZScHJvamVjdC8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZHJlaS9oZWxwZXJzL2RlcHJlY2F0ZWQuanM/ZTAwOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFNldHMgYEJ1ZmZlckF0dHJpYnV0ZS51cGRhdGVSYW5nZWAgc2luY2UgcjE1OS5cbiAqL1xuY29uc3Qgc2V0VXBkYXRlUmFuZ2UgPSAoYXR0cmlidXRlLCB1cGRhdGVSYW5nZSkgPT4ge1xuICBpZiAoJ3VwZGF0ZVJhbmdlcycgaW4gYXR0cmlidXRlKSB7XG4gICAgLy8gcjE1OVxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBhdHRyaWJ1dGUudXBkYXRlUmFuZ2VzWzBdID0gdXBkYXRlUmFuZ2U7XG4gIH0gZWxzZSB7XG4gICAgYXR0cmlidXRlLnVwZGF0ZVJhbmdlID0gdXBkYXRlUmFuZ2U7XG4gIH1cbn07XG5jb25zdCBMaW5lYXJFbmNvZGluZyA9IDMwMDA7XG5jb25zdCBzUkdCRW5jb2RpbmcgPSAzMDAxO1xuXG4vKipcbiAqIFRleHR1cmVFbmNvZGluZyB3YXMgZGVwcmVjYXRlZCBpbiByMTUyLCBhbmQgcmVtb3ZlZCBpbiByMTYyLlxuICovXG5cbmV4cG9ydCB7IExpbmVhckVuY29kaW5nLCBzUkdCRW5jb2RpbmcsIHNldFVwZGF0ZVJhbmdlIH07XG4iXSwibmFtZXMiOlsic2V0VXBkYXRlUmFuZ2UiLCJhdHRyaWJ1dGUiLCJ1cGRhdGVSYW5nZSIsInVwZGF0ZVJhbmdlcyIsIkxpbmVhckVuY29kaW5nIiwic1JHQkVuY29kaW5nIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/helpers/deprecated.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/helpers/environment-assets.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@react-three/drei/helpers/environment-assets.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   presetsObj: () => (/* binding */ presetsObj)\n/* harmony export */ });\nconst presetsObj = {\n    apartment: \"lebombo_1k.hdr\",\n    city: \"potsdamer_platz_1k.hdr\",\n    dawn: \"kiara_1_dawn_1k.hdr\",\n    forest: \"forest_slope_1k.hdr\",\n    lobby: \"st_fagans_interior_1k.hdr\",\n    night: \"dikhololo_night_1k.hdr\",\n    park: \"rooitou_park_1k.hdr\",\n    studio: \"studio_small_03_1k.hdr\",\n    sunset: \"venice_sunset_1k.hdr\",\n    warehouse: \"empty_warehouse_01_1k.hdr\"\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvaGVscGVycy9lbnZpcm9ubWVudC1hc3NldHMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE1BQU1BLGFBQWE7SUFDakJDLFdBQVc7SUFDWEMsTUFBTTtJQUNOQyxNQUFNO0lBQ05DLFFBQVE7SUFDUkMsT0FBTztJQUNQQyxPQUFPO0lBQ1BDLE1BQU07SUFDTkMsUUFBUTtJQUNSQyxRQUFRO0lBQ1JDLFdBQVc7QUFDYjtBQUVzQiIsInNvdXJjZXMiOlsid2VicGFjazovL215VlJwcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL0ByZWFjdC10aHJlZS9kcmVpL2hlbHBlcnMvZW52aXJvbm1lbnQtYXNzZXRzLmpzPzE2NTEiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgcHJlc2V0c09iaiA9IHtcbiAgYXBhcnRtZW50OiAnbGVib21ib18xay5oZHInLFxuICBjaXR5OiAncG90c2RhbWVyX3BsYXR6XzFrLmhkcicsXG4gIGRhd246ICdraWFyYV8xX2Rhd25fMWsuaGRyJyxcbiAgZm9yZXN0OiAnZm9yZXN0X3Nsb3BlXzFrLmhkcicsXG4gIGxvYmJ5OiAnc3RfZmFnYW5zX2ludGVyaW9yXzFrLmhkcicsXG4gIG5pZ2h0OiAnZGlraG9sb2xvX25pZ2h0XzFrLmhkcicsXG4gIHBhcms6ICdyb29pdG91X3BhcmtfMWsuaGRyJyxcbiAgc3R1ZGlvOiAnc3R1ZGlvX3NtYWxsXzAzXzFrLmhkcicsXG4gIHN1bnNldDogJ3ZlbmljZV9zdW5zZXRfMWsuaGRyJyxcbiAgd2FyZWhvdXNlOiAnZW1wdHlfd2FyZWhvdXNlXzAxXzFrLmhkcidcbn07XG5cbmV4cG9ydCB7IHByZXNldHNPYmogfTtcbiJdLCJuYW1lcyI6WyJwcmVzZXRzT2JqIiwiYXBhcnRtZW50IiwiY2l0eSIsImRhd24iLCJmb3Jlc3QiLCJsb2JieSIsIm5pZ2h0IiwicGFyayIsInN0dWRpbyIsInN1bnNldCIsIndhcmVob3VzZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/helpers/environment-assets.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/fiber/dist/index-673ef987.esm.js":
/*!********************************************************************!*\
  !*** ./node_modules/@react-three/fiber/dist/index-673ef987.esm.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ useFrame),\n/* harmony export */   B: () => (/* binding */ Block),\n/* harmony export */   C: () => (/* binding */ useGraph),\n/* harmony export */   D: () => (/* binding */ useLoader),\n/* harmony export */   E: () => (/* binding */ ErrorBoundary),\n/* harmony export */   a: () => (/* binding */ useIsomorphicLayoutEffect),\n/* harmony export */   b: () => (/* binding */ createRoot),\n/* harmony export */   c: () => (/* binding */ createEvents),\n/* harmony export */   d: () => (/* binding */ unmountComponentAtNode),\n/* harmony export */   e: () => (/* binding */ extend),\n/* harmony export */   f: () => (/* binding */ context),\n/* harmony export */   g: () => (/* binding */ createPortal),\n/* harmony export */   h: () => (/* binding */ reconciler),\n/* harmony export */   i: () => (/* binding */ isRef),\n/* harmony export */   j: () => (/* binding */ applyProps),\n/* harmony export */   k: () => (/* binding */ dispose),\n/* harmony export */   l: () => (/* binding */ invalidate),\n/* harmony export */   m: () => (/* binding */ advance),\n/* harmony export */   n: () => (/* binding */ addEffect),\n/* harmony export */   o: () => (/* binding */ addAfterEffect),\n/* harmony export */   p: () => (/* binding */ addTail),\n/* harmony export */   q: () => (/* binding */ flushGlobalEffects),\n/* harmony export */   r: () => (/* binding */ render),\n/* harmony export */   s: () => (/* binding */ getRootState),\n/* harmony export */   t: () => (/* binding */ threeTypes),\n/* harmony export */   u: () => (/* binding */ useMutableCallback),\n/* harmony export */   v: () => (/* binding */ act),\n/* harmony export */   w: () => (/* binding */ roots),\n/* harmony export */   x: () => (/* binding */ useInstanceHandle),\n/* harmony export */   y: () => (/* binding */ useStore),\n/* harmony export */   z: () => (/* binding */ useThree)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-reconciler/constants */ \"(ssr)/./node_modules/react-reconciler/constants.js\");\n/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! zustand */ \"(ssr)/./node_modules/zustand/esm/index.js\");\n/* harmony import */ var react_reconciler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-reconciler */ \"(ssr)/./node_modules/react-reconciler/index.js\");\n/* harmony import */ var react_reconciler__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react_reconciler__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var scheduler__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! scheduler */ \"(ssr)/./node_modules/scheduler/index.js\");\n/* harmony import */ var suspend_react__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! suspend-react */ \"(ssr)/./node_modules/suspend-react/index.js\");\n\n\n\n\n\n\n\nvar threeTypes = /*#__PURE__*/ Object.freeze({\n    __proto__: null\n});\nconst catalogue = {};\nconst extend = (objects)=>void Object.assign(catalogue, objects);\nfunction createRenderer(_roots, _getEventPriority) {\n    function createInstance(type, { args = [], attach, ...props }, root) {\n        let name = `${type[0].toUpperCase()}${type.slice(1)}`;\n        let instance;\n        if (type === \"primitive\") {\n            if (props.object === undefined) throw new Error(\"R3F: Primitives without 'object' are invalid!\");\n            const object = props.object;\n            instance = prepare(object, {\n                type,\n                root,\n                attach,\n                primitive: true\n            });\n        } else {\n            const target = catalogue[name];\n            if (!target) {\n                throw new Error(`R3F: ${name} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`);\n            }\n            // Throw if an object or literal was passed for args\n            if (!Array.isArray(args)) throw new Error(\"R3F: The args prop must be an array!\");\n            // Instanciate new object, link it to the root\n            // Append memoized props with args so it's not forgotten\n            instance = prepare(new target(...args), {\n                type,\n                root,\n                attach,\n                // Save args in case we need to reconstruct later for HMR\n                memoizedProps: {\n                    args\n                }\n            });\n        }\n        // Auto-attach geometries and materials\n        if (instance.__r3f.attach === undefined) {\n            if (instance instanceof three__WEBPACK_IMPORTED_MODULE_4__.BufferGeometry) instance.__r3f.attach = \"geometry\";\n            else if (instance instanceof three__WEBPACK_IMPORTED_MODULE_4__.Material) instance.__r3f.attach = \"material\";\n        }\n        // It should NOT call onUpdate on object instanciation, because it hasn't been added to the\n        // view yet. If the callback relies on references for instance, they won't be ready yet, this is\n        // why it passes \"true\" here\n        // There is no reason to apply props to injects\n        if (name !== \"inject\") applyProps$1(instance, props);\n        return instance;\n    }\n    function appendChild(parentInstance, child) {\n        let added = false;\n        if (child) {\n            var _child$__r3f, _parentInstance$__r3f;\n            // The attach attribute implies that the object attaches itself on the parent\n            if ((_child$__r3f = child.__r3f) != null && _child$__r3f.attach) {\n                attach(parentInstance, child, child.__r3f.attach);\n            } else if (child.isObject3D && parentInstance.isObject3D) {\n                // add in the usual parent-child way\n                parentInstance.add(child);\n                added = true;\n            }\n            // This is for anything that used attach, and for non-Object3Ds that don't get attached to props;\n            // that is, anything that's a child in React but not a child in the scenegraph.\n            if (!added) (_parentInstance$__r3f = parentInstance.__r3f) == null ? void 0 : _parentInstance$__r3f.objects.push(child);\n            if (!child.__r3f) prepare(child, {});\n            child.__r3f.parent = parentInstance;\n            updateInstance(child);\n            invalidateInstance(child);\n        }\n    }\n    function insertBefore(parentInstance, child, beforeChild) {\n        let added = false;\n        if (child) {\n            var _child$__r3f2, _parentInstance$__r3f2;\n            if ((_child$__r3f2 = child.__r3f) != null && _child$__r3f2.attach) {\n                attach(parentInstance, child, child.__r3f.attach);\n            } else if (child.isObject3D && parentInstance.isObject3D) {\n                child.parent = parentInstance;\n                child.dispatchEvent({\n                    type: \"added\"\n                });\n                const restSiblings = parentInstance.children.filter((sibling)=>sibling !== child);\n                const index = restSiblings.indexOf(beforeChild);\n                parentInstance.children = [\n                    ...restSiblings.slice(0, index),\n                    child,\n                    ...restSiblings.slice(index)\n                ];\n                added = true;\n            }\n            if (!added) (_parentInstance$__r3f2 = parentInstance.__r3f) == null ? void 0 : _parentInstance$__r3f2.objects.push(child);\n            if (!child.__r3f) prepare(child, {});\n            child.__r3f.parent = parentInstance;\n            updateInstance(child);\n            invalidateInstance(child);\n        }\n    }\n    function removeRecursive(array, parent, dispose = false) {\n        if (array) [\n            ...array\n        ].forEach((child)=>removeChild(parent, child, dispose));\n    }\n    function removeChild(parentInstance, child, dispose) {\n        if (child) {\n            var _parentInstance$__r3f3, _child$__r3f3, _child$__r3f5;\n            // Clear the parent reference\n            if (child.__r3f) child.__r3f.parent = null;\n            // Remove child from the parents objects\n            if ((_parentInstance$__r3f3 = parentInstance.__r3f) != null && _parentInstance$__r3f3.objects) parentInstance.__r3f.objects = parentInstance.__r3f.objects.filter((x)=>x !== child);\n            // Remove attachment\n            if ((_child$__r3f3 = child.__r3f) != null && _child$__r3f3.attach) {\n                detach(parentInstance, child, child.__r3f.attach);\n            } else if (child.isObject3D && parentInstance.isObject3D) {\n                var _child$__r3f4;\n                parentInstance.remove(child);\n                // Remove interactivity\n                if ((_child$__r3f4 = child.__r3f) != null && _child$__r3f4.root) {\n                    removeInteractivity(child.__r3f.root, child);\n                }\n            }\n            // Allow objects to bail out of recursive dispose altogether by passing dispose={null}\n            // Never dispose of primitives because their state may be kept outside of React!\n            // In order for an object to be able to dispose it has to have\n            //   - a dispose method,\n            //   - it cannot be a <primitive object={...} />\n            //   - it cannot be a THREE.Scene, because three has broken it's own api\n            //\n            // Since disposal is recursive, we can check the optional dispose arg, which will be undefined\n            // when the reconciler calls it, but then carry our own check recursively\n            const isPrimitive = (_child$__r3f5 = child.__r3f) == null ? void 0 : _child$__r3f5.primitive;\n            const shouldDispose = dispose === undefined ? child.dispose !== null && !isPrimitive : dispose;\n            // Remove nested child objects. Primitives should not have objects and children that are\n            // attached to them declaratively ...\n            if (!isPrimitive) {\n                var _child$__r3f6;\n                removeRecursive((_child$__r3f6 = child.__r3f) == null ? void 0 : _child$__r3f6.objects, child, shouldDispose);\n                removeRecursive(child.children, child, shouldDispose);\n            }\n            // Remove references\n            delete child.__r3f;\n            // Dispose item whenever the reconciler feels like it\n            if (shouldDispose && child.dispose && child.type !== \"Scene\") {\n                (0,scheduler__WEBPACK_IMPORTED_MODULE_3__.unstable_scheduleCallback)(scheduler__WEBPACK_IMPORTED_MODULE_3__.unstable_IdlePriority, ()=>{\n                    try {\n                        child.dispose();\n                    } catch (e) {\n                    /* ... */ }\n                });\n            }\n            invalidateInstance(parentInstance);\n        }\n    }\n    function switchInstance(instance, type, newProps, fiber) {\n        var _instance$__r3f;\n        const parent = (_instance$__r3f = instance.__r3f) == null ? void 0 : _instance$__r3f.parent;\n        if (!parent) return;\n        const newInstance = createInstance(type, newProps, instance.__r3f.root);\n        // https://github.com/pmndrs/react-three-fiber/issues/1348\n        // When args change the instance has to be re-constructed, which then\n        // forces r3f to re-parent the children and non-scene objects\n        if (instance.children) {\n            for (const child of instance.children){\n                if (child.__r3f) appendChild(newInstance, child);\n            }\n            instance.children = instance.children.filter((child)=>!child.__r3f);\n        }\n        instance.__r3f.objects.forEach((child)=>appendChild(newInstance, child));\n        instance.__r3f.objects = [];\n        if (!instance.__r3f.autoRemovedBeforeAppend) {\n            removeChild(parent, instance);\n        }\n        if (newInstance.parent) {\n            newInstance.__r3f.autoRemovedBeforeAppend = true;\n        }\n        appendChild(parent, newInstance);\n        // Re-bind event handlers\n        if (newInstance.raycast && newInstance.__r3f.eventCount) {\n            const rootState = newInstance.__r3f.root.getState();\n            rootState.internal.interaction.push(newInstance);\n        }\n        [\n            fiber,\n            fiber.alternate\n        ].forEach((fiber)=>{\n            if (fiber !== null) {\n                fiber.stateNode = newInstance;\n                if (fiber.ref) {\n                    if (typeof fiber.ref === \"function\") fiber.ref(newInstance);\n                    else fiber.ref.current = newInstance;\n                }\n            }\n        });\n    }\n    // Don't handle text instances, warn on undefined behavior\n    const handleTextInstance = ()=>console.warn(\"Text is not allowed in the R3F tree! This could be stray whitespace or characters.\");\n    const reconciler = react_reconciler__WEBPACK_IMPORTED_MODULE_2___default()({\n        createInstance,\n        removeChild,\n        appendChild,\n        appendInitialChild: appendChild,\n        insertBefore,\n        supportsMutation: true,\n        isPrimaryRenderer: false,\n        supportsPersistence: false,\n        supportsHydration: false,\n        noTimeout: -1,\n        appendChildToContainer: (container, child)=>{\n            if (!child) return;\n            // Don't append to unmounted container\n            const scene = container.getState().scene;\n            if (!scene.__r3f) return;\n            // Link current root to the default scene\n            scene.__r3f.root = container;\n            appendChild(scene, child);\n        },\n        removeChildFromContainer: (container, child)=>{\n            if (!child) return;\n            removeChild(container.getState().scene, child);\n        },\n        insertInContainerBefore: (container, child, beforeChild)=>{\n            if (!child || !beforeChild) return;\n            // Don't append to unmounted container\n            const scene = container.getState().scene;\n            if (!scene.__r3f) return;\n            insertBefore(scene, child, beforeChild);\n        },\n        getRootHostContext: ()=>null,\n        getChildHostContext: (parentHostContext)=>parentHostContext,\n        finalizeInitialChildren (instance) {\n            var _instance$__r3f2;\n            const localState = (_instance$__r3f2 = instance == null ? void 0 : instance.__r3f) != null ? _instance$__r3f2 : {};\n            // https://github.com/facebook/react/issues/20271\n            // Returning true will trigger commitMount\n            return Boolean(localState.handlers);\n        },\n        prepareUpdate (instance, _type, oldProps, newProps) {\n            var _instance$__r3f3;\n            const localState = (_instance$__r3f3 = instance == null ? void 0 : instance.__r3f) != null ? _instance$__r3f3 : {};\n            // Create diff-sets\n            if (localState.primitive && newProps.object && newProps.object !== instance) {\n                return [\n                    true\n                ];\n            } else {\n                // This is a data object, let's extract critical information about it\n                const { args: argsNew = [], children: cN, ...restNew } = newProps;\n                const { args: argsOld = [], children: cO, ...restOld } = oldProps;\n                // Throw if an object or literal was passed for args\n                if (!Array.isArray(argsNew)) throw new Error(\"R3F: the args prop must be an array!\");\n                // If it has new props or arguments, then it needs to be re-instantiated\n                if (argsNew.some((value, index)=>value !== argsOld[index])) return [\n                    true\n                ];\n                // Create a diff-set, flag if there are any changes\n                const diff = diffProps(instance, restNew, restOld, true);\n                if (diff.changes.length) return [\n                    false,\n                    diff\n                ];\n                // Otherwise do not touch the instance\n                return null;\n            }\n        },\n        commitUpdate (instance, [reconstruct, diff], type, _oldProps, newProps, fiber) {\n            // Reconstruct when args or <primitive object={...} have changes\n            if (reconstruct) switchInstance(instance, type, newProps, fiber);\n            else applyProps$1(instance, diff);\n        },\n        commitMount (instance, _type, _props, _int) {\n            var _instance$__r3f4;\n            // https://github.com/facebook/react/issues/20271\n            // This will make sure events are only added once to the central container\n            const localState = (_instance$__r3f4 = instance.__r3f) != null ? _instance$__r3f4 : {};\n            if (instance.raycast && localState.handlers && localState.eventCount) {\n                instance.__r3f.root.getState().internal.interaction.push(instance);\n            }\n        },\n        getPublicInstance: (instance)=>instance,\n        prepareForCommit: ()=>null,\n        preparePortalMount: (container)=>prepare(container.getState().scene),\n        resetAfterCommit: ()=>{},\n        shouldSetTextContent: ()=>false,\n        clearContainer: ()=>false,\n        hideInstance (instance) {\n            var _instance$__r3f5;\n            // Detach while the instance is hidden\n            const { attach: type, parent } = (_instance$__r3f5 = instance.__r3f) != null ? _instance$__r3f5 : {};\n            if (type && parent) detach(parent, instance, type);\n            if (instance.isObject3D) instance.visible = false;\n            invalidateInstance(instance);\n        },\n        unhideInstance (instance, props) {\n            var _instance$__r3f6;\n            // Re-attach when the instance is unhidden\n            const { attach: type, parent } = (_instance$__r3f6 = instance.__r3f) != null ? _instance$__r3f6 : {};\n            if (type && parent) attach(parent, instance, type);\n            if (instance.isObject3D && props.visible == null || props.visible) instance.visible = true;\n            invalidateInstance(instance);\n        },\n        createTextInstance: handleTextInstance,\n        hideTextInstance: handleTextInstance,\n        unhideTextInstance: handleTextInstance,\n        // https://github.com/pmndrs/react-three-fiber/pull/2360#discussion_r916356874\n        // @ts-ignore\n        getCurrentEventPriority: ()=>_getEventPriority ? _getEventPriority() : react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.DefaultEventPriority,\n        beforeActiveInstanceBlur: ()=>{},\n        afterActiveInstanceBlur: ()=>{},\n        detachDeletedInstance: ()=>{},\n        now: typeof performance !== \"undefined\" && is.fun(performance.now) ? performance.now : is.fun(Date.now) ? Date.now : ()=>0,\n        // https://github.com/pmndrs/react-three-fiber/pull/2360#discussion_r920883503\n        scheduleTimeout: is.fun(setTimeout) ? setTimeout : undefined,\n        cancelTimeout: is.fun(clearTimeout) ? clearTimeout : undefined\n    });\n    return {\n        reconciler,\n        applyProps: applyProps$1\n    };\n}\nvar _window$document, _window$navigator;\n/**\n * Returns `true` with correct TS type inference if an object has a configurable color space (since r152).\n */ const hasColorSpace = (object)=>\"colorSpace\" in object || \"outputColorSpace\" in object;\n/**\n * The current THREE.ColorManagement instance, if present.\n */ const getColorManagement = ()=>{\n    var _ColorManagement;\n    return (_ColorManagement = catalogue.ColorManagement) != null ? _ColorManagement : null;\n};\nconst isOrthographicCamera = (def)=>def && def.isOrthographicCamera;\nconst isRef = (obj)=>obj && obj.hasOwnProperty(\"current\");\n/**\n * An SSR-friendly useLayoutEffect.\n *\n * React currently throws a warning when using useLayoutEffect on the server.\n * To get around it, we can conditionally useEffect on the server (no-op) and\n * useLayoutEffect elsewhere.\n *\n * @see https://github.com/facebook/react/issues/14927\n */ const useIsomorphicLayoutEffect =  false ? 0 : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\nfunction useMutableCallback(fn) {\n    const ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(fn);\n    useIsomorphicLayoutEffect(()=>void (ref.current = fn), [\n        fn\n    ]);\n    return ref;\n}\nfunction Block({ set }) {\n    useIsomorphicLayoutEffect(()=>{\n        set(new Promise(()=>null));\n        return ()=>set(false);\n    }, [\n        set\n    ]);\n    return null;\n}\nclass ErrorBoundary extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n    constructor(...args){\n        super(...args);\n        this.state = {\n            error: false\n        };\n    }\n    componentDidCatch(err) {\n        this.props.set(err);\n    }\n    render() {\n        return this.state.error ? null : this.props.children;\n    }\n}\nErrorBoundary.getDerivedStateFromError = ()=>({\n        error: true\n    });\nconst DEFAULT = \"__default\";\nconst DEFAULTS = new Map();\nconst isDiffSet = (def)=>def && !!def.memoized && !!def.changes;\nfunction calculateDpr(dpr) {\n    var _window$devicePixelRa;\n    // Err on the side of progress by assuming 2x dpr if we can't detect it\n    // This will happen in workers where window is defined but dpr isn't.\n    const target =  false ? 0 : 1;\n    return Array.isArray(dpr) ? Math.min(Math.max(dpr[0], target), dpr[1]) : dpr;\n}\n/**\n * Returns instance root state\n */ const getRootState = (obj)=>{\n    var _r3f;\n    return (_r3f = obj.__r3f) == null ? void 0 : _r3f.root.getState();\n};\n// A collection of compare functions\nconst is = {\n    obj: (a)=>a === Object(a) && !is.arr(a) && typeof a !== \"function\",\n    fun: (a)=>typeof a === \"function\",\n    str: (a)=>typeof a === \"string\",\n    num: (a)=>typeof a === \"number\",\n    boo: (a)=>typeof a === \"boolean\",\n    und: (a)=>a === void 0,\n    arr: (a)=>Array.isArray(a),\n    equ (a, b, { arrays = \"shallow\", objects = \"reference\", strict = true } = {}) {\n        // Wrong type or one of the two undefined, doesn't match\n        if (typeof a !== typeof b || !!a !== !!b) return false;\n        // Atomic, just compare a against b\n        if (is.str(a) || is.num(a)) return a === b;\n        const isObj = is.obj(a);\n        if (isObj && objects === \"reference\") return a === b;\n        const isArr = is.arr(a);\n        if (isArr && arrays === \"reference\") return a === b;\n        // Array or Object, shallow compare first to see if it's a match\n        if ((isArr || isObj) && a === b) return true;\n        // Last resort, go through keys\n        let i;\n        // Check if a has all the keys of b\n        for(i in a)if (!(i in b)) return false;\n        // Check if values between keys match\n        if (isObj && arrays === \"shallow\" && objects === \"shallow\") {\n            for(i in strict ? b : a)if (!is.equ(a[i], b[i], {\n                strict,\n                objects: \"reference\"\n            })) return false;\n        } else {\n            for(i in strict ? b : a)if (a[i] !== b[i]) return false;\n        }\n        // If i is undefined\n        if (is.und(i)) {\n            // If both arrays are empty we consider them equal\n            if (isArr && a.length === 0 && b.length === 0) return true;\n            // If both objects are empty we consider them equal\n            if (isObj && Object.keys(a).length === 0 && Object.keys(b).length === 0) return true;\n            // Otherwise match them by value\n            if (a !== b) return false;\n        }\n        return true;\n    }\n};\n// Collects nodes and materials from a THREE.Object3D\nfunction buildGraph(object) {\n    const data = {\n        nodes: {},\n        materials: {}\n    };\n    if (object) {\n        object.traverse((obj)=>{\n            if (obj.name) data.nodes[obj.name] = obj;\n            if (obj.material && !data.materials[obj.material.name]) data.materials[obj.material.name] = obj.material;\n        });\n    }\n    return data;\n}\n// Disposes an object and all its properties\nfunction dispose(obj) {\n    if (obj.dispose && obj.type !== \"Scene\") obj.dispose();\n    for(const p in obj){\n        p.dispose == null ? void 0 : p.dispose();\n        delete obj[p];\n    }\n}\n// Each object in the scene carries a small LocalState descriptor\nfunction prepare(object, state) {\n    const instance = object;\n    instance.__r3f = {\n        type: \"\",\n        root: null,\n        previousAttach: null,\n        memoizedProps: {},\n        eventCount: 0,\n        handlers: {},\n        objects: [],\n        parent: null,\n        ...state\n    };\n    return object;\n}\nfunction resolve(instance, key) {\n    let target = instance;\n    if (key.includes(\"-\")) {\n        const entries = key.split(\"-\");\n        const last = entries.pop();\n        target = entries.reduce((acc, key)=>acc[key], instance);\n        return {\n            target,\n            key: last\n        };\n    } else return {\n        target,\n        key\n    };\n}\n// Checks if a dash-cased string ends with an integer\nconst INDEX_REGEX = /-\\d+$/;\nfunction attach(parent, child, type) {\n    if (is.str(type)) {\n        // If attaching into an array (foo-0), create one\n        if (INDEX_REGEX.test(type)) {\n            const root = type.replace(INDEX_REGEX, \"\");\n            const { target, key } = resolve(parent, root);\n            if (!Array.isArray(target[key])) target[key] = [];\n        }\n        const { target, key } = resolve(parent, type);\n        child.__r3f.previousAttach = target[key];\n        target[key] = child;\n    } else child.__r3f.previousAttach = type(parent, child);\n}\nfunction detach(parent, child, type) {\n    var _child$__r3f, _child$__r3f2;\n    if (is.str(type)) {\n        const { target, key } = resolve(parent, type);\n        const previous = child.__r3f.previousAttach;\n        // When the previous value was undefined, it means the value was never set to begin with\n        if (previous === undefined) delete target[key];\n        else target[key] = previous;\n    } else (_child$__r3f = child.__r3f) == null ? void 0 : _child$__r3f.previousAttach == null ? void 0 : _child$__r3f.previousAttach(parent, child);\n    (_child$__r3f2 = child.__r3f) == null ? true : delete _child$__r3f2.previousAttach;\n}\n// This function prepares a set of changes to be applied to the instance\nfunction diffProps(instance, { children: cN, key: kN, ref: rN, ...props }, { children: cP, key: kP, ref: rP, ...previous } = {}, remove = false) {\n    var _instance$__r3f;\n    const localState = (_instance$__r3f = instance == null ? void 0 : instance.__r3f) != null ? _instance$__r3f : {};\n    const entries = Object.entries(props);\n    const changes = [];\n    // Catch removed props, prepend them so they can be reset or removed\n    if (remove) {\n        const previousKeys = Object.keys(previous);\n        for(let i = 0; i < previousKeys.length; i++){\n            if (!props.hasOwnProperty(previousKeys[i])) entries.unshift([\n                previousKeys[i],\n                DEFAULT + \"remove\"\n            ]);\n        }\n    }\n    entries.forEach(([key, value])=>{\n        var _instance$__r3f2;\n        // Bail out on primitive object\n        if ((_instance$__r3f2 = instance.__r3f) != null && _instance$__r3f2.primitive && key === \"object\") return;\n        // When props match bail out\n        if (is.equ(value, previous[key])) return;\n        // Collect handlers and bail out\n        if (/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(key)) return changes.push([\n            key,\n            value,\n            true,\n            []\n        ]);\n        // Split dashed props\n        let entries = [];\n        if (key.includes(\"-\")) entries = key.split(\"-\");\n        changes.push([\n            key,\n            value,\n            false,\n            entries\n        ]);\n        // Reset pierced props\n        for(const prop in props){\n            const value = props[prop];\n            if (prop.startsWith(`${key}-`)) changes.push([\n                prop,\n                value,\n                false,\n                prop.split(\"-\")\n            ]);\n        }\n    });\n    const memoized = {\n        ...props\n    };\n    if (localState.memoizedProps && localState.memoizedProps.args) memoized.args = localState.memoizedProps.args;\n    if (localState.memoizedProps && localState.memoizedProps.attach) memoized.attach = localState.memoizedProps.attach;\n    return {\n        memoized,\n        changes\n    };\n}\n// This function applies a set of changes to the instance\nfunction applyProps$1(instance, data) {\n    var _instance$__r3f3, _root$getState, _instance$__r3f4;\n    // Filter equals, events and reserved props\n    const localState = (_instance$__r3f3 = instance.__r3f) != null ? _instance$__r3f3 : {};\n    const root = localState.root;\n    const rootState = (_root$getState = root == null ? void 0 : root.getState == null ? void 0 : root.getState()) != null ? _root$getState : {};\n    const { memoized, changes } = isDiffSet(data) ? data : diffProps(instance, data);\n    const prevHandlers = localState.eventCount;\n    // Prepare memoized props\n    if (instance.__r3f) instance.__r3f.memoizedProps = memoized;\n    for(let i = 0; i < changes.length; i++){\n        let [key, value, isEvent, keys] = changes[i];\n        // Alias (output)encoding => (output)colorSpace (since r152)\n        // https://github.com/pmndrs/react-three-fiber/pull/2829\n        if (hasColorSpace(instance)) {\n            const sRGBEncoding = 3001;\n            const SRGBColorSpace = \"srgb\";\n            const LinearSRGBColorSpace = \"srgb-linear\";\n            if (key === \"encoding\") {\n                key = \"colorSpace\";\n                value = value === sRGBEncoding ? SRGBColorSpace : LinearSRGBColorSpace;\n            } else if (key === \"outputEncoding\") {\n                key = \"outputColorSpace\";\n                value = value === sRGBEncoding ? SRGBColorSpace : LinearSRGBColorSpace;\n            }\n        }\n        let currentInstance = instance;\n        let targetProp = currentInstance[key];\n        // Revolve dashed props\n        if (keys.length) {\n            targetProp = keys.reduce((acc, key)=>acc[key], instance);\n            // If the target is atomic, it forces us to switch the root\n            if (!(targetProp && targetProp.set)) {\n                const [name, ...reverseEntries] = keys.reverse();\n                currentInstance = reverseEntries.reverse().reduce((acc, key)=>acc[key], instance);\n                key = name;\n            }\n        }\n        // https://github.com/mrdoob/three.js/issues/21209\n        // HMR/fast-refresh relies on the ability to cancel out props, but threejs\n        // has no means to do this. Hence we curate a small collection of value-classes\n        // with their respective constructor/set arguments\n        // For removed props, try to set default values, if possible\n        if (value === DEFAULT + \"remove\") {\n            if (currentInstance.constructor) {\n                // create a blank slate of the instance and copy the particular parameter.\n                let ctor = DEFAULTS.get(currentInstance.constructor);\n                if (!ctor) {\n                    // @ts-ignore\n                    ctor = new currentInstance.constructor();\n                    DEFAULTS.set(currentInstance.constructor, ctor);\n                }\n                value = ctor[key];\n            } else {\n                // instance does not have constructor, just set it to 0\n                value = 0;\n            }\n        }\n        // Deal with pointer events ...\n        if (isEvent) {\n            if (value) localState.handlers[key] = value;\n            else delete localState.handlers[key];\n            localState.eventCount = Object.keys(localState.handlers).length;\n        } else if (targetProp && targetProp.set && (targetProp.copy || targetProp instanceof three__WEBPACK_IMPORTED_MODULE_4__.Layers)) {\n            // If value is an array\n            if (Array.isArray(value)) {\n                if (targetProp.fromArray) targetProp.fromArray(value);\n                else targetProp.set(...value);\n            } else if (targetProp.copy && value && value.constructor && targetProp.constructor === value.constructor) {\n                targetProp.copy(value);\n            } else if (value !== undefined) {\n                const isColor = targetProp instanceof three__WEBPACK_IMPORTED_MODULE_4__.Color;\n                // Allow setting array scalars\n                if (!isColor && targetProp.setScalar) targetProp.setScalar(value);\n                else if (targetProp instanceof three__WEBPACK_IMPORTED_MODULE_4__.Layers && value instanceof three__WEBPACK_IMPORTED_MODULE_4__.Layers) targetProp.mask = value.mask;\n                else targetProp.set(value);\n                // For versions of three which don't support THREE.ColorManagement,\n                // Auto-convert sRGB colors\n                // https://github.com/pmndrs/react-three-fiber/issues/344\n                if (!getColorManagement() && !rootState.linear && isColor) targetProp.convertSRGBToLinear();\n            }\n        // Else, just overwrite the value\n        } else {\n            currentInstance[key] = value;\n            // Auto-convert sRGB textures, for now ...\n            // https://github.com/pmndrs/react-three-fiber/issues/344\n            if (currentInstance[key] instanceof three__WEBPACK_IMPORTED_MODULE_4__.Texture && // sRGB textures must be RGBA8 since r137 https://github.com/mrdoob/three.js/pull/23129\n            currentInstance[key].format === three__WEBPACK_IMPORTED_MODULE_4__.RGBAFormat && currentInstance[key].type === three__WEBPACK_IMPORTED_MODULE_4__.UnsignedByteType) {\n                const texture = currentInstance[key];\n                if (hasColorSpace(texture) && hasColorSpace(rootState.gl)) texture.colorSpace = rootState.gl.outputColorSpace;\n                else texture.encoding = rootState.gl.outputEncoding;\n            }\n        }\n        invalidateInstance(instance);\n    }\n    if (localState.parent && rootState.internal && instance.raycast && prevHandlers !== localState.eventCount) {\n        // Pre-emptively remove the instance from the interaction manager\n        const index = rootState.internal.interaction.indexOf(instance);\n        if (index > -1) rootState.internal.interaction.splice(index, 1);\n        // Add the instance to the interaction manager only when it has handlers\n        if (localState.eventCount) rootState.internal.interaction.push(instance);\n    }\n    // Call the update lifecycle when it is being updated, but only when it is part of the scene.\n    // Skip updates to the `onUpdate` prop itself\n    const isCircular = changes.length === 1 && changes[0][0] === \"onUpdate\";\n    if (!isCircular && changes.length && (_instance$__r3f4 = instance.__r3f) != null && _instance$__r3f4.parent) updateInstance(instance);\n    return instance;\n}\nfunction invalidateInstance(instance) {\n    var _instance$__r3f5, _instance$__r3f5$root;\n    const state = (_instance$__r3f5 = instance.__r3f) == null ? void 0 : (_instance$__r3f5$root = _instance$__r3f5.root) == null ? void 0 : _instance$__r3f5$root.getState == null ? void 0 : _instance$__r3f5$root.getState();\n    if (state && state.internal.frames === 0) state.invalidate();\n}\nfunction updateInstance(instance) {\n    instance.onUpdate == null ? void 0 : instance.onUpdate(instance);\n}\nfunction updateCamera(camera, size) {\n    // https://github.com/pmndrs/react-three-fiber/issues/92\n    // Do not mess with the camera if it belongs to the user\n    if (!camera.manual) {\n        if (isOrthographicCamera(camera)) {\n            camera.left = size.width / -2;\n            camera.right = size.width / 2;\n            camera.top = size.height / 2;\n            camera.bottom = size.height / -2;\n        } else {\n            camera.aspect = size.width / size.height;\n        }\n        camera.updateProjectionMatrix();\n        // https://github.com/pmndrs/react-three-fiber/issues/178\n        // Update matrix world since the renderer is a frame late\n        camera.updateMatrixWorld();\n    }\n}\nfunction makeId(event) {\n    return (event.eventObject || event.object).uuid + \"/\" + event.index + event.instanceId;\n}\n// https://github.com/facebook/react/tree/main/packages/react-reconciler#getcurrenteventpriority\n// Gives React a clue as to how import the current interaction is\nfunction getEventPriority() {\n    var _globalScope$event;\n    // Get a handle to the current global scope in window and worker contexts if able\n    // https://github.com/pmndrs/react-three-fiber/pull/2493\n    const globalScope = typeof self !== \"undefined\" && self ||  false && 0;\n    if (!globalScope) return react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.DefaultEventPriority;\n    const name = (_globalScope$event = globalScope.event) == null ? void 0 : _globalScope$event.type;\n    switch(name){\n        case \"click\":\n        case \"contextmenu\":\n        case \"dblclick\":\n        case \"pointercancel\":\n        case \"pointerdown\":\n        case \"pointerup\":\n            return react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.DiscreteEventPriority;\n        case \"pointermove\":\n        case \"pointerout\":\n        case \"pointerover\":\n        case \"pointerenter\":\n        case \"pointerleave\":\n        case \"wheel\":\n            return react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.ContinuousEventPriority;\n        default:\n            return react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.DefaultEventPriority;\n    }\n}\n/**\n * Release pointer captures.\n * This is called by releasePointerCapture in the API, and when an object is removed.\n */ function releaseInternalPointerCapture(capturedMap, obj, captures, pointerId) {\n    const captureData = captures.get(obj);\n    if (captureData) {\n        captures.delete(obj);\n        // If this was the last capturing object for this pointer\n        if (captures.size === 0) {\n            capturedMap.delete(pointerId);\n            captureData.target.releasePointerCapture(pointerId);\n        }\n    }\n}\nfunction removeInteractivity(store, object) {\n    const { internal } = store.getState();\n    // Removes every trace of an object from the data store\n    internal.interaction = internal.interaction.filter((o)=>o !== object);\n    internal.initialHits = internal.initialHits.filter((o)=>o !== object);\n    internal.hovered.forEach((value, key)=>{\n        if (value.eventObject === object || value.object === object) {\n            // Clear out intersects, they are outdated by now\n            internal.hovered.delete(key);\n        }\n    });\n    internal.capturedMap.forEach((captures, pointerId)=>{\n        releaseInternalPointerCapture(internal.capturedMap, object, captures, pointerId);\n    });\n}\nfunction createEvents(store) {\n    /** Calculates delta */ function calculateDistance(event) {\n        const { internal } = store.getState();\n        const dx = event.offsetX - internal.initialClick[0];\n        const dy = event.offsetY - internal.initialClick[1];\n        return Math.round(Math.sqrt(dx * dx + dy * dy));\n    }\n    /** Returns true if an instance has a valid pointer-event registered, this excludes scroll, clicks etc */ function filterPointerEvents(objects) {\n        return objects.filter((obj)=>[\n                \"Move\",\n                \"Over\",\n                \"Enter\",\n                \"Out\",\n                \"Leave\"\n            ].some((name)=>{\n                var _r3f;\n                return (_r3f = obj.__r3f) == null ? void 0 : _r3f.handlers[\"onPointer\" + name];\n            }));\n    }\n    function intersect(event, filter) {\n        const state = store.getState();\n        const duplicates = new Set();\n        const intersections = [];\n        // Allow callers to eliminate event objects\n        const eventsObjects = filter ? filter(state.internal.interaction) : state.internal.interaction;\n        // Reset all raycaster cameras to undefined\n        for(let i = 0; i < eventsObjects.length; i++){\n            const state = getRootState(eventsObjects[i]);\n            if (state) {\n                state.raycaster.camera = undefined;\n            }\n        }\n        if (!state.previousRoot) {\n            // Make sure root-level pointer and ray are set up\n            state.events.compute == null ? void 0 : state.events.compute(event, state);\n        }\n        function handleRaycast(obj) {\n            const state = getRootState(obj);\n            // Skip event handling when noEvents is set, or when the raycasters camera is null\n            if (!state || !state.events.enabled || state.raycaster.camera === null) return [];\n            // When the camera is undefined we have to call the event layers update function\n            if (state.raycaster.camera === undefined) {\n                var _state$previousRoot;\n                state.events.compute == null ? void 0 : state.events.compute(event, state, (_state$previousRoot = state.previousRoot) == null ? void 0 : _state$previousRoot.getState());\n                // If the camera is still undefined we have to skip this layer entirely\n                if (state.raycaster.camera === undefined) state.raycaster.camera = null;\n            }\n            // Intersect object by object\n            return state.raycaster.camera ? state.raycaster.intersectObject(obj, true) : [];\n        }\n        // Collect events\n        let hits = eventsObjects// Intersect objects\n        .flatMap(handleRaycast)// Sort by event priority and distance\n        .sort((a, b)=>{\n            const aState = getRootState(a.object);\n            const bState = getRootState(b.object);\n            if (!aState || !bState) return a.distance - b.distance;\n            return bState.events.priority - aState.events.priority || a.distance - b.distance;\n        })// Filter out duplicates\n        .filter((item)=>{\n            const id = makeId(item);\n            if (duplicates.has(id)) return false;\n            duplicates.add(id);\n            return true;\n        });\n        // https://github.com/mrdoob/three.js/issues/16031\n        // Allow custom userland intersect sort order, this likely only makes sense on the root filter\n        if (state.events.filter) hits = state.events.filter(hits, state);\n        // Bubble up the events, find the event source (eventObject)\n        for (const hit of hits){\n            let eventObject = hit.object;\n            // Bubble event up\n            while(eventObject){\n                var _r3f2;\n                if ((_r3f2 = eventObject.__r3f) != null && _r3f2.eventCount) intersections.push({\n                    ...hit,\n                    eventObject\n                });\n                eventObject = eventObject.parent;\n            }\n        }\n        // If the interaction is captured, make all capturing targets part of the intersect.\n        if (\"pointerId\" in event && state.internal.capturedMap.has(event.pointerId)) {\n            for (let captureData of state.internal.capturedMap.get(event.pointerId).values()){\n                if (!duplicates.has(makeId(captureData.intersection))) intersections.push(captureData.intersection);\n            }\n        }\n        return intersections;\n    }\n    /**  Handles intersections by forwarding them to handlers */ function handleIntersects(intersections, event, delta, callback) {\n        const rootState = store.getState();\n        // If anything has been found, forward it to the event listeners\n        if (intersections.length) {\n            const localState = {\n                stopped: false\n            };\n            for (const hit of intersections){\n                const state = getRootState(hit.object) || rootState;\n                const { raycaster, pointer, camera, internal } = state;\n                const unprojectedPoint = new three__WEBPACK_IMPORTED_MODULE_4__.Vector3(pointer.x, pointer.y, 0).unproject(camera);\n                const hasPointerCapture = (id)=>{\n                    var _internal$capturedMap, _internal$capturedMap2;\n                    return (_internal$capturedMap = (_internal$capturedMap2 = internal.capturedMap.get(id)) == null ? void 0 : _internal$capturedMap2.has(hit.eventObject)) != null ? _internal$capturedMap : false;\n                };\n                const setPointerCapture = (id)=>{\n                    const captureData = {\n                        intersection: hit,\n                        target: event.target\n                    };\n                    if (internal.capturedMap.has(id)) {\n                        // if the pointerId was previously captured, we add the hit to the\n                        // event capturedMap.\n                        internal.capturedMap.get(id).set(hit.eventObject, captureData);\n                    } else {\n                        // if the pointerId was not previously captured, we create a map\n                        // containing the hitObject, and the hit. hitObject is used for\n                        // faster access.\n                        internal.capturedMap.set(id, new Map([\n                            [\n                                hit.eventObject,\n                                captureData\n                            ]\n                        ]));\n                    }\n                    event.target.setPointerCapture(id);\n                };\n                const releasePointerCapture = (id)=>{\n                    const captures = internal.capturedMap.get(id);\n                    if (captures) {\n                        releaseInternalPointerCapture(internal.capturedMap, hit.eventObject, captures, id);\n                    }\n                };\n                // Add native event props\n                let extractEventProps = {};\n                // This iterates over the event's properties including the inherited ones. Native PointerEvents have most of their props as getters which are inherited, but polyfilled PointerEvents have them all as their own properties (i.e. not inherited). We can't use Object.keys() or Object.entries() as they only return \"own\" properties; nor Object.getPrototypeOf(event) as that *doesn't* return \"own\" properties, only inherited ones.\n                for(let prop in event){\n                    let property = event[prop];\n                    // Only copy over atomics, leave functions alone as these should be\n                    // called as event.nativeEvent.fn()\n                    if (typeof property !== \"function\") extractEventProps[prop] = property;\n                }\n                let raycastEvent = {\n                    ...hit,\n                    ...extractEventProps,\n                    pointer,\n                    intersections,\n                    stopped: localState.stopped,\n                    delta,\n                    unprojectedPoint,\n                    ray: raycaster.ray,\n                    camera: camera,\n                    // Hijack stopPropagation, which just sets a flag\n                    stopPropagation () {\n                        // https://github.com/pmndrs/react-three-fiber/issues/596\n                        // Events are not allowed to stop propagation if the pointer has been captured\n                        const capturesForPointer = \"pointerId\" in event && internal.capturedMap.get(event.pointerId);\n                        // We only authorize stopPropagation...\n                        if (// ...if this pointer hasn't been captured\n                        !capturesForPointer || // ... or if the hit object is capturing the pointer\n                        capturesForPointer.has(hit.eventObject)) {\n                            raycastEvent.stopped = localState.stopped = true;\n                            // Propagation is stopped, remove all other hover records\n                            // An event handler is only allowed to flush other handlers if it is hovered itself\n                            if (internal.hovered.size && Array.from(internal.hovered.values()).find((i)=>i.eventObject === hit.eventObject)) {\n                                // Objects cannot flush out higher up objects that have already caught the event\n                                const higher = intersections.slice(0, intersections.indexOf(hit));\n                                cancelPointer([\n                                    ...higher,\n                                    hit\n                                ]);\n                            }\n                        }\n                    },\n                    // there should be a distinction between target and currentTarget\n                    target: {\n                        hasPointerCapture,\n                        setPointerCapture,\n                        releasePointerCapture\n                    },\n                    currentTarget: {\n                        hasPointerCapture,\n                        setPointerCapture,\n                        releasePointerCapture\n                    },\n                    nativeEvent: event\n                };\n                // Call subscribers\n                callback(raycastEvent);\n                // Event bubbling may be interrupted by stopPropagation\n                if (localState.stopped === true) break;\n            }\n        }\n        return intersections;\n    }\n    function cancelPointer(intersections) {\n        const { internal } = store.getState();\n        for (const hoveredObj of internal.hovered.values()){\n            // When no objects were hit or the the hovered object wasn't found underneath the cursor\n            // we call onPointerOut and delete the object from the hovered-elements map\n            if (!intersections.length || !intersections.find((hit)=>hit.object === hoveredObj.object && hit.index === hoveredObj.index && hit.instanceId === hoveredObj.instanceId)) {\n                const eventObject = hoveredObj.eventObject;\n                const instance = eventObject.__r3f;\n                const handlers = instance == null ? void 0 : instance.handlers;\n                internal.hovered.delete(makeId(hoveredObj));\n                if (instance != null && instance.eventCount) {\n                    // Clear out intersects, they are outdated by now\n                    const data = {\n                        ...hoveredObj,\n                        intersections\n                    };\n                    handlers.onPointerOut == null ? void 0 : handlers.onPointerOut(data);\n                    handlers.onPointerLeave == null ? void 0 : handlers.onPointerLeave(data);\n                }\n            }\n        }\n    }\n    function pointerMissed(event, objects) {\n        for(let i = 0; i < objects.length; i++){\n            const instance = objects[i].__r3f;\n            instance == null ? void 0 : instance.handlers.onPointerMissed == null ? void 0 : instance.handlers.onPointerMissed(event);\n        }\n    }\n    function handlePointer(name) {\n        // Deal with cancelation\n        switch(name){\n            case \"onPointerLeave\":\n            case \"onPointerCancel\":\n                return ()=>cancelPointer([]);\n            case \"onLostPointerCapture\":\n                return (event)=>{\n                    const { internal } = store.getState();\n                    if (\"pointerId\" in event && internal.capturedMap.has(event.pointerId)) {\n                        // If the object event interface had onLostPointerCapture, we'd call it here on every\n                        // object that's getting removed. We call it on the next frame because onLostPointerCapture\n                        // fires before onPointerUp. Otherwise pointerUp would never be called if the event didn't\n                        // happen in the object it originated from, leaving components in a in-between state.\n                        requestAnimationFrame(()=>{\n                            // Only release if pointer-up didn't do it already\n                            if (internal.capturedMap.has(event.pointerId)) {\n                                internal.capturedMap.delete(event.pointerId);\n                                cancelPointer([]);\n                            }\n                        });\n                    }\n                };\n        }\n        // Any other pointer goes here ...\n        return function handleEvent(event) {\n            const { onPointerMissed, internal } = store.getState();\n            // prepareRay(event)\n            internal.lastEvent.current = event;\n            // Get fresh intersects\n            const isPointerMove = name === \"onPointerMove\";\n            const isClickEvent = name === \"onClick\" || name === \"onContextMenu\" || name === \"onDoubleClick\";\n            const filter = isPointerMove ? filterPointerEvents : undefined;\n            const hits = intersect(event, filter);\n            const delta = isClickEvent ? calculateDistance(event) : 0;\n            // Save initial coordinates on pointer-down\n            if (name === \"onPointerDown\") {\n                internal.initialClick = [\n                    event.offsetX,\n                    event.offsetY\n                ];\n                internal.initialHits = hits.map((hit)=>hit.eventObject);\n            }\n            // If a click yields no results, pass it back to the user as a miss\n            // Missed events have to come first in order to establish user-land side-effect clean up\n            if (isClickEvent && !hits.length) {\n                if (delta <= 2) {\n                    pointerMissed(event, internal.interaction);\n                    if (onPointerMissed) onPointerMissed(event);\n                }\n            }\n            // Take care of unhover\n            if (isPointerMove) cancelPointer(hits);\n            function onIntersect(data) {\n                const eventObject = data.eventObject;\n                const instance = eventObject.__r3f;\n                const handlers = instance == null ? void 0 : instance.handlers;\n                // Check presence of handlers\n                if (!(instance != null && instance.eventCount)) return;\n                /*\n        MAYBE TODO, DELETE IF NOT: \n          Check if the object is captured, captured events should not have intersects running in parallel\n          But wouldn't it be better to just replace capturedMap with a single entry?\n          Also, are we OK with straight up making picking up multiple objects impossible?\n          \n        const pointerId = (data as ThreeEvent<PointerEvent>).pointerId        \n        if (pointerId !== undefined) {\n          const capturedMeshSet = internal.capturedMap.get(pointerId)\n          if (capturedMeshSet) {\n            const captured = capturedMeshSet.get(eventObject)\n            if (captured && captured.localState.stopped) return\n          }\n        }*/ if (isPointerMove) {\n                    // Move event ...\n                    if (handlers.onPointerOver || handlers.onPointerEnter || handlers.onPointerOut || handlers.onPointerLeave) {\n                        // When enter or out is present take care of hover-state\n                        const id = makeId(data);\n                        const hoveredItem = internal.hovered.get(id);\n                        if (!hoveredItem) {\n                            // If the object wasn't previously hovered, book it and call its handler\n                            internal.hovered.set(id, data);\n                            handlers.onPointerOver == null ? void 0 : handlers.onPointerOver(data);\n                            handlers.onPointerEnter == null ? void 0 : handlers.onPointerEnter(data);\n                        } else if (hoveredItem.stopped) {\n                            // If the object was previously hovered and stopped, we shouldn't allow other items to proceed\n                            data.stopPropagation();\n                        }\n                    }\n                    // Call mouse move\n                    handlers.onPointerMove == null ? void 0 : handlers.onPointerMove(data);\n                } else {\n                    // All other events ...\n                    const handler = handlers[name];\n                    if (handler) {\n                        // Forward all events back to their respective handlers with the exception of click events,\n                        // which must use the initial target\n                        if (!isClickEvent || internal.initialHits.includes(eventObject)) {\n                            // Missed events have to come first\n                            pointerMissed(event, internal.interaction.filter((object)=>!internal.initialHits.includes(object)));\n                            // Now call the handler\n                            handler(data);\n                        }\n                    } else {\n                        // Trigger onPointerMissed on all elements that have pointer over/out handlers, but not click and weren't hit\n                        if (isClickEvent && internal.initialHits.includes(eventObject)) {\n                            pointerMissed(event, internal.interaction.filter((object)=>!internal.initialHits.includes(object)));\n                        }\n                    }\n                }\n            }\n            handleIntersects(hits, event, delta, onIntersect);\n        };\n    }\n    return {\n        handlePointer\n    };\n}\n// Keys that shouldn't be copied between R3F stores\nconst privateKeys = [\n    \"set\",\n    \"get\",\n    \"setSize\",\n    \"setFrameloop\",\n    \"setDpr\",\n    \"events\",\n    \"invalidate\",\n    \"advance\",\n    \"size\",\n    \"viewport\"\n];\nconst isRenderer = (def)=>!!(def != null && def.render);\nconst context = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nconst createStore = (invalidate, advance)=>{\n    const rootState = (0,zustand__WEBPACK_IMPORTED_MODULE_5__[\"default\"])((set, get)=>{\n        const position = new three__WEBPACK_IMPORTED_MODULE_4__.Vector3();\n        const defaultTarget = new three__WEBPACK_IMPORTED_MODULE_4__.Vector3();\n        const tempTarget = new three__WEBPACK_IMPORTED_MODULE_4__.Vector3();\n        function getCurrentViewport(camera = get().camera, target = defaultTarget, size = get().size) {\n            const { width, height, top, left } = size;\n            const aspect = width / height;\n            if (target instanceof three__WEBPACK_IMPORTED_MODULE_4__.Vector3) tempTarget.copy(target);\n            else tempTarget.set(...target);\n            const distance = camera.getWorldPosition(position).distanceTo(tempTarget);\n            if (isOrthographicCamera(camera)) {\n                return {\n                    width: width / camera.zoom,\n                    height: height / camera.zoom,\n                    top,\n                    left,\n                    factor: 1,\n                    distance,\n                    aspect\n                };\n            } else {\n                const fov = camera.fov * Math.PI / 180; // convert vertical fov to radians\n                const h = 2 * Math.tan(fov / 2) * distance; // visible height\n                const w = h * (width / height);\n                return {\n                    width: w,\n                    height: h,\n                    top,\n                    left,\n                    factor: width / w,\n                    distance,\n                    aspect\n                };\n            }\n        }\n        let performanceTimeout = undefined;\n        const setPerformanceCurrent = (current)=>set((state)=>({\n                    performance: {\n                        ...state.performance,\n                        current\n                    }\n                }));\n        const pointer = new three__WEBPACK_IMPORTED_MODULE_4__.Vector2();\n        const rootState = {\n            set,\n            get,\n            // Mock objects that have to be configured\n            gl: null,\n            camera: null,\n            raycaster: null,\n            events: {\n                priority: 1,\n                enabled: true,\n                connected: false\n            },\n            xr: null,\n            scene: null,\n            invalidate: (frames = 1)=>invalidate(get(), frames),\n            advance: (timestamp, runGlobalEffects)=>advance(timestamp, runGlobalEffects, get()),\n            legacy: false,\n            linear: false,\n            flat: false,\n            controls: null,\n            clock: new three__WEBPACK_IMPORTED_MODULE_4__.Clock(),\n            pointer,\n            mouse: pointer,\n            frameloop: \"always\",\n            onPointerMissed: undefined,\n            performance: {\n                current: 1,\n                min: 0.5,\n                max: 1,\n                debounce: 200,\n                regress: ()=>{\n                    const state = get();\n                    // Clear timeout\n                    if (performanceTimeout) clearTimeout(performanceTimeout);\n                    // Set lower bound performance\n                    if (state.performance.current !== state.performance.min) setPerformanceCurrent(state.performance.min);\n                    // Go back to upper bound performance after a while unless something regresses meanwhile\n                    performanceTimeout = setTimeout(()=>setPerformanceCurrent(get().performance.max), state.performance.debounce);\n                }\n            },\n            size: {\n                width: 0,\n                height: 0,\n                top: 0,\n                left: 0,\n                updateStyle: false\n            },\n            viewport: {\n                initialDpr: 0,\n                dpr: 0,\n                width: 0,\n                height: 0,\n                top: 0,\n                left: 0,\n                aspect: 0,\n                distance: 0,\n                factor: 0,\n                getCurrentViewport\n            },\n            setEvents: (events)=>set((state)=>({\n                        ...state,\n                        events: {\n                            ...state.events,\n                            ...events\n                        }\n                    })),\n            setSize: (width, height, updateStyle, top, left)=>{\n                const camera = get().camera;\n                const size = {\n                    width,\n                    height,\n                    top: top || 0,\n                    left: left || 0,\n                    updateStyle\n                };\n                set((state)=>({\n                        size,\n                        viewport: {\n                            ...state.viewport,\n                            ...getCurrentViewport(camera, defaultTarget, size)\n                        }\n                    }));\n            },\n            setDpr: (dpr)=>set((state)=>{\n                    const resolved = calculateDpr(dpr);\n                    return {\n                        viewport: {\n                            ...state.viewport,\n                            dpr: resolved,\n                            initialDpr: state.viewport.initialDpr || resolved\n                        }\n                    };\n                }),\n            setFrameloop: (frameloop = \"always\")=>{\n                const clock = get().clock;\n                // if frameloop === \"never\" clock.elapsedTime is updated using advance(timestamp)\n                clock.stop();\n                clock.elapsedTime = 0;\n                if (frameloop !== \"never\") {\n                    clock.start();\n                    clock.elapsedTime = 0;\n                }\n                set(()=>({\n                        frameloop\n                    }));\n            },\n            previousRoot: undefined,\n            internal: {\n                active: false,\n                priority: 0,\n                frames: 0,\n                lastEvent: /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createRef(),\n                interaction: [],\n                hovered: new Map(),\n                subscribers: [],\n                initialClick: [\n                    0,\n                    0\n                ],\n                initialHits: [],\n                capturedMap: new Map(),\n                subscribe: (ref, priority, store)=>{\n                    const internal = get().internal;\n                    // If this subscription was given a priority, it takes rendering into its own hands\n                    // For that reason we switch off automatic rendering and increase the manual flag\n                    // As long as this flag is positive there can be no internal rendering at all\n                    // because there could be multiple render subscriptions\n                    internal.priority = internal.priority + (priority > 0 ? 1 : 0);\n                    internal.subscribers.push({\n                        ref,\n                        priority,\n                        store\n                    });\n                    // Register subscriber and sort layers from lowest to highest, meaning,\n                    // highest priority renders last (on top of the other frames)\n                    internal.subscribers = internal.subscribers.sort((a, b)=>a.priority - b.priority);\n                    return ()=>{\n                        const internal = get().internal;\n                        if (internal != null && internal.subscribers) {\n                            // Decrease manual flag if this subscription had a priority\n                            internal.priority = internal.priority - (priority > 0 ? 1 : 0);\n                            // Remove subscriber from list\n                            internal.subscribers = internal.subscribers.filter((s)=>s.ref !== ref);\n                        }\n                    };\n                }\n            }\n        };\n        return rootState;\n    });\n    const state = rootState.getState();\n    let oldSize = state.size;\n    let oldDpr = state.viewport.dpr;\n    let oldCamera = state.camera;\n    rootState.subscribe(()=>{\n        const { camera, size, viewport, gl, set } = rootState.getState();\n        // Resize camera and renderer on changes to size and pixelratio\n        if (size !== oldSize || viewport.dpr !== oldDpr) {\n            var _size$updateStyle;\n            oldSize = size;\n            oldDpr = viewport.dpr;\n            // Update camera & renderer\n            updateCamera(camera, size);\n            gl.setPixelRatio(viewport.dpr);\n            const updateStyle = (_size$updateStyle = size.updateStyle) != null ? _size$updateStyle : typeof HTMLCanvasElement !== \"undefined\" && gl.domElement instanceof HTMLCanvasElement;\n            gl.setSize(size.width, size.height, updateStyle);\n        }\n        // Update viewport once the camera changes\n        if (camera !== oldCamera) {\n            oldCamera = camera;\n            // Update viewport\n            set((state)=>({\n                    viewport: {\n                        ...state.viewport,\n                        ...state.viewport.getCurrentViewport(camera)\n                    }\n                }));\n        }\n    });\n    // Invalidate on any change\n    rootState.subscribe((state)=>invalidate(state));\n    // Return root state\n    return rootState;\n};\nfunction createSubs(callback, subs) {\n    const sub = {\n        callback\n    };\n    subs.add(sub);\n    return ()=>void subs.delete(sub);\n}\nlet i;\nlet globalEffects = new Set();\nlet globalAfterEffects = new Set();\nlet globalTailEffects = new Set();\n/**\n * Adds a global render callback which is called each frame.\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#addEffect\n */ const addEffect = (callback)=>createSubs(callback, globalEffects);\n/**\n * Adds a global after-render callback which is called each frame.\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#addAfterEffect\n */ const addAfterEffect = (callback)=>createSubs(callback, globalAfterEffects);\n/**\n * Adds a global callback which is called when rendering stops.\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#addTail\n */ const addTail = (callback)=>createSubs(callback, globalTailEffects);\nfunction run(effects, timestamp) {\n    if (!effects.size) return;\n    for (const { callback } of effects.values()){\n        callback(timestamp);\n    }\n}\nfunction flushGlobalEffects(type, timestamp) {\n    switch(type){\n        case \"before\":\n            return run(globalEffects, timestamp);\n        case \"after\":\n            return run(globalAfterEffects, timestamp);\n        case \"tail\":\n            return run(globalTailEffects, timestamp);\n    }\n}\nlet subscribers;\nlet subscription;\nfunction render$1(timestamp, state, frame) {\n    // Run local effects\n    let delta = state.clock.getDelta();\n    // In frameloop='never' mode, clock times are updated using the provided timestamp\n    if (state.frameloop === \"never\" && typeof timestamp === \"number\") {\n        delta = timestamp - state.clock.elapsedTime;\n        state.clock.oldTime = state.clock.elapsedTime;\n        state.clock.elapsedTime = timestamp;\n    }\n    // Call subscribers (useFrame)\n    subscribers = state.internal.subscribers;\n    for(i = 0; i < subscribers.length; i++){\n        subscription = subscribers[i];\n        subscription.ref.current(subscription.store.getState(), delta, frame);\n    }\n    // Render content\n    if (!state.internal.priority && state.gl.render) state.gl.render(state.scene, state.camera);\n    // Decrease frame count\n    state.internal.frames = Math.max(0, state.internal.frames - 1);\n    return state.frameloop === \"always\" ? 1 : state.internal.frames;\n}\nfunction createLoop(roots) {\n    let running = false;\n    let repeat;\n    let frame;\n    let state;\n    function loop(timestamp) {\n        frame = requestAnimationFrame(loop);\n        running = true;\n        repeat = 0;\n        // Run effects\n        flushGlobalEffects(\"before\", timestamp);\n        // Render all roots\n        for (const root of roots.values()){\n            var _state$gl$xr;\n            state = root.store.getState();\n            // If the frameloop is invalidated, do not run another frame\n            if (state.internal.active && (state.frameloop === \"always\" || state.internal.frames > 0) && !((_state$gl$xr = state.gl.xr) != null && _state$gl$xr.isPresenting)) {\n                repeat += render$1(timestamp, state);\n            }\n        }\n        // Run after-effects\n        flushGlobalEffects(\"after\", timestamp);\n        // Stop the loop if nothing invalidates it\n        if (repeat === 0) {\n            // Tail call effects, they are called when rendering stops\n            flushGlobalEffects(\"tail\", timestamp);\n            // Flag end of operation\n            running = false;\n            return cancelAnimationFrame(frame);\n        }\n    }\n    function invalidate(state, frames = 1) {\n        var _state$gl$xr2;\n        if (!state) return roots.forEach((root)=>invalidate(root.store.getState()), frames);\n        if ((_state$gl$xr2 = state.gl.xr) != null && _state$gl$xr2.isPresenting || !state.internal.active || state.frameloop === \"never\") return;\n        // Increase frames, do not go higher than 60\n        state.internal.frames = Math.min(60, state.internal.frames + frames);\n        // If the render-loop isn't active, start it\n        if (!running) {\n            running = true;\n            requestAnimationFrame(loop);\n        }\n    }\n    function advance(timestamp, runGlobalEffects = true, state, frame) {\n        if (runGlobalEffects) flushGlobalEffects(\"before\", timestamp);\n        if (!state) for (const root of roots.values())render$1(timestamp, root.store.getState());\n        else render$1(timestamp, state, frame);\n        if (runGlobalEffects) flushGlobalEffects(\"after\", timestamp);\n    }\n    return {\n        loop,\n        /**\n     * Invalidates the view, requesting a frame to be rendered. Will globally invalidate unless passed a root's state.\n     * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#invalidate\n     */ invalidate,\n        /**\n     * Advances the frameloop and runs render effects, useful for when manually rendering via `frameloop=\"never\"`.\n     * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#advance\n     */ advance\n    };\n}\n/**\n * Exposes an object's {@link LocalState}.\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#useInstanceHandle\n *\n * **Note**: this is an escape hatch to react-internal fields. Expect this to change significantly between versions.\n */ function useInstanceHandle(ref) {\n    const instance = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    useIsomorphicLayoutEffect(()=>void (instance.current = ref.current.__r3f), [\n        ref\n    ]);\n    return instance;\n}\nfunction useStore() {\n    const store = react__WEBPACK_IMPORTED_MODULE_0__.useContext(context);\n    if (!store) throw new Error(\"R3F: Hooks can only be used within the Canvas component!\");\n    return store;\n}\n/**\n * Accesses R3F's internal state, containing renderer, canvas, scene, etc.\n * @see https://docs.pmnd.rs/react-three-fiber/api/hooks#usethree\n */ function useThree(selector = (state)=>state, equalityFn) {\n    return useStore()(selector, equalityFn);\n}\n/**\n * Executes a callback before render in a shared frame loop.\n * Can order effects with render priority or manually render with a positive priority.\n * @see https://docs.pmnd.rs/react-three-fiber/api/hooks#useframe\n */ function useFrame(callback, renderPriority = 0) {\n    const store = useStore();\n    const subscribe = store.getState().internal.subscribe;\n    // Memoize ref\n    const ref = useMutableCallback(callback);\n    // Subscribe on mount, unsubscribe on unmount\n    useIsomorphicLayoutEffect(()=>subscribe(ref, renderPriority, store), [\n        renderPriority,\n        subscribe,\n        store\n    ]);\n    return null;\n}\n/**\n * Returns a node graph of an object with named nodes & materials.\n * @see https://docs.pmnd.rs/react-three-fiber/api/hooks#usegraph\n */ function useGraph(object) {\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>buildGraph(object), [\n        object\n    ]);\n}\nfunction loadingFn(extensions, onProgress) {\n    return function(Proto, ...input) {\n        // Construct new loader and run extensions\n        const loader = new Proto();\n        if (extensions) extensions(loader);\n        // Go through the urls and load them\n        return Promise.all(input.map((input)=>new Promise((res, reject)=>loader.load(input, (data)=>{\n                    if (data.scene) Object.assign(data, buildGraph(data.scene));\n                    res(data);\n                }, onProgress, (error)=>reject(new Error(`Could not load ${input}: ${error.message}`))))));\n    };\n}\n/**\n * Synchronously loads and caches assets with a three loader.\n *\n * Note: this hook's caller must be wrapped with `React.Suspense`\n * @see https://docs.pmnd.rs/react-three-fiber/api/hooks#useloader\n */ function useLoader(Proto, input, extensions, onProgress) {\n    // Use suspense to load async assets\n    const keys = Array.isArray(input) ? input : [\n        input\n    ];\n    const results = (0,suspend_react__WEBPACK_IMPORTED_MODULE_6__.suspend)(loadingFn(extensions, onProgress), [\n        Proto,\n        ...keys\n    ], {\n        equal: is.equ\n    });\n    // Return the object/s\n    return Array.isArray(input) ? results : results[0];\n}\n/**\n * Preloads an asset into cache as a side-effect.\n */ useLoader.preload = function(Proto, input, extensions) {\n    const keys = Array.isArray(input) ? input : [\n        input\n    ];\n    return (0,suspend_react__WEBPACK_IMPORTED_MODULE_6__.preload)(loadingFn(extensions), [\n        Proto,\n        ...keys\n    ]);\n};\n/**\n * Removes a loaded asset from cache.\n */ useLoader.clear = function(Proto, input) {\n    const keys = Array.isArray(input) ? input : [\n        input\n    ];\n    return (0,suspend_react__WEBPACK_IMPORTED_MODULE_6__.clear)([\n        Proto,\n        ...keys\n    ]);\n};\nconst roots = new Map();\nconst { invalidate, advance } = createLoop(roots);\nconst { reconciler, applyProps } = createRenderer(roots, getEventPriority);\nconst shallowLoose = {\n    objects: \"shallow\",\n    strict: false\n};\nconst createRendererInstance = (gl, canvas)=>{\n    const customRenderer = typeof gl === \"function\" ? gl(canvas) : gl;\n    if (isRenderer(customRenderer)) return customRenderer;\n    else return new three__WEBPACK_IMPORTED_MODULE_7__.WebGLRenderer({\n        powerPreference: \"high-performance\",\n        canvas: canvas,\n        antialias: true,\n        alpha: true,\n        ...gl\n    });\n};\nfunction computeInitialSize(canvas, defaultSize) {\n    if (defaultSize) return defaultSize;\n    if (typeof HTMLCanvasElement !== \"undefined\" && canvas instanceof HTMLCanvasElement && canvas.parentElement) {\n        const { width, height, top, left } = canvas.parentElement.getBoundingClientRect();\n        return {\n            width,\n            height,\n            top,\n            left\n        };\n    } else if (typeof OffscreenCanvas !== \"undefined\" && canvas instanceof OffscreenCanvas) {\n        return {\n            width: canvas.width,\n            height: canvas.height,\n            top: 0,\n            left: 0\n        };\n    }\n    return {\n        width: 0,\n        height: 0,\n        top: 0,\n        left: 0\n    };\n}\nfunction createRoot(canvas) {\n    // Check against mistaken use of createRoot\n    const prevRoot = roots.get(canvas);\n    const prevFiber = prevRoot == null ? void 0 : prevRoot.fiber;\n    const prevStore = prevRoot == null ? void 0 : prevRoot.store;\n    if (prevRoot) console.warn(\"R3F.createRoot should only be called once!\");\n    // Report when an error was detected in a previous render\n    // https://github.com/pmndrs/react-three-fiber/pull/2261\n    const logRecoverableError = typeof reportError === \"function\" ? // In modern browsers, reportError will dispatch an error event,\n    // emulating an uncaught JavaScript error.\n    reportError : // In older browsers and test environments, fallback to console.error.\n    console.error;\n    // Create store\n    const store = prevStore || createStore(invalidate, advance);\n    // Create renderer\n    const fiber = prevFiber || reconciler.createContainer(store, react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.ConcurrentRoot, null, false, null, \"\", logRecoverableError, null);\n    // Map it\n    if (!prevRoot) roots.set(canvas, {\n        fiber,\n        store\n    });\n    // Locals\n    let onCreated;\n    let configured = false;\n    let lastCamera;\n    return {\n        configure (props = {}) {\n            let { gl: glConfig, size: propsSize, scene: sceneOptions, events, onCreated: onCreatedCallback, shadows = false, linear = false, flat = false, legacy = false, orthographic = false, frameloop = \"always\", dpr = [\n                1,\n                2\n            ], performance: performance1, raycaster: raycastOptions, camera: cameraOptions, onPointerMissed } = props;\n            let state = store.getState();\n            // Set up renderer (one time only!)\n            let gl = state.gl;\n            if (!state.gl) state.set({\n                gl: gl = createRendererInstance(glConfig, canvas)\n            });\n            // Set up raycaster (one time only!)\n            let raycaster = state.raycaster;\n            if (!raycaster) state.set({\n                raycaster: raycaster = new three__WEBPACK_IMPORTED_MODULE_4__.Raycaster()\n            });\n            // Set raycaster options\n            const { params, ...options } = raycastOptions || {};\n            if (!is.equ(options, raycaster, shallowLoose)) applyProps(raycaster, {\n                ...options\n            });\n            if (!is.equ(params, raycaster.params, shallowLoose)) applyProps(raycaster, {\n                params: {\n                    ...raycaster.params,\n                    ...params\n                }\n            });\n            // Create default camera, don't overwrite any user-set state\n            if (!state.camera || state.camera === lastCamera && !is.equ(lastCamera, cameraOptions, shallowLoose)) {\n                lastCamera = cameraOptions;\n                const isCamera = cameraOptions instanceof three__WEBPACK_IMPORTED_MODULE_4__.Camera;\n                const camera = isCamera ? cameraOptions : orthographic ? new three__WEBPACK_IMPORTED_MODULE_4__.OrthographicCamera(0, 0, 0, 0, 0.1, 1000) : new three__WEBPACK_IMPORTED_MODULE_4__.PerspectiveCamera(75, 0, 0.1, 1000);\n                if (!isCamera) {\n                    camera.position.z = 5;\n                    if (cameraOptions) applyProps(camera, cameraOptions);\n                    // Always look at center by default\n                    if (!state.camera && !(cameraOptions != null && cameraOptions.rotation)) camera.lookAt(0, 0, 0);\n                }\n                state.set({\n                    camera\n                });\n            }\n            // Set up scene (one time only!)\n            if (!state.scene) {\n                let scene;\n                if (sceneOptions instanceof three__WEBPACK_IMPORTED_MODULE_4__.Scene) {\n                    scene = sceneOptions;\n                } else {\n                    scene = new three__WEBPACK_IMPORTED_MODULE_4__.Scene();\n                    if (sceneOptions) applyProps(scene, sceneOptions);\n                }\n                state.set({\n                    scene: prepare(scene)\n                });\n            }\n            // Set up XR (one time only!)\n            if (!state.xr) {\n                var _gl$xr;\n                // Handle frame behavior in WebXR\n                const handleXRFrame = (timestamp, frame)=>{\n                    const state = store.getState();\n                    if (state.frameloop === \"never\") return;\n                    advance(timestamp, true, state, frame);\n                };\n                // Toggle render switching on session\n                const handleSessionChange = ()=>{\n                    const state = store.getState();\n                    state.gl.xr.enabled = state.gl.xr.isPresenting;\n                    state.gl.xr.setAnimationLoop(state.gl.xr.isPresenting ? handleXRFrame : null);\n                    if (!state.gl.xr.isPresenting) invalidate(state);\n                };\n                // WebXR session manager\n                const xr = {\n                    connect () {\n                        const gl = store.getState().gl;\n                        gl.xr.addEventListener(\"sessionstart\", handleSessionChange);\n                        gl.xr.addEventListener(\"sessionend\", handleSessionChange);\n                    },\n                    disconnect () {\n                        const gl = store.getState().gl;\n                        gl.xr.removeEventListener(\"sessionstart\", handleSessionChange);\n                        gl.xr.removeEventListener(\"sessionend\", handleSessionChange);\n                    }\n                };\n                // Subscribe to WebXR session events\n                if (typeof ((_gl$xr = gl.xr) == null ? void 0 : _gl$xr.addEventListener) === \"function\") xr.connect();\n                state.set({\n                    xr\n                });\n            }\n            // Set shadowmap\n            if (gl.shadowMap) {\n                const oldEnabled = gl.shadowMap.enabled;\n                const oldType = gl.shadowMap.type;\n                gl.shadowMap.enabled = !!shadows;\n                if (is.boo(shadows)) {\n                    gl.shadowMap.type = three__WEBPACK_IMPORTED_MODULE_4__.PCFSoftShadowMap;\n                } else if (is.str(shadows)) {\n                    var _types$shadows;\n                    const types = {\n                        basic: three__WEBPACK_IMPORTED_MODULE_4__.BasicShadowMap,\n                        percentage: three__WEBPACK_IMPORTED_MODULE_4__.PCFShadowMap,\n                        soft: three__WEBPACK_IMPORTED_MODULE_4__.PCFSoftShadowMap,\n                        variance: three__WEBPACK_IMPORTED_MODULE_4__.VSMShadowMap\n                    };\n                    gl.shadowMap.type = (_types$shadows = types[shadows]) != null ? _types$shadows : three__WEBPACK_IMPORTED_MODULE_4__.PCFSoftShadowMap;\n                } else if (is.obj(shadows)) {\n                    Object.assign(gl.shadowMap, shadows);\n                }\n                if (oldEnabled !== gl.shadowMap.enabled || oldType !== gl.shadowMap.type) gl.shadowMap.needsUpdate = true;\n            }\n            // Safely set color management if available.\n            // Avoid accessing THREE.ColorManagement to play nice with older versions\n            const ColorManagement = getColorManagement();\n            if (ColorManagement) {\n                if (\"enabled\" in ColorManagement) ColorManagement.enabled = !legacy;\n                else if (\"legacyMode\" in ColorManagement) ColorManagement.legacyMode = legacy;\n            }\n            // Set color space and tonemapping preferences\n            const LinearEncoding = 3000;\n            const sRGBEncoding = 3001;\n            applyProps(gl, {\n                outputEncoding: linear ? LinearEncoding : sRGBEncoding,\n                toneMapping: flat ? three__WEBPACK_IMPORTED_MODULE_4__.NoToneMapping : three__WEBPACK_IMPORTED_MODULE_4__.ACESFilmicToneMapping\n            });\n            // Update color management state\n            if (state.legacy !== legacy) state.set(()=>({\n                    legacy\n                }));\n            if (state.linear !== linear) state.set(()=>({\n                    linear\n                }));\n            if (state.flat !== flat) state.set(()=>({\n                    flat\n                }));\n            // Set gl props\n            if (glConfig && !is.fun(glConfig) && !isRenderer(glConfig) && !is.equ(glConfig, gl, shallowLoose)) applyProps(gl, glConfig);\n            // Store events internally\n            if (events && !state.events.handlers) state.set({\n                events: events(store)\n            });\n            // Check size, allow it to take on container bounds initially\n            const size = computeInitialSize(canvas, propsSize);\n            if (!is.equ(size, state.size, shallowLoose)) {\n                state.setSize(size.width, size.height, size.updateStyle, size.top, size.left);\n            }\n            // Check pixelratio\n            if (dpr && state.viewport.dpr !== calculateDpr(dpr)) state.setDpr(dpr);\n            // Check frameloop\n            if (state.frameloop !== frameloop) state.setFrameloop(frameloop);\n            // Check pointer missed\n            if (!state.onPointerMissed) state.set({\n                onPointerMissed\n            });\n            // Check performance\n            if (performance1 && !is.equ(performance1, state.performance, shallowLoose)) state.set((state)=>({\n                    performance: {\n                        ...state.performance,\n                        ...performance1\n                    }\n                }));\n            // Set locals\n            onCreated = onCreatedCallback;\n            configured = true;\n            return this;\n        },\n        render (children) {\n            // The root has to be configured before it can be rendered\n            if (!configured) this.configure();\n            reconciler.updateContainer(/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Provider, {\n                store: store,\n                children: children,\n                onCreated: onCreated,\n                rootElement: canvas\n            }), fiber, null, ()=>undefined);\n            return store;\n        },\n        unmount () {\n            unmountComponentAtNode(canvas);\n        }\n    };\n}\nfunction render(children, canvas, config) {\n    console.warn(\"R3F.render is no longer supported in React 18. Use createRoot instead!\");\n    const root = createRoot(canvas);\n    root.configure(config);\n    return root.render(children);\n}\nfunction Provider({ store, children, onCreated, rootElement }) {\n    useIsomorphicLayoutEffect(()=>{\n        const state = store.getState();\n        // Flag the canvas active, rendering will now begin\n        state.set((state)=>({\n                internal: {\n                    ...state.internal,\n                    active: true\n                }\n            }));\n        // Notifiy that init is completed, the scene graph exists, but nothing has yet rendered\n        if (onCreated) onCreated(state);\n        // Connect events to the targets parent, this is done to ensure events are registered on\n        // a shared target, and not on the canvas itself\n        if (!store.getState().events.connected) state.events.connect == null ? void 0 : state.events.connect(rootElement);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(context.Provider, {\n        value: store\n    }, children);\n}\nfunction unmountComponentAtNode(canvas, callback) {\n    const root = roots.get(canvas);\n    const fiber = root == null ? void 0 : root.fiber;\n    if (fiber) {\n        const state = root == null ? void 0 : root.store.getState();\n        if (state) state.internal.active = false;\n        reconciler.updateContainer(null, fiber, null, ()=>{\n            if (state) {\n                setTimeout(()=>{\n                    try {\n                        var _state$gl, _state$gl$renderLists, _state$gl2, _state$gl3;\n                        state.events.disconnect == null ? void 0 : state.events.disconnect();\n                        (_state$gl = state.gl) == null ? void 0 : (_state$gl$renderLists = _state$gl.renderLists) == null ? void 0 : _state$gl$renderLists.dispose == null ? void 0 : _state$gl$renderLists.dispose();\n                        (_state$gl2 = state.gl) == null ? void 0 : _state$gl2.forceContextLoss == null ? void 0 : _state$gl2.forceContextLoss();\n                        if ((_state$gl3 = state.gl) != null && _state$gl3.xr) state.xr.disconnect();\n                        dispose(state);\n                        roots.delete(canvas);\n                        if (callback) callback(canvas);\n                    } catch (e) {\n                    /* ... */ }\n                }, 500);\n            }\n        });\n    }\n}\nfunction createPortal(children, container, state) {\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Portal, {\n        key: container.uuid,\n        children: children,\n        container: container,\n        state: state\n    });\n}\nfunction Portal({ state = {}, children, container }) {\n    /** This has to be a component because it would not be able to call useThree/useStore otherwise since\n   *  if this is our environment, then we are not in r3f's renderer but in react-dom, it would trigger\n   *  the \"R3F hooks can only be used within the Canvas component!\" warning:\n   *  <Canvas>\n   *    {createPortal(...)} */ const { events, size, ...rest } = state;\n    const previousRoot = useStore();\n    const [raycaster] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>new three__WEBPACK_IMPORTED_MODULE_4__.Raycaster());\n    const [pointer] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>new three__WEBPACK_IMPORTED_MODULE_4__.Vector2());\n    const inject = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((rootState, injectState)=>{\n        const intersect = {\n            ...rootState\n        }; // all prev state props\n        // Only the fields of \"rootState\" that do not differ from injectState\n        // Some props should be off-limits\n        // Otherwise filter out the props that are different and let the inject layer take precedence\n        Object.keys(rootState).forEach((key)=>{\n            if (// Some props should be off-limits\n            privateKeys.includes(key) || // Otherwise filter out the props that are different and let the inject layer take precedence\n            // Unless the inject layer props is undefined, then we keep the root layer\n            rootState[key] !== injectState[key] && injectState[key]) {\n                delete intersect[key];\n            }\n        });\n        let viewport = undefined;\n        if (injectState && size) {\n            const camera = injectState.camera;\n            // Calculate the override viewport, if present\n            viewport = rootState.viewport.getCurrentViewport(camera, new three__WEBPACK_IMPORTED_MODULE_4__.Vector3(), size);\n            // Update the portal camera, if it differs from the previous layer\n            if (camera !== rootState.camera) updateCamera(camera, size);\n        }\n        return {\n            // The intersect consists of the previous root state\n            ...intersect,\n            // Portals have their own scene, which forms the root, a raycaster and a pointer\n            scene: container,\n            raycaster,\n            pointer,\n            mouse: pointer,\n            // Their previous root is the layer before it\n            previousRoot,\n            // Events, size and viewport can be overridden by the inject layer\n            events: {\n                ...rootState.events,\n                ...injectState == null ? void 0 : injectState.events,\n                ...events\n            },\n            size: {\n                ...rootState.size,\n                ...size\n            },\n            viewport: {\n                ...rootState.viewport,\n                ...viewport\n            },\n            ...rest\n        };\n    }, [\n        state\n    ]);\n    const [usePortalStore] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>{\n        // Create a mirrored store, based on the previous root with a few overrides ...\n        const previousState = previousRoot.getState();\n        const store = (0,zustand__WEBPACK_IMPORTED_MODULE_5__[\"default\"])((set, get)=>({\n                ...previousState,\n                scene: container,\n                raycaster,\n                pointer,\n                mouse: pointer,\n                previousRoot,\n                events: {\n                    ...previousState.events,\n                    ...events\n                },\n                size: {\n                    ...previousState.size,\n                    ...size\n                },\n                ...rest,\n                // Set and get refer to this root-state\n                set,\n                get,\n                // Layers are allowed to override events\n                setEvents: (events)=>set((state)=>({\n                            ...state,\n                            events: {\n                                ...state.events,\n                                ...events\n                            }\n                        }))\n            }));\n        return store;\n    });\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        // Subscribe to previous root-state and copy changes over to the mirrored portal-state\n        const unsub = previousRoot.subscribe((prev)=>usePortalStore.setState((state)=>inject(prev, state)));\n        return ()=>{\n            unsub();\n            usePortalStore.destroy();\n        };\n    }, []);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        usePortalStore.setState((injectState)=>inject(previousRoot.getState(), injectState));\n    }, [\n        inject\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, reconciler.createPortal(/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(context.Provider, {\n        value: usePortalStore\n    }, children), usePortalStore, null));\n}\nreconciler.injectIntoDevTools({\n    bundleType:  false ? 0 : 1,\n    rendererPackageName: \"@react-three/fiber\",\n    version: react__WEBPACK_IMPORTED_MODULE_0__.version\n});\nconst act = react__WEBPACK_IMPORTED_MODULE_0__.unstable_act;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2ZpYmVyL2Rpc3QvaW5kZXgtNjczZWY5ODcuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQStCO0FBQ0E7QUFDbUc7QUFDckc7QUFDYTtBQUNtQztBQUNyQjtBQUV4RCxJQUFJYSxhQUFhLFdBQVcsR0FBRUMsT0FBT0MsTUFBTSxDQUFDO0lBQzFDQyxXQUFXO0FBQ2I7QUFFQSxNQUFNQyxZQUFZLENBQUM7QUFDbkIsTUFBTUMsU0FBU0MsQ0FBQUEsVUFBVyxLQUFLTCxPQUFPTSxNQUFNLENBQUNILFdBQVdFO0FBQ3hELFNBQVNFLGVBQWVDLE1BQU0sRUFBRUMsaUJBQWlCO0lBQy9DLFNBQVNDLGVBQWVDLElBQUksRUFBRSxFQUM1QkMsT0FBTyxFQUFFLEVBQ1RDLE1BQU0sRUFDTixHQUFHQyxPQUNKLEVBQUVDLElBQUk7UUFDTCxJQUFJQyxPQUFPLENBQUMsRUFBRUwsSUFBSSxDQUFDLEVBQUUsQ0FBQ00sV0FBVyxHQUFHLEVBQUVOLEtBQUtPLEtBQUssQ0FBQyxHQUFHLENBQUM7UUFDckQsSUFBSUM7UUFDSixJQUFJUixTQUFTLGFBQWE7WUFDeEIsSUFBSUcsTUFBTU0sTUFBTSxLQUFLQyxXQUFXLE1BQU0sSUFBSUMsTUFBTTtZQUNoRCxNQUFNRixTQUFTTixNQUFNTSxNQUFNO1lBQzNCRCxXQUFXSSxRQUFRSCxRQUFRO2dCQUN6QlQ7Z0JBQ0FJO2dCQUNBRjtnQkFDQVcsV0FBVztZQUNiO1FBQ0YsT0FBTztZQUNMLE1BQU1DLFNBQVN0QixTQUFTLENBQUNhLEtBQUs7WUFDOUIsSUFBSSxDQUFDUyxRQUFRO2dCQUNYLE1BQU0sSUFBSUgsTUFBTSxDQUFDLEtBQUssRUFBRU4sS0FBSyw0SkFBNEosQ0FBQztZQUM1TDtZQUVBLG9EQUFvRDtZQUNwRCxJQUFJLENBQUNVLE1BQU1DLE9BQU8sQ0FBQ2YsT0FBTyxNQUFNLElBQUlVLE1B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QVcsR0FBRXBtQixnREFBbUIsQ0FBQ0EsMkNBQWMsRUFBRSxNQUFNeUcsV0FBV3VmLFlBQVksQ0FBRSxXQUFXLEdBQUVobUIsZ0RBQW1CLENBQUNvYSxRQUFRaUwsUUFBUSxFQUFFO1FBQ3hJN2MsT0FBTytkO0lBQ1QsR0FBR3ZpQixXQUFXdWlCLGdCQUFnQjtBQUNoQztBQUNBOWYsV0FBV3FnQixrQkFBa0IsQ0FBQztJQUM1QkMsWUFBWUMsTUFBeUIsR0FBZSxDQUFDLEdBQUc7SUFDeERDLHFCQUFxQjtJQUNyQkMsU0FBU2xuQiwwQ0FBYTtBQUN4QjtBQUNBLE1BQU1tbkIsTUFBTW5uQiwrQ0FBa0I7QUFFc2dCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXlWUnByb2plY3QvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2ZpYmVyL2Rpc3QvaW5kZXgtNjczZWY5ODcuZXNtLmpzP2U1YWYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgRGVmYXVsdEV2ZW50UHJpb3JpdHksIENvbnRpbnVvdXNFdmVudFByaW9yaXR5LCBEaXNjcmV0ZUV2ZW50UHJpb3JpdHksIENvbmN1cnJlbnRSb290IH0gZnJvbSAncmVhY3QtcmVjb25jaWxlci9jb25zdGFudHMnO1xuaW1wb3J0IGNyZWF0ZSBmcm9tICd6dXN0YW5kJztcbmltcG9ydCBSZWNvbmNpbGVyIGZyb20gJ3JlYWN0LXJlY29uY2lsZXInO1xuaW1wb3J0IHsgdW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjaywgdW5zdGFibGVfSWRsZVByaW9yaXR5IH0gZnJvbSAnc2NoZWR1bGVyJztcbmltcG9ydCB7IHN1c3BlbmQsIHByZWxvYWQsIGNsZWFyIH0gZnJvbSAnc3VzcGVuZC1yZWFjdCc7XG5cbnZhciB0aHJlZVR5cGVzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGxcbn0pO1xuXG5jb25zdCBjYXRhbG9ndWUgPSB7fTtcbmNvbnN0IGV4dGVuZCA9IG9iamVjdHMgPT4gdm9pZCBPYmplY3QuYXNzaWduKGNhdGFsb2d1ZSwgb2JqZWN0cyk7XG5mdW5jdGlvbiBjcmVhdGVSZW5kZXJlcihfcm9vdHMsIF9nZXRFdmVudFByaW9yaXR5KSB7XG4gIGZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlKHR5cGUsIHtcbiAgICBhcmdzID0gW10sXG4gICAgYXR0YWNoLFxuICAgIC4uLnByb3BzXG4gIH0sIHJvb3QpIHtcbiAgICBsZXQgbmFtZSA9IGAke3R5cGVbMF0udG9VcHBlckNhc2UoKX0ke3R5cGUuc2xpY2UoMSl9YDtcbiAgICBsZXQgaW5zdGFuY2U7XG4gICAgaWYgKHR5cGUgPT09ICdwcmltaXRpdmUnKSB7XG4gICAgICBpZiAocHJvcHMub2JqZWN0ID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvcihcIlIzRjogUHJpbWl0aXZlcyB3aXRob3V0ICdvYmplY3QnIGFyZSBpbnZhbGlkIVwiKTtcbiAgICAgIGNvbnN0IG9iamVjdCA9IHByb3BzLm9iamVjdDtcbiAgICAgIGluc3RhbmNlID0gcHJlcGFyZShvYmplY3QsIHtcbiAgICAgICAgdHlwZSxcbiAgICAgICAgcm9vdCxcbiAgICAgICAgYXR0YWNoLFxuICAgICAgICBwcmltaXRpdmU6IHRydWVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0YXJnZXQgPSBjYXRhbG9ndWVbbmFtZV07XG4gICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFIzRjogJHtuYW1lfSBpcyBub3QgcGFydCBvZiB0aGUgVEhSRUUgbmFtZXNwYWNlISBEaWQgeW91IGZvcmdldCB0byBleHRlbmQ/IFNlZTogaHR0cHM6Ly9kb2NzLnBtbmQucnMvcmVhY3QtdGhyZWUtZmliZXIvYXBpL29iamVjdHMjdXNpbmctM3JkLXBhcnR5LW9iamVjdHMtZGVjbGFyYXRpdmVseWApO1xuICAgICAgfVxuXG4gICAgICAvLyBUaHJvdyBpZiBhbiBvYmplY3Qgb3IgbGl0ZXJhbCB3YXMgcGFzc2VkIGZvciBhcmdzXG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJncykpIHRocm93IG5ldyBFcnJvcignUjNGOiBUaGUgYXJncyBwcm9wIG11c3QgYmUgYW4gYXJyYXkhJyk7XG5cbiAgICAgIC8vIEluc3RhbmNpYXRlIG5ldyBvYmplY3QsIGxpbmsgaXQgdG8gdGhlIHJvb3RcbiAgICAgIC8vIEFwcGVuZCBtZW1vaXplZCBwcm9wcyB3aXRoIGFyZ3Mgc28gaXQncyBub3QgZm9yZ290dGVuXG4gICAgICBpbnN0YW5jZSA9IHByZXBhcmUobmV3IHRhcmdldCguLi5hcmdzKSwge1xuICAgICAgICB0eXBlLFxuICAgICAgICByb290LFxuICAgICAgICBhdHRhY2gsXG4gICAgICAgIC8vIFNhdmUgYXJncyBpbiBjYXNlIHdlIG5lZWQgdG8gcmVjb25zdHJ1Y3QgbGF0ZXIgZm9yIEhNUlxuICAgICAgICBtZW1vaXplZFByb3BzOiB7XG4gICAgICAgICAgYXJnc1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBBdXRvLWF0dGFjaCBnZW9tZXRyaWVzIGFuZCBtYXRlcmlhbHNcbiAgICBpZiAoaW5zdGFuY2UuX19yM2YuYXR0YWNoID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChpbnN0YW5jZSBpbnN0YW5jZW9mIFRIUkVFLkJ1ZmZlckdlb21ldHJ5KSBpbnN0YW5jZS5fX3IzZi5hdHRhY2ggPSAnZ2VvbWV0cnknO2Vsc2UgaWYgKGluc3RhbmNlIGluc3RhbmNlb2YgVEhSRUUuTWF0ZXJpYWwpIGluc3RhbmNlLl9fcjNmLmF0dGFjaCA9ICdtYXRlcmlhbCc7XG4gICAgfVxuXG4gICAgLy8gSXQgc2hvdWxkIE5PVCBjYWxsIG9uVXBkYXRlIG9uIG9iamVjdCBpbnN0YW5jaWF0aW9uLCBiZWNhdXNlIGl0IGhhc24ndCBiZWVuIGFkZGVkIHRvIHRoZVxuICAgIC8vIHZpZXcgeWV0LiBJZiB0aGUgY2FsbGJhY2sgcmVsaWVzIG9uIHJlZmVyZW5jZXMgZm9yIGluc3RhbmNlLCB0aGV5IHdvbid0IGJlIHJlYWR5IHlldCwgdGhpcyBpc1xuICAgIC8vIHdoeSBpdCBwYXNzZXMgXCJ0cnVlXCIgaGVyZVxuICAgIC8vIFRoZXJlIGlzIG5vIHJlYXNvbiB0byBhcHBseSBwcm9wcyB0byBpbmplY3RzXG4gICAgaWYgKG5hbWUgIT09ICdpbmplY3QnKSBhcHBseVByb3BzJDEoaW5zdGFuY2UsIHByb3BzKTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH1cbiAgZnVuY3Rpb24gYXBwZW5kQ2hpbGQocGFyZW50SW5zdGFuY2UsIGNoaWxkKSB7XG4gICAgbGV0IGFkZGVkID0gZmFsc2U7XG4gICAgaWYgKGNoaWxkKSB7XG4gICAgICB2YXIgX2NoaWxkJF9fcjNmLCBfcGFyZW50SW5zdGFuY2UkX19yM2Y7XG4gICAgICAvLyBUaGUgYXR0YWNoIGF0dHJpYnV0ZSBpbXBsaWVzIHRoYXQgdGhlIG9iamVjdCBhdHRhY2hlcyBpdHNlbGYgb24gdGhlIHBhcmVudFxuICAgICAgaWYgKChfY2hpbGQkX19yM2YgPSBjaGlsZC5fX3IzZikgIT0gbnVsbCAmJiBfY2hpbGQkX19yM2YuYXR0YWNoKSB7XG4gICAgICAgIGF0dGFjaChwYXJlbnRJbnN0YW5jZSwgY2hpbGQsIGNoaWxkLl9fcjNmLmF0dGFjaCk7XG4gICAgICB9IGVsc2UgaWYgKGNoaWxkLmlzT2JqZWN0M0QgJiYgcGFyZW50SW5zdGFuY2UuaXNPYmplY3QzRCkge1xuICAgICAgICAvLyBhZGQgaW4gdGhlIHVzdWFsIHBhcmVudC1jaGlsZCB3YXlcbiAgICAgICAgcGFyZW50SW5zdGFuY2UuYWRkKGNoaWxkKTtcbiAgICAgICAgYWRkZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgLy8gVGhpcyBpcyBmb3IgYW55dGhpbmcgdGhhdCB1c2VkIGF0dGFjaCwgYW5kIGZvciBub24tT2JqZWN0M0RzIHRoYXQgZG9uJ3QgZ2V0IGF0dGFjaGVkIHRvIHByb3BzO1xuICAgICAgLy8gdGhhdCBpcywgYW55dGhpbmcgdGhhdCdzIGEgY2hpbGQgaW4gUmVhY3QgYnV0IG5vdCBhIGNoaWxkIGluIHRoZSBzY2VuZWdyYXBoLlxuICAgICAgaWYgKCFhZGRlZCkgKF9wYXJlbnRJbnN0YW5jZSRfX3IzZiA9IHBhcmVudEluc3RhbmNlLl9fcjNmKSA9PSBudWxsID8gdm9pZCAwIDogX3BhcmVudEluc3RhbmNlJF9fcjNmLm9iamVjdHMucHVzaChjaGlsZCk7XG4gICAgICBpZiAoIWNoaWxkLl9fcjNmKSBwcmVwYXJlKGNoaWxkLCB7fSk7XG4gICAgICBjaGlsZC5fX3IzZi5wYXJlbnQgPSBwYXJlbnRJbnN0YW5jZTtcbiAgICAgIHVwZGF0ZUluc3RhbmNlKGNoaWxkKTtcbiAgICAgIGludmFsaWRhdGVJbnN0YW5jZShjaGlsZCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGluc2VydEJlZm9yZShwYXJlbnRJbnN0YW5jZSwgY2hpbGQsIGJlZm9yZUNoaWxkKSB7XG4gICAgbGV0IGFkZGVkID0gZmFsc2U7XG4gICAgaWYgKGNoaWxkKSB7XG4gICAgICB2YXIgX2NoaWxkJF9fcjNmMiwgX3BhcmVudEluc3RhbmNlJF9fcjNmMjtcbiAgICAgIGlmICgoX2NoaWxkJF9fcjNmMiA9IGNoaWxkLl9fcjNmKSAhPSBudWxsICYmIF9jaGlsZCRfX3IzZjIuYXR0YWNoKSB7XG4gICAgICAgIGF0dGFjaChwYXJlbnRJbnN0YW5jZSwgY2hpbGQsIGNoaWxkLl9fcjNmLmF0dGFjaCk7XG4gICAgICB9IGVsc2UgaWYgKGNoaWxkLmlzT2JqZWN0M0QgJiYgcGFyZW50SW5zdGFuY2UuaXNPYmplY3QzRCkge1xuICAgICAgICBjaGlsZC5wYXJlbnQgPSBwYXJlbnRJbnN0YW5jZTtcbiAgICAgICAgY2hpbGQuZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgdHlwZTogJ2FkZGVkJ1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVzdFNpYmxpbmdzID0gcGFyZW50SW5zdGFuY2UuY2hpbGRyZW4uZmlsdGVyKHNpYmxpbmcgPT4gc2libGluZyAhPT0gY2hpbGQpO1xuICAgICAgICBjb25zdCBpbmRleCA9IHJlc3RTaWJsaW5ncy5pbmRleE9mKGJlZm9yZUNoaWxkKTtcbiAgICAgICAgcGFyZW50SW5zdGFuY2UuY2hpbGRyZW4gPSBbLi4ucmVzdFNpYmxpbmdzLnNsaWNlKDAsIGluZGV4KSwgY2hpbGQsIC4uLnJlc3RTaWJsaW5ncy5zbGljZShpbmRleCldO1xuICAgICAgICBhZGRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoIWFkZGVkKSAoX3BhcmVudEluc3RhbmNlJF9fcjNmMiA9IHBhcmVudEluc3RhbmNlLl9fcjNmKSA9PSBudWxsID8gdm9pZCAwIDogX3BhcmVudEluc3RhbmNlJF9fcjNmMi5vYmplY3RzLnB1c2goY2hpbGQpO1xuICAgICAgaWYgKCFjaGlsZC5fX3IzZikgcHJlcGFyZShjaGlsZCwge30pO1xuICAgICAgY2hpbGQuX19yM2YucGFyZW50ID0gcGFyZW50SW5zdGFuY2U7XG4gICAgICB1cGRhdGVJbnN0YW5jZShjaGlsZCk7XG4gICAgICBpbnZhbGlkYXRlSW5zdGFuY2UoY2hpbGQpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiByZW1vdmVSZWN1cnNpdmUoYXJyYXksIHBhcmVudCwgZGlzcG9zZSA9IGZhbHNlKSB7XG4gICAgaWYgKGFycmF5KSBbLi4uYXJyYXldLmZvckVhY2goY2hpbGQgPT4gcmVtb3ZlQ2hpbGQocGFyZW50LCBjaGlsZCwgZGlzcG9zZSkpO1xuICB9XG4gIGZ1bmN0aW9uIHJlbW92ZUNoaWxkKHBhcmVudEluc3RhbmNlLCBjaGlsZCwgZGlzcG9zZSkge1xuICAgIGlmIChjaGlsZCkge1xuICAgICAgdmFyIF9wYXJlbnRJbnN0YW5jZSRfX3IzZjMsIF9jaGlsZCRfX3IzZjMsIF9jaGlsZCRfX3IzZjU7XG4gICAgICAvLyBDbGVhciB0aGUgcGFyZW50IHJlZmVyZW5jZVxuICAgICAgaWYgKGNoaWxkLl9fcjNmKSBjaGlsZC5fX3IzZi5wYXJlbnQgPSBudWxsO1xuICAgICAgLy8gUmVtb3ZlIGNoaWxkIGZyb20gdGhlIHBhcmVudHMgb2JqZWN0c1xuICAgICAgaWYgKChfcGFyZW50SW5zdGFuY2UkX19yM2YzID0gcGFyZW50SW5zdGFuY2UuX19yM2YpICE9IG51bGwgJiYgX3BhcmVudEluc3RhbmNlJF9fcjNmMy5vYmplY3RzKSBwYXJlbnRJbnN0YW5jZS5fX3IzZi5vYmplY3RzID0gcGFyZW50SW5zdGFuY2UuX19yM2Yub2JqZWN0cy5maWx0ZXIoeCA9PiB4ICE9PSBjaGlsZCk7XG4gICAgICAvLyBSZW1vdmUgYXR0YWNobWVudFxuICAgICAgaWYgKChfY2hpbGQkX19yM2YzID0gY2hpbGQuX19yM2YpICE9IG51bGwgJiYgX2NoaWxkJF9fcjNmMy5hdHRhY2gpIHtcbiAgICAgICAgZGV0YWNoKHBhcmVudEluc3RhbmNlLCBjaGlsZCwgY2hpbGQuX19yM2YuYXR0YWNoKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hpbGQuaXNPYmplY3QzRCAmJiBwYXJlbnRJbnN0YW5jZS5pc09iamVjdDNEKSB7XG4gICAgICAgIHZhciBfY2hpbGQkX19yM2Y0O1xuICAgICAgICBwYXJlbnRJbnN0YW5jZS5yZW1vdmUoY2hpbGQpO1xuICAgICAgICAvLyBSZW1vdmUgaW50ZXJhY3Rpdml0eVxuICAgICAgICBpZiAoKF9jaGlsZCRfX3IzZjQgPSBjaGlsZC5fX3IzZikgIT0gbnVsbCAmJiBfY2hpbGQkX19yM2Y0LnJvb3QpIHtcbiAgICAgICAgICByZW1vdmVJbnRlcmFjdGl2aXR5KGNoaWxkLl9fcjNmLnJvb3QsIGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBBbGxvdyBvYmplY3RzIHRvIGJhaWwgb3V0IG9mIHJlY3Vyc2l2ZSBkaXNwb3NlIGFsdG9nZXRoZXIgYnkgcGFzc2luZyBkaXNwb3NlPXtudWxsfVxuICAgICAgLy8gTmV2ZXIgZGlzcG9zZSBvZiBwcmltaXRpdmVzIGJlY2F1c2UgdGhlaXIgc3RhdGUgbWF5IGJlIGtlcHQgb3V0c2lkZSBvZiBSZWFjdCFcbiAgICAgIC8vIEluIG9yZGVyIGZvciBhbiBvYmplY3QgdG8gYmUgYWJsZSB0byBkaXNwb3NlIGl0IGhhcyB0byBoYXZlXG4gICAgICAvLyAgIC0gYSBkaXNwb3NlIG1ldGhvZCxcbiAgICAgIC8vICAgLSBpdCBjYW5ub3QgYmUgYSA8cHJpbWl0aXZlIG9iamVjdD17Li4ufSAvPlxuICAgICAgLy8gICAtIGl0IGNhbm5vdCBiZSBhIFRIUkVFLlNjZW5lLCBiZWNhdXNlIHRocmVlIGhhcyBicm9rZW4gaXQncyBvd24gYXBpXG4gICAgICAvL1xuICAgICAgLy8gU2luY2UgZGlzcG9zYWwgaXMgcmVjdXJzaXZlLCB3ZSBjYW4gY2hlY2sgdGhlIG9wdGlvbmFsIGRpc3Bvc2UgYXJnLCB3aGljaCB3aWxsIGJlIHVuZGVmaW5lZFxuICAgICAgLy8gd2hlbiB0aGUgcmVjb25jaWxlciBjYWxscyBpdCwgYnV0IHRoZW4gY2Fycnkgb3VyIG93biBjaGVjayByZWN1cnNpdmVseVxuICAgICAgY29uc3QgaXNQcmltaXRpdmUgPSAoX2NoaWxkJF9fcjNmNSA9IGNoaWxkLl9fcjNmKSA9PSBudWxsID8gdm9pZCAwIDogX2NoaWxkJF9fcjNmNS5wcmltaXRpdmU7XG4gICAgICBjb25zdCBzaG91bGREaXNwb3NlID0gZGlzcG9zZSA9PT0gdW5kZWZpbmVkID8gY2hpbGQuZGlzcG9zZSAhPT0gbnVsbCAmJiAhaXNQcmltaXRpdmUgOiBkaXNwb3NlO1xuXG4gICAgICAvLyBSZW1vdmUgbmVzdGVkIGNoaWxkIG9iamVjdHMuIFByaW1pdGl2ZXMgc2hvdWxkIG5vdCBoYXZlIG9iamVjdHMgYW5kIGNoaWxkcmVuIHRoYXQgYXJlXG4gICAgICAvLyBhdHRhY2hlZCB0byB0aGVtIGRlY2xhcmF0aXZlbHkgLi4uXG4gICAgICBpZiAoIWlzUHJpbWl0aXZlKSB7XG4gICAgICAgIHZhciBfY2hpbGQkX19yM2Y2O1xuICAgICAgICByZW1vdmVSZWN1cnNpdmUoKF9jaGlsZCRfX3IzZjYgPSBjaGlsZC5fX3IzZikgPT0gbnVsbCA/IHZvaWQgMCA6IF9jaGlsZCRfX3IzZjYub2JqZWN0cywgY2hpbGQsIHNob3VsZERpc3Bvc2UpO1xuICAgICAgICByZW1vdmVSZWN1cnNpdmUoY2hpbGQuY2hpbGRyZW4sIGNoaWxkLCBzaG91bGREaXNwb3NlKTtcbiAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIHJlZmVyZW5jZXNcbiAgICAgIGRlbGV0ZSBjaGlsZC5fX3IzZjtcblxuICAgICAgLy8gRGlzcG9zZSBpdGVtIHdoZW5ldmVyIHRoZSByZWNvbmNpbGVyIGZlZWxzIGxpa2UgaXRcbiAgICAgIGlmIChzaG91bGREaXNwb3NlICYmIGNoaWxkLmRpc3Bvc2UgJiYgY2hpbGQudHlwZSAhPT0gJ1NjZW5lJykge1xuICAgICAgICB1bnN0YWJsZV9zY2hlZHVsZUNhbGxiYWNrKHVuc3RhYmxlX0lkbGVQcmlvcml0eSwgKCkgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjaGlsZC5kaXNwb3NlKCk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLyogLi4uICovXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGludmFsaWRhdGVJbnN0YW5jZShwYXJlbnRJbnN0YW5jZSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHN3aXRjaEluc3RhbmNlKGluc3RhbmNlLCB0eXBlLCBuZXdQcm9wcywgZmliZXIpIHtcbiAgICB2YXIgX2luc3RhbmNlJF9fcjNmO1xuICAgIGNvbnN0IHBhcmVudCA9IChfaW5zdGFuY2UkX19yM2YgPSBpbnN0YW5jZS5fX3IzZikgPT0gbnVsbCA/IHZvaWQgMCA6IF9pbnN0YW5jZSRfX3IzZi5wYXJlbnQ7XG4gICAgaWYgKCFwYXJlbnQpIHJldHVybjtcbiAgICBjb25zdCBuZXdJbnN0YW5jZSA9IGNyZWF0ZUluc3RhbmNlKHR5cGUsIG5ld1Byb3BzLCBpbnN0YW5jZS5fX3IzZi5yb290KTtcblxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvcmVhY3QtdGhyZWUtZmliZXIvaXNzdWVzLzEzNDhcbiAgICAvLyBXaGVuIGFyZ3MgY2hhbmdlIHRoZSBpbnN0YW5jZSBoYXMgdG8gYmUgcmUtY29uc3RydWN0ZWQsIHdoaWNoIHRoZW5cbiAgICAvLyBmb3JjZXMgcjNmIHRvIHJlLXBhcmVudCB0aGUgY2hpbGRyZW4gYW5kIG5vbi1zY2VuZSBvYmplY3RzXG4gICAgaWYgKGluc3RhbmNlLmNoaWxkcmVuKSB7XG4gICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGluc3RhbmNlLmNoaWxkcmVuKSB7XG4gICAgICAgIGlmIChjaGlsZC5fX3IzZikgYXBwZW5kQ2hpbGQobmV3SW5zdGFuY2UsIGNoaWxkKTtcbiAgICAgIH1cbiAgICAgIGluc3RhbmNlLmNoaWxkcmVuID0gaW5zdGFuY2UuY2hpbGRyZW4uZmlsdGVyKGNoaWxkID0+ICFjaGlsZC5fX3IzZik7XG4gICAgfVxuICAgIGluc3RhbmNlLl9fcjNmLm9iamVjdHMuZm9yRWFjaChjaGlsZCA9PiBhcHBlbmRDaGlsZChuZXdJbnN0YW5jZSwgY2hpbGQpKTtcbiAgICBpbnN0YW5jZS5fX3IzZi5vYmplY3RzID0gW107XG4gICAgaWYgKCFpbnN0YW5jZS5fX3IzZi5hdXRvUmVtb3ZlZEJlZm9yZUFwcGVuZCkge1xuICAgICAgcmVtb3ZlQ2hpbGQocGFyZW50LCBpbnN0YW5jZSk7XG4gICAgfVxuICAgIGlmIChuZXdJbnN0YW5jZS5wYXJlbnQpIHtcbiAgICAgIG5ld0luc3RhbmNlLl9fcjNmLmF1dG9SZW1vdmVkQmVmb3JlQXBwZW5kID0gdHJ1ZTtcbiAgICB9XG4gICAgYXBwZW5kQ2hpbGQocGFyZW50LCBuZXdJbnN0YW5jZSk7XG5cbiAgICAvLyBSZS1iaW5kIGV2ZW50IGhhbmRsZXJzXG4gICAgaWYgKG5ld0luc3RhbmNlLnJheWNhc3QgJiYgbmV3SW5zdGFuY2UuX19yM2YuZXZlbnRDb3VudCkge1xuICAgICAgY29uc3Qgcm9vdFN0YXRlID0gbmV3SW5zdGFuY2UuX19yM2Yucm9vdC5nZXRTdGF0ZSgpO1xuICAgICAgcm9vdFN0YXRlLmludGVybmFsLmludGVyYWN0aW9uLnB1c2gobmV3SW5zdGFuY2UpO1xuICAgIH1cbiAgICBbZmliZXIsIGZpYmVyLmFsdGVybmF0ZV0uZm9yRWFjaChmaWJlciA9PiB7XG4gICAgICBpZiAoZmliZXIgIT09IG51bGwpIHtcbiAgICAgICAgZmliZXIuc3RhdGVOb2RlID0gbmV3SW5zdGFuY2U7XG4gICAgICAgIGlmIChmaWJlci5yZWYpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGZpYmVyLnJlZiA9PT0gJ2Z1bmN0aW9uJykgZmliZXIucmVmKG5ld0luc3RhbmNlKTtlbHNlIGZpYmVyLnJlZi5jdXJyZW50ID0gbmV3SW5zdGFuY2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8vIERvbid0IGhhbmRsZSB0ZXh0IGluc3RhbmNlcywgd2FybiBvbiB1bmRlZmluZWQgYmVoYXZpb3JcbiAgY29uc3QgaGFuZGxlVGV4dEluc3RhbmNlID0gKCkgPT4gY29uc29sZS53YXJuKCdUZXh0IGlzIG5vdCBhbGxvd2VkIGluIHRoZSBSM0YgdHJlZSEgVGhpcyBjb3VsZCBiZSBzdHJheSB3aGl0ZXNwYWNlIG9yIGNoYXJhY3RlcnMuJyk7XG4gIGNvbnN0IHJlY29uY2lsZXIgPSBSZWNvbmNpbGVyKHtcbiAgICBjcmVhdGVJbnN0YW5jZSxcbiAgICByZW1vdmVDaGlsZCxcbiAgICBhcHBlbmRDaGlsZCxcbiAgICBhcHBlbmRJbml0aWFsQ2hpbGQ6IGFwcGVuZENoaWxkLFxuICAgIGluc2VydEJlZm9yZSxcbiAgICBzdXBwb3J0c011dGF0aW9uOiB0cnVlLFxuICAgIGlzUHJpbWFyeVJlbmRlcmVyOiBmYWxzZSxcbiAgICBzdXBwb3J0c1BlcnNpc3RlbmNlOiBmYWxzZSxcbiAgICBzdXBwb3J0c0h5ZHJhdGlvbjogZmFsc2UsXG4gICAgbm9UaW1lb3V0OiAtMSxcbiAgICBhcHBlbmRDaGlsZFRvQ29udGFpbmVyOiAoY29udGFpbmVyLCBjaGlsZCkgPT4ge1xuICAgICAgaWYgKCFjaGlsZCkgcmV0dXJuO1xuXG4gICAgICAvLyBEb24ndCBhcHBlbmQgdG8gdW5tb3VudGVkIGNvbnRhaW5lclxuICAgICAgY29uc3Qgc2NlbmUgPSBjb250YWluZXIuZ2V0U3RhdGUoKS5zY2VuZTtcbiAgICAgIGlmICghc2NlbmUuX19yM2YpIHJldHVybjtcblxuICAgICAgLy8gTGluayBjdXJyZW50IHJvb3QgdG8gdGhlIGRlZmF1bHQgc2NlbmVcbiAgICAgIHNjZW5lLl9fcjNmLnJvb3QgPSBjb250YWluZXI7XG4gICAgICBhcHBlbmRDaGlsZChzY2VuZSwgY2hpbGQpO1xuICAgIH0sXG4gICAgcmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyOiAoY29udGFpbmVyLCBjaGlsZCkgPT4ge1xuICAgICAgaWYgKCFjaGlsZCkgcmV0dXJuO1xuICAgICAgcmVtb3ZlQ2hpbGQoY29udGFpbmVyLmdldFN0YXRlKCkuc2NlbmUsIGNoaWxkKTtcbiAgICB9LFxuICAgIGluc2VydEluQ29udGFpbmVyQmVmb3JlOiAoY29udGFpbmVyLCBjaGlsZCwgYmVmb3JlQ2hpbGQpID0+IHtcbiAgICAgIGlmICghY2hpbGQgfHwgIWJlZm9yZUNoaWxkKSByZXR1cm47XG5cbiAgICAgIC8vIERvbid0IGFwcGVuZCB0byB1bm1vdW50ZWQgY29udGFpbmVyXG4gICAgICBjb25zdCBzY2VuZSA9IGNvbnRhaW5lci5nZXRTdGF0ZSgpLnNjZW5lO1xuICAgICAgaWYgKCFzY2VuZS5fX3IzZikgcmV0dXJuO1xuICAgICAgaW5zZXJ0QmVmb3JlKHNjZW5lLCBjaGlsZCwgYmVmb3JlQ2hpbGQpO1xuICAgIH0sXG4gICAgZ2V0Um9vdEhvc3RDb250ZXh0OiAoKSA9PiBudWxsLFxuICAgIGdldENoaWxkSG9zdENvbnRleHQ6IHBhcmVudEhvc3RDb250ZXh0ID0+IHBhcmVudEhvc3RDb250ZXh0LFxuICAgIGZpbmFsaXplSW5pdGlhbENoaWxkcmVuKGluc3RhbmNlKSB7XG4gICAgICB2YXIgX2luc3RhbmNlJF9fcjNmMjtcbiAgICAgIGNvbnN0IGxvY2FsU3RhdGUgPSAoX2luc3RhbmNlJF9fcjNmMiA9IGluc3RhbmNlID09IG51bGwgPyB2b2lkIDAgOiBpbnN0YW5jZS5fX3IzZikgIT0gbnVsbCA/IF9pbnN0YW5jZSRfX3IzZjIgOiB7fTtcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMjAyNzFcbiAgICAgIC8vIFJldHVybmluZyB0cnVlIHdpbGwgdHJpZ2dlciBjb21taXRNb3VudFxuICAgICAgcmV0dXJuIEJvb2xlYW4obG9jYWxTdGF0ZS5oYW5kbGVycyk7XG4gICAgfSxcbiAgICBwcmVwYXJlVXBkYXRlKGluc3RhbmNlLCBfdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzKSB7XG4gICAgICB2YXIgX2luc3RhbmNlJF9fcjNmMztcbiAgICAgIGNvbnN0IGxvY2FsU3RhdGUgPSAoX2luc3RhbmNlJF9fcjNmMyA9IGluc3RhbmNlID09IG51bGwgPyB2b2lkIDAgOiBpbnN0YW5jZS5fX3IzZikgIT0gbnVsbCA/IF9pbnN0YW5jZSRfX3IzZjMgOiB7fTtcblxuICAgICAgLy8gQ3JlYXRlIGRpZmYtc2V0c1xuICAgICAgaWYgKGxvY2FsU3RhdGUucHJpbWl0aXZlICYmIG5ld1Byb3BzLm9iamVjdCAmJiBuZXdQcm9wcy5vYmplY3QgIT09IGluc3RhbmNlKSB7XG4gICAgICAgIHJldHVybiBbdHJ1ZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIGlzIGEgZGF0YSBvYmplY3QsIGxldCdzIGV4dHJhY3QgY3JpdGljYWwgaW5mb3JtYXRpb24gYWJvdXQgaXRcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGFyZ3M6IGFyZ3NOZXcgPSBbXSxcbiAgICAgICAgICBjaGlsZHJlbjogY04sXG4gICAgICAgICAgLi4ucmVzdE5ld1xuICAgICAgICB9ID0gbmV3UHJvcHM7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBhcmdzOiBhcmdzT2xkID0gW10sXG4gICAgICAgICAgY2hpbGRyZW46IGNPLFxuICAgICAgICAgIC4uLnJlc3RPbGRcbiAgICAgICAgfSA9IG9sZFByb3BzO1xuXG4gICAgICAgIC8vIFRocm93IGlmIGFuIG9iamVjdCBvciBsaXRlcmFsIHdhcyBwYXNzZWQgZm9yIGFyZ3NcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGFyZ3NOZXcpKSB0aHJvdyBuZXcgRXJyb3IoJ1IzRjogdGhlIGFyZ3MgcHJvcCBtdXN0IGJlIGFuIGFycmF5IScpO1xuXG4gICAgICAgIC8vIElmIGl0IGhhcyBuZXcgcHJvcHMgb3IgYXJndW1lbnRzLCB0aGVuIGl0IG5lZWRzIHRvIGJlIHJlLWluc3RhbnRpYXRlZFxuICAgICAgICBpZiAoYXJnc05ldy5zb21lKCh2YWx1ZSwgaW5kZXgpID0+IHZhbHVlICE9PSBhcmdzT2xkW2luZGV4XSkpIHJldHVybiBbdHJ1ZV07XG4gICAgICAgIC8vIENyZWF0ZSBhIGRpZmYtc2V0LCBmbGFnIGlmIHRoZXJlIGFyZSBhbnkgY2hhbmdlc1xuICAgICAgICBjb25zdCBkaWZmID0gZGlmZlByb3BzKGluc3RhbmNlLCByZXN0TmV3LCByZXN0T2xkLCB0cnVlKTtcbiAgICAgICAgaWYgKGRpZmYuY2hhbmdlcy5sZW5ndGgpIHJldHVybiBbZmFsc2UsIGRpZmZdO1xuXG4gICAgICAgIC8vIE90aGVyd2lzZSBkbyBub3QgdG91Y2ggdGhlIGluc3RhbmNlXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH0sXG4gICAgY29tbWl0VXBkYXRlKGluc3RhbmNlLCBbcmVjb25zdHJ1Y3QsIGRpZmZdLCB0eXBlLCBfb2xkUHJvcHMsIG5ld1Byb3BzLCBmaWJlcikge1xuICAgICAgLy8gUmVjb25zdHJ1Y3Qgd2hlbiBhcmdzIG9yIDxwcmltaXRpdmUgb2JqZWN0PXsuLi59IGhhdmUgY2hhbmdlc1xuICAgICAgaWYgKHJlY29uc3RydWN0KSBzd2l0Y2hJbnN0YW5jZShpbnN0YW5jZSwgdHlwZSwgbmV3UHJvcHMsIGZpYmVyKTtcbiAgICAgIC8vIE90aGVyd2lzZSBqdXN0IG92ZXJ3cml0ZSBwcm9wc1xuICAgICAgZWxzZSBhcHBseVByb3BzJDEoaW5zdGFuY2UsIGRpZmYpO1xuICAgIH0sXG4gICAgY29tbWl0TW91bnQoaW5zdGFuY2UsIF90eXBlLCBfcHJvcHMsIF9pbnQpIHtcbiAgICAgIHZhciBfaW5zdGFuY2UkX19yM2Y0O1xuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8yMDI3MVxuICAgICAgLy8gVGhpcyB3aWxsIG1ha2Ugc3VyZSBldmVudHMgYXJlIG9ubHkgYWRkZWQgb25jZSB0byB0aGUgY2VudHJhbCBjb250YWluZXJcbiAgICAgIGNvbnN0IGxvY2FsU3RhdGUgPSAoX2luc3RhbmNlJF9fcjNmNCA9IGluc3RhbmNlLl9fcjNmKSAhPSBudWxsID8gX2luc3RhbmNlJF9fcjNmNCA6IHt9O1xuICAgICAgaWYgKGluc3RhbmNlLnJheWNhc3QgJiYgbG9jYWxTdGF0ZS5oYW5kbGVycyAmJiBsb2NhbFN0YXRlLmV2ZW50Q291bnQpIHtcbiAgICAgICAgaW5zdGFuY2UuX19yM2Yucm9vdC5nZXRTdGF0ZSgpLmludGVybmFsLmludGVyYWN0aW9uLnB1c2goaW5zdGFuY2UpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0UHVibGljSW5zdGFuY2U6IGluc3RhbmNlID0+IGluc3RhbmNlLFxuICAgIHByZXBhcmVGb3JDb21taXQ6ICgpID0+IG51bGwsXG4gICAgcHJlcGFyZVBvcnRhbE1vdW50OiBjb250YWluZXIgPT4gcHJlcGFyZShjb250YWluZXIuZ2V0U3RhdGUoKS5zY2VuZSksXG4gICAgcmVzZXRBZnRlckNvbW1pdDogKCkgPT4ge30sXG4gICAgc2hvdWxkU2V0VGV4dENvbnRlbnQ6ICgpID0+IGZhbHNlLFxuICAgIGNsZWFyQ29udGFpbmVyOiAoKSA9PiBmYWxzZSxcbiAgICBoaWRlSW5zdGFuY2UoaW5zdGFuY2UpIHtcbiAgICAgIHZhciBfaW5zdGFuY2UkX19yM2Y1O1xuICAgICAgLy8gRGV0YWNoIHdoaWxlIHRoZSBpbnN0YW5jZSBpcyBoaWRkZW5cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYXR0YWNoOiB0eXBlLFxuICAgICAgICBwYXJlbnRcbiAgICAgIH0gPSAoX2luc3RhbmNlJF9fcjNmNSA9IGluc3RhbmNlLl9fcjNmKSAhPSBudWxsID8gX2luc3RhbmNlJF9fcjNmNSA6IHt9O1xuICAgICAgaWYgKHR5cGUgJiYgcGFyZW50KSBkZXRhY2gocGFyZW50LCBpbnN0YW5jZSwgdHlwZSk7XG4gICAgICBpZiAoaW5zdGFuY2UuaXNPYmplY3QzRCkgaW5zdGFuY2UudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgaW52YWxpZGF0ZUluc3RhbmNlKGluc3RhbmNlKTtcbiAgICB9LFxuICAgIHVuaGlkZUluc3RhbmNlKGluc3RhbmNlLCBwcm9wcykge1xuICAgICAgdmFyIF9pbnN0YW5jZSRfX3IzZjY7XG4gICAgICAvLyBSZS1hdHRhY2ggd2hlbiB0aGUgaW5zdGFuY2UgaXMgdW5oaWRkZW5cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYXR0YWNoOiB0eXBlLFxuICAgICAgICBwYXJlbnRcbiAgICAgIH0gPSAoX2luc3RhbmNlJF9fcjNmNiA9IGluc3RhbmNlLl9fcjNmKSAhPSBudWxsID8gX2luc3RhbmNlJF9fcjNmNiA6IHt9O1xuICAgICAgaWYgKHR5cGUgJiYgcGFyZW50KSBhdHRhY2gocGFyZW50LCBpbnN0YW5jZSwgdHlwZSk7XG4gICAgICBpZiAoaW5zdGFuY2UuaXNPYmplY3QzRCAmJiBwcm9wcy52aXNpYmxlID09IG51bGwgfHwgcHJvcHMudmlzaWJsZSkgaW5zdGFuY2UudmlzaWJsZSA9IHRydWU7XG4gICAgICBpbnZhbGlkYXRlSW5zdGFuY2UoaW5zdGFuY2UpO1xuICAgIH0sXG4gICAgY3JlYXRlVGV4dEluc3RhbmNlOiBoYW5kbGVUZXh0SW5zdGFuY2UsXG4gICAgaGlkZVRleHRJbnN0YW5jZTogaGFuZGxlVGV4dEluc3RhbmNlLFxuICAgIHVuaGlkZVRleHRJbnN0YW5jZTogaGFuZGxlVGV4dEluc3RhbmNlLFxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvcmVhY3QtdGhyZWUtZmliZXIvcHVsbC8yMzYwI2Rpc2N1c3Npb25fcjkxNjM1Njg3NFxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBnZXRDdXJyZW50RXZlbnRQcmlvcml0eTogKCkgPT4gX2dldEV2ZW50UHJpb3JpdHkgPyBfZ2V0RXZlbnRQcmlvcml0eSgpIDogRGVmYXVsdEV2ZW50UHJpb3JpdHksXG4gICAgYmVmb3JlQWN0aXZlSW5zdGFuY2VCbHVyOiAoKSA9PiB7fSxcbiAgICBhZnRlckFjdGl2ZUluc3RhbmNlQmx1cjogKCkgPT4ge30sXG4gICAgZGV0YWNoRGVsZXRlZEluc3RhbmNlOiAoKSA9PiB7fSxcbiAgICBub3c6IHR5cGVvZiBwZXJmb3JtYW5jZSAhPT0gJ3VuZGVmaW5lZCcgJiYgaXMuZnVuKHBlcmZvcm1hbmNlLm5vdykgPyBwZXJmb3JtYW5jZS5ub3cgOiBpcy5mdW4oRGF0ZS5ub3cpID8gRGF0ZS5ub3cgOiAoKSA9PiAwLFxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvcmVhY3QtdGhyZWUtZmliZXIvcHVsbC8yMzYwI2Rpc2N1c3Npb25fcjkyMDg4MzUwM1xuICAgIHNjaGVkdWxlVGltZW91dDogaXMuZnVuKHNldFRpbWVvdXQpID8gc2V0VGltZW91dCA6IHVuZGVmaW5lZCxcbiAgICBjYW5jZWxUaW1lb3V0OiBpcy5mdW4oY2xlYXJUaW1lb3V0KSA/IGNsZWFyVGltZW91dCA6IHVuZGVmaW5lZFxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICByZWNvbmNpbGVyLFxuICAgIGFwcGx5UHJvcHM6IGFwcGx5UHJvcHMkMVxuICB9O1xufVxuXG52YXIgX3dpbmRvdyRkb2N1bWVudCwgX3dpbmRvdyRuYXZpZ2F0b3I7XG4vKipcbiAqIFJldHVybnMgYHRydWVgIHdpdGggY29ycmVjdCBUUyB0eXBlIGluZmVyZW5jZSBpZiBhbiBvYmplY3QgaGFzIGEgY29uZmlndXJhYmxlIGNvbG9yIHNwYWNlIChzaW5jZSByMTUyKS5cbiAqL1xuY29uc3QgaGFzQ29sb3JTcGFjZSA9IG9iamVjdCA9PiAnY29sb3JTcGFjZScgaW4gb2JqZWN0IHx8ICdvdXRwdXRDb2xvclNwYWNlJyBpbiBvYmplY3Q7XG4vKipcbiAqIFRoZSBjdXJyZW50IFRIUkVFLkNvbG9yTWFuYWdlbWVudCBpbnN0YW5jZSwgaWYgcHJlc2VudC5cbiAqL1xuY29uc3QgZ2V0Q29sb3JNYW5hZ2VtZW50ID0gKCkgPT4ge1xuICB2YXIgX0NvbG9yTWFuYWdlbWVudDtcbiAgcmV0dXJuIChfQ29sb3JNYW5hZ2VtZW50ID0gY2F0YWxvZ3VlLkNvbG9yTWFuYWdlbWVudCkgIT0gbnVsbCA/IF9Db2xvck1hbmFnZW1lbnQgOiBudWxsO1xufTtcbmNvbnN0IGlzT3J0aG9ncmFwaGljQ2FtZXJhID0gZGVmID0+IGRlZiAmJiBkZWYuaXNPcnRob2dyYXBoaWNDYW1lcmE7XG5jb25zdCBpc1JlZiA9IG9iaiA9PiBvYmogJiYgb2JqLmhhc093blByb3BlcnR5KCdjdXJyZW50Jyk7XG5cbi8qKlxuICogQW4gU1NSLWZyaWVuZGx5IHVzZUxheW91dEVmZmVjdC5cbiAqXG4gKiBSZWFjdCBjdXJyZW50bHkgdGhyb3dzIGEgd2FybmluZyB3aGVuIHVzaW5nIHVzZUxheW91dEVmZmVjdCBvbiB0aGUgc2VydmVyLlxuICogVG8gZ2V0IGFyb3VuZCBpdCwgd2UgY2FuIGNvbmRpdGlvbmFsbHkgdXNlRWZmZWN0IG9uIHRoZSBzZXJ2ZXIgKG5vLW9wKSBhbmRcbiAqIHVzZUxheW91dEVmZmVjdCBlbHNld2hlcmUuXG4gKlxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE0OTI3XG4gKi9cbmNvbnN0IHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAoKF93aW5kb3ckZG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQpICE9IG51bGwgJiYgX3dpbmRvdyRkb2N1bWVudC5jcmVhdGVFbGVtZW50IHx8ICgoX3dpbmRvdyRuYXZpZ2F0b3IgPSB3aW5kb3cubmF2aWdhdG9yKSA9PSBudWxsID8gdm9pZCAwIDogX3dpbmRvdyRuYXZpZ2F0b3IucHJvZHVjdCkgPT09ICdSZWFjdE5hdGl2ZScpID8gUmVhY3QudXNlTGF5b3V0RWZmZWN0IDogUmVhY3QudXNlRWZmZWN0O1xuZnVuY3Rpb24gdXNlTXV0YWJsZUNhbGxiYWNrKGZuKSB7XG4gIGNvbnN0IHJlZiA9IFJlYWN0LnVzZVJlZihmbik7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4gdm9pZCAocmVmLmN1cnJlbnQgPSBmbiksIFtmbl0pO1xuICByZXR1cm4gcmVmO1xufVxuZnVuY3Rpb24gQmxvY2soe1xuICBzZXRcbn0pIHtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgc2V0KG5ldyBQcm9taXNlKCgpID0+IG51bGwpKTtcbiAgICByZXR1cm4gKCkgPT4gc2V0KGZhbHNlKTtcbiAgfSwgW3NldF0pO1xuICByZXR1cm4gbnVsbDtcbn1cbmNsYXNzIEVycm9yQm91bmRhcnkgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncyk7XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGVycm9yOiBmYWxzZVxuICAgIH07XG4gIH1cbiAgY29tcG9uZW50RGlkQ2F0Y2goZXJyKSB7XG4gICAgdGhpcy5wcm9wcy5zZXQoZXJyKTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuZXJyb3IgPyBudWxsIDogdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgfVxufVxuRXJyb3JCb3VuZGFyeS5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgPSAoKSA9PiAoe1xuICBlcnJvcjogdHJ1ZVxufSk7XG5jb25zdCBERUZBVUxUID0gJ19fZGVmYXVsdCc7XG5jb25zdCBERUZBVUxUUyA9IG5ldyBNYXAoKTtcbmNvbnN0IGlzRGlmZlNldCA9IGRlZiA9PiBkZWYgJiYgISFkZWYubWVtb2l6ZWQgJiYgISFkZWYuY2hhbmdlcztcbmZ1bmN0aW9uIGNhbGN1bGF0ZURwcihkcHIpIHtcbiAgdmFyIF93aW5kb3ckZGV2aWNlUGl4ZWxSYTtcbiAgLy8gRXJyIG9uIHRoZSBzaWRlIG9mIHByb2dyZXNzIGJ5IGFzc3VtaW5nIDJ4IGRwciBpZiB3ZSBjYW4ndCBkZXRlY3QgaXRcbiAgLy8gVGhpcyB3aWxsIGhhcHBlbiBpbiB3b3JrZXJzIHdoZXJlIHdpbmRvdyBpcyBkZWZpbmVkIGJ1dCBkcHIgaXNuJ3QuXG4gIGNvbnN0IHRhcmdldCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gKF93aW5kb3ckZGV2aWNlUGl4ZWxSYSA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKSAhPSBudWxsID8gX3dpbmRvdyRkZXZpY2VQaXhlbFJhIDogMiA6IDE7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGRwcikgPyBNYXRoLm1pbihNYXRoLm1heChkcHJbMF0sIHRhcmdldCksIGRwclsxXSkgOiBkcHI7XG59XG5cbi8qKlxuICogUmV0dXJucyBpbnN0YW5jZSByb290IHN0YXRlXG4gKi9cbmNvbnN0IGdldFJvb3RTdGF0ZSA9IG9iaiA9PiB7XG4gIHZhciBfcjNmO1xuICByZXR1cm4gKF9yM2YgPSBvYmouX19yM2YpID09IG51bGwgPyB2b2lkIDAgOiBfcjNmLnJvb3QuZ2V0U3RhdGUoKTtcbn07XG4vLyBBIGNvbGxlY3Rpb24gb2YgY29tcGFyZSBmdW5jdGlvbnNcbmNvbnN0IGlzID0ge1xuICBvYmo6IGEgPT4gYSA9PT0gT2JqZWN0KGEpICYmICFpcy5hcnIoYSkgJiYgdHlwZW9mIGEgIT09ICdmdW5jdGlvbicsXG4gIGZ1bjogYSA9PiB0eXBlb2YgYSA9PT0gJ2Z1bmN0aW9uJyxcbiAgc3RyOiBhID0+IHR5cGVvZiBhID09PSAnc3RyaW5nJyxcbiAgbnVtOiBhID0+IHR5cGVvZiBhID09PSAnbnVtYmVyJyxcbiAgYm9vOiBhID0+IHR5cGVvZiBhID09PSAnYm9vbGVhbicsXG4gIHVuZDogYSA9PiBhID09PSB2b2lkIDAsXG4gIGFycjogYSA9PiBBcnJheS5pc0FycmF5KGEpLFxuICBlcXUoYSwgYiwge1xuICAgIGFycmF5cyA9ICdzaGFsbG93JyxcbiAgICBvYmplY3RzID0gJ3JlZmVyZW5jZScsXG4gICAgc3RyaWN0ID0gdHJ1ZVxuICB9ID0ge30pIHtcbiAgICAvLyBXcm9uZyB0eXBlIG9yIG9uZSBvZiB0aGUgdHdvIHVuZGVmaW5lZCwgZG9lc24ndCBtYXRjaFxuICAgIGlmICh0eXBlb2YgYSAhPT0gdHlwZW9mIGIgfHwgISFhICE9PSAhIWIpIHJldHVybiBmYWxzZTtcbiAgICAvLyBBdG9taWMsIGp1c3QgY29tcGFyZSBhIGFnYWluc3QgYlxuICAgIGlmIChpcy5zdHIoYSkgfHwgaXMubnVtKGEpKSByZXR1cm4gYSA9PT0gYjtcbiAgICBjb25zdCBpc09iaiA9IGlzLm9iaihhKTtcbiAgICBpZiAoaXNPYmogJiYgb2JqZWN0cyA9PT0gJ3JlZmVyZW5jZScpIHJldHVybiBhID09PSBiO1xuICAgIGNvbnN0IGlzQXJyID0gaXMuYXJyKGEpO1xuICAgIGlmIChpc0FyciAmJiBhcnJheXMgPT09ICdyZWZlcmVuY2UnKSByZXR1cm4gYSA9PT0gYjtcbiAgICAvLyBBcnJheSBvciBPYmplY3QsIHNoYWxsb3cgY29tcGFyZSBmaXJzdCB0byBzZWUgaWYgaXQncyBhIG1hdGNoXG4gICAgaWYgKChpc0FyciB8fCBpc09iaikgJiYgYSA9PT0gYikgcmV0dXJuIHRydWU7XG4gICAgLy8gTGFzdCByZXNvcnQsIGdvIHRocm91Z2gga2V5c1xuICAgIGxldCBpO1xuICAgIC8vIENoZWNrIGlmIGEgaGFzIGFsbCB0aGUga2V5cyBvZiBiXG4gICAgZm9yIChpIGluIGEpIGlmICghKGkgaW4gYikpIHJldHVybiBmYWxzZTtcbiAgICAvLyBDaGVjayBpZiB2YWx1ZXMgYmV0d2VlbiBrZXlzIG1hdGNoXG4gICAgaWYgKGlzT2JqICYmIGFycmF5cyA9PT0gJ3NoYWxsb3cnICYmIG9iamVjdHMgPT09ICdzaGFsbG93Jykge1xuICAgICAgZm9yIChpIGluIHN0cmljdCA/IGIgOiBhKSBpZiAoIWlzLmVxdShhW2ldLCBiW2ldLCB7XG4gICAgICAgIHN0cmljdCxcbiAgICAgICAgb2JqZWN0czogJ3JlZmVyZW5jZSdcbiAgICAgIH0pKSByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoaSBpbiBzdHJpY3QgPyBiIDogYSkgaWYgKGFbaV0gIT09IGJbaV0pIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gSWYgaSBpcyB1bmRlZmluZWRcbiAgICBpZiAoaXMudW5kKGkpKSB7XG4gICAgICAvLyBJZiBib3RoIGFycmF5cyBhcmUgZW1wdHkgd2UgY29uc2lkZXIgdGhlbSBlcXVhbFxuICAgICAgaWYgKGlzQXJyICYmIGEubGVuZ3RoID09PSAwICYmIGIubGVuZ3RoID09PSAwKSByZXR1cm4gdHJ1ZTtcbiAgICAgIC8vIElmIGJvdGggb2JqZWN0cyBhcmUgZW1wdHkgd2UgY29uc2lkZXIgdGhlbSBlcXVhbFxuICAgICAgaWYgKGlzT2JqICYmIE9iamVjdC5rZXlzKGEpLmxlbmd0aCA9PT0gMCAmJiBPYmplY3Qua2V5cyhiKS5sZW5ndGggPT09IDApIHJldHVybiB0cnVlO1xuICAgICAgLy8gT3RoZXJ3aXNlIG1hdGNoIHRoZW0gYnkgdmFsdWVcbiAgICAgIGlmIChhICE9PSBiKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG4vLyBDb2xsZWN0cyBub2RlcyBhbmQgbWF0ZXJpYWxzIGZyb20gYSBUSFJFRS5PYmplY3QzRFxuZnVuY3Rpb24gYnVpbGRHcmFwaChvYmplY3QpIHtcbiAgY29uc3QgZGF0YSA9IHtcbiAgICBub2Rlczoge30sXG4gICAgbWF0ZXJpYWxzOiB7fVxuICB9O1xuICBpZiAob2JqZWN0KSB7XG4gICAgb2JqZWN0LnRyYXZlcnNlKG9iaiA9PiB7XG4gICAgICBpZiAob2JqLm5hbWUpIGRhdGEubm9kZXNbb2JqLm5hbWVdID0gb2JqO1xuICAgICAgaWYgKG9iai5tYXRlcmlhbCAmJiAhZGF0YS5tYXRlcmlhbHNbb2JqLm1hdGVyaWFsLm5hbWVdKSBkYXRhLm1hdGVyaWFsc1tvYmoubWF0ZXJpYWwubmFtZV0gPSBvYmoubWF0ZXJpYWw7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8vIERpc3Bvc2VzIGFuIG9iamVjdCBhbmQgYWxsIGl0cyBwcm9wZXJ0aWVzXG5mdW5jdGlvbiBkaXNwb3NlKG9iaikge1xuICBpZiAob2JqLmRpc3Bvc2UgJiYgb2JqLnR5cGUgIT09ICdTY2VuZScpIG9iai5kaXNwb3NlKCk7XG4gIGZvciAoY29uc3QgcCBpbiBvYmopIHtcbiAgICBwLmRpc3Bvc2UgPT0gbnVsbCA/IHZvaWQgMCA6IHAuZGlzcG9zZSgpO1xuICAgIGRlbGV0ZSBvYmpbcF07XG4gIH1cbn1cblxuLy8gRWFjaCBvYmplY3QgaW4gdGhlIHNjZW5lIGNhcnJpZXMgYSBzbWFsbCBMb2NhbFN0YXRlIGRlc2NyaXB0b3JcbmZ1bmN0aW9uIHByZXBhcmUob2JqZWN0LCBzdGF0ZSkge1xuICBjb25zdCBpbnN0YW5jZSA9IG9iamVjdDtcbiAgaW5zdGFuY2UuX19yM2YgPSB7XG4gICAgdHlwZTogJycsXG4gICAgcm9vdDogbnVsbCxcbiAgICBwcmV2aW91c0F0dGFjaDogbnVsbCxcbiAgICBtZW1vaXplZFByb3BzOiB7fSxcbiAgICBldmVudENvdW50OiAwLFxuICAgIGhhbmRsZXJzOiB7fSxcbiAgICBvYmplY3RzOiBbXSxcbiAgICBwYXJlbnQ6IG51bGwsXG4gICAgLi4uc3RhdGVcbiAgfTtcbiAgcmV0dXJuIG9iamVjdDtcbn1cbmZ1bmN0aW9uIHJlc29sdmUoaW5zdGFuY2UsIGtleSkge1xuICBsZXQgdGFyZ2V0ID0gaW5zdGFuY2U7XG4gIGlmIChrZXkuaW5jbHVkZXMoJy0nKSkge1xuICAgIGNvbnN0IGVudHJpZXMgPSBrZXkuc3BsaXQoJy0nKTtcbiAgICBjb25zdCBsYXN0ID0gZW50cmllcy5wb3AoKTtcbiAgICB0YXJnZXQgPSBlbnRyaWVzLnJlZHVjZSgoYWNjLCBrZXkpID0+IGFjY1trZXldLCBpbnN0YW5jZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRhcmdldCxcbiAgICAgIGtleTogbGFzdFxuICAgIH07XG4gIH0gZWxzZSByZXR1cm4ge1xuICAgIHRhcmdldCxcbiAgICBrZXlcbiAgfTtcbn1cblxuLy8gQ2hlY2tzIGlmIGEgZGFzaC1jYXNlZCBzdHJpbmcgZW5kcyB3aXRoIGFuIGludGVnZXJcbmNvbnN0IElOREVYX1JFR0VYID0gLy1cXGQrJC87XG5mdW5jdGlvbiBhdHRhY2gocGFyZW50LCBjaGlsZCwgdHlwZSkge1xuICBpZiAoaXMuc3RyKHR5cGUpKSB7XG4gICAgLy8gSWYgYXR0YWNoaW5nIGludG8gYW4gYXJyYXkgKGZvby0wKSwgY3JlYXRlIG9uZVxuICAgIGlmIChJTkRFWF9SRUdFWC50ZXN0KHR5cGUpKSB7XG4gICAgICBjb25zdCByb290ID0gdHlwZS5yZXBsYWNlKElOREVYX1JFR0VYLCAnJyk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHRhcmdldCxcbiAgICAgICAga2V5XG4gICAgICB9ID0gcmVzb2x2ZShwYXJlbnQsIHJvb3QpO1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHRhcmdldFtrZXldKSkgdGFyZ2V0W2tleV0gPSBbXTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgdGFyZ2V0LFxuICAgICAga2V5XG4gICAgfSA9IHJlc29sdmUocGFyZW50LCB0eXBlKTtcbiAgICBjaGlsZC5fX3IzZi5wcmV2aW91c0F0dGFjaCA9IHRhcmdldFtrZXldO1xuICAgIHRhcmdldFtrZXldID0gY2hpbGQ7XG4gIH0gZWxzZSBjaGlsZC5fX3IzZi5wcmV2aW91c0F0dGFjaCA9IHR5cGUocGFyZW50LCBjaGlsZCk7XG59XG5mdW5jdGlvbiBkZXRhY2gocGFyZW50LCBjaGlsZCwgdHlwZSkge1xuICB2YXIgX2NoaWxkJF9fcjNmLCBfY2hpbGQkX19yM2YyO1xuICBpZiAoaXMuc3RyKHR5cGUpKSB7XG4gICAgY29uc3Qge1xuICAgICAgdGFyZ2V0LFxuICAgICAga2V5XG4gICAgfSA9IHJlc29sdmUocGFyZW50LCB0eXBlKTtcbiAgICBjb25zdCBwcmV2aW91cyA9IGNoaWxkLl9fcjNmLnByZXZpb3VzQXR0YWNoO1xuICAgIC8vIFdoZW4gdGhlIHByZXZpb3VzIHZhbHVlIHdhcyB1bmRlZmluZWQsIGl0IG1lYW5zIHRoZSB2YWx1ZSB3YXMgbmV2ZXIgc2V0IHRvIGJlZ2luIHdpdGhcbiAgICBpZiAocHJldmlvdXMgPT09IHVuZGVmaW5lZCkgZGVsZXRlIHRhcmdldFtrZXldO1xuICAgIC8vIE90aGVyd2lzZSBzZXQgdGhlIHByZXZpb3VzIHZhbHVlXG4gICAgZWxzZSB0YXJnZXRba2V5XSA9IHByZXZpb3VzO1xuICB9IGVsc2UgKF9jaGlsZCRfX3IzZiA9IGNoaWxkLl9fcjNmKSA9PSBudWxsID8gdm9pZCAwIDogX2NoaWxkJF9fcjNmLnByZXZpb3VzQXR0YWNoID09IG51bGwgPyB2b2lkIDAgOiBfY2hpbGQkX19yM2YucHJldmlvdXNBdHRhY2gocGFyZW50LCBjaGlsZCk7XG4gIChfY2hpbGQkX19yM2YyID0gY2hpbGQuX19yM2YpID09IG51bGwgPyB0cnVlIDogZGVsZXRlIF9jaGlsZCRfX3IzZjIucHJldmlvdXNBdHRhY2g7XG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gcHJlcGFyZXMgYSBzZXQgb2YgY2hhbmdlcyB0byBiZSBhcHBsaWVkIHRvIHRoZSBpbnN0YW5jZVxuZnVuY3Rpb24gZGlmZlByb3BzKGluc3RhbmNlLCB7XG4gIGNoaWxkcmVuOiBjTixcbiAga2V5OiBrTixcbiAgcmVmOiByTixcbiAgLi4ucHJvcHNcbn0sIHtcbiAgY2hpbGRyZW46IGNQLFxuICBrZXk6IGtQLFxuICByZWY6IHJQLFxuICAuLi5wcmV2aW91c1xufSA9IHt9LCByZW1vdmUgPSBmYWxzZSkge1xuICB2YXIgX2luc3RhbmNlJF9fcjNmO1xuICBjb25zdCBsb2NhbFN0YXRlID0gKF9pbnN0YW5jZSRfX3IzZiA9IGluc3RhbmNlID09IG51bGwgPyB2b2lkIDAgOiBpbnN0YW5jZS5fX3IzZikgIT0gbnVsbCA/IF9pbnN0YW5jZSRfX3IzZiA6IHt9O1xuICBjb25zdCBlbnRyaWVzID0gT2JqZWN0LmVudHJpZXMocHJvcHMpO1xuICBjb25zdCBjaGFuZ2VzID0gW107XG5cbiAgLy8gQ2F0Y2ggcmVtb3ZlZCBwcm9wcywgcHJlcGVuZCB0aGVtIHNvIHRoZXkgY2FuIGJlIHJlc2V0IG9yIHJlbW92ZWRcbiAgaWYgKHJlbW92ZSkge1xuICAgIGNvbnN0IHByZXZpb3VzS2V5cyA9IE9iamVjdC5rZXlzKHByZXZpb3VzKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByZXZpb3VzS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFwcm9wcy5oYXNPd25Qcm9wZXJ0eShwcmV2aW91c0tleXNbaV0pKSBlbnRyaWVzLnVuc2hpZnQoW3ByZXZpb3VzS2V5c1tpXSwgREVGQVVMVCArICdyZW1vdmUnXSk7XG4gICAgfVxuICB9XG4gIGVudHJpZXMuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgdmFyIF9pbnN0YW5jZSRfX3IzZjI7XG4gICAgLy8gQmFpbCBvdXQgb24gcHJpbWl0aXZlIG9iamVjdFxuICAgIGlmICgoX2luc3RhbmNlJF9fcjNmMiA9IGluc3RhbmNlLl9fcjNmKSAhPSBudWxsICYmIF9pbnN0YW5jZSRfX3IzZjIucHJpbWl0aXZlICYmIGtleSA9PT0gJ29iamVjdCcpIHJldHVybjtcbiAgICAvLyBXaGVuIHByb3BzIG1hdGNoIGJhaWwgb3V0XG4gICAgaWYgKGlzLmVxdSh2YWx1ZSwgcHJldmlvdXNba2V5XSkpIHJldHVybjtcbiAgICAvLyBDb2xsZWN0IGhhbmRsZXJzIGFuZCBiYWlsIG91dFxuICAgIGlmICgvXm9uKFBvaW50ZXJ8Q2xpY2t8RG91YmxlQ2xpY2t8Q29udGV4dE1lbnV8V2hlZWwpLy50ZXN0KGtleSkpIHJldHVybiBjaGFuZ2VzLnB1c2goW2tleSwgdmFsdWUsIHRydWUsIFtdXSk7XG4gICAgLy8gU3BsaXQgZGFzaGVkIHByb3BzXG4gICAgbGV0IGVudHJpZXMgPSBbXTtcbiAgICBpZiAoa2V5LmluY2x1ZGVzKCctJykpIGVudHJpZXMgPSBrZXkuc3BsaXQoJy0nKTtcbiAgICBjaGFuZ2VzLnB1c2goW2tleSwgdmFsdWUsIGZhbHNlLCBlbnRyaWVzXSk7XG5cbiAgICAvLyBSZXNldCBwaWVyY2VkIHByb3BzXG4gICAgZm9yIChjb25zdCBwcm9wIGluIHByb3BzKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHByb3BzW3Byb3BdO1xuICAgICAgaWYgKHByb3Auc3RhcnRzV2l0aChgJHtrZXl9LWApKSBjaGFuZ2VzLnB1c2goW3Byb3AsIHZhbHVlLCBmYWxzZSwgcHJvcC5zcGxpdCgnLScpXSk7XG4gICAgfVxuICB9KTtcbiAgY29uc3QgbWVtb2l6ZWQgPSB7XG4gICAgLi4ucHJvcHNcbiAgfTtcbiAgaWYgKGxvY2FsU3RhdGUubWVtb2l6ZWRQcm9wcyAmJiBsb2NhbFN0YXRlLm1lbW9pemVkUHJvcHMuYXJncykgbWVtb2l6ZWQuYXJncyA9IGxvY2FsU3RhdGUubWVtb2l6ZWRQcm9wcy5hcmdzO1xuICBpZiAobG9jYWxTdGF0ZS5tZW1vaXplZFByb3BzICYmIGxvY2FsU3RhdGUubWVtb2l6ZWRQcm9wcy5hdHRhY2gpIG1lbW9pemVkLmF0dGFjaCA9IGxvY2FsU3RhdGUubWVtb2l6ZWRQcm9wcy5hdHRhY2g7XG4gIHJldHVybiB7XG4gICAgbWVtb2l6ZWQsXG4gICAgY2hhbmdlc1xuICB9O1xufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGFwcGxpZXMgYSBzZXQgb2YgY2hhbmdlcyB0byB0aGUgaW5zdGFuY2VcbmZ1bmN0aW9uIGFwcGx5UHJvcHMkMShpbnN0YW5jZSwgZGF0YSkge1xuICB2YXIgX2luc3RhbmNlJF9fcjNmMywgX3Jvb3QkZ2V0U3RhdGUsIF9pbnN0YW5jZSRfX3IzZjQ7XG4gIC8vIEZpbHRlciBlcXVhbHMsIGV2ZW50cyBhbmQgcmVzZXJ2ZWQgcHJvcHNcbiAgY29uc3QgbG9jYWxTdGF0ZSA9IChfaW5zdGFuY2UkX19yM2YzID0gaW5zdGFuY2UuX19yM2YpICE9IG51bGwgPyBfaW5zdGFuY2UkX19yM2YzIDoge307XG4gIGNvbnN0IHJvb3QgPSBsb2NhbFN0YXRlLnJvb3Q7XG4gIGNvbnN0IHJvb3RTdGF0ZSA9IChfcm9vdCRnZXRTdGF0ZSA9IHJvb3QgPT0gbnVsbCA/IHZvaWQgMCA6IHJvb3QuZ2V0U3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IHJvb3QuZ2V0U3RhdGUoKSkgIT0gbnVsbCA/IF9yb290JGdldFN0YXRlIDoge307XG4gIGNvbnN0IHtcbiAgICBtZW1vaXplZCxcbiAgICBjaGFuZ2VzXG4gIH0gPSBpc0RpZmZTZXQoZGF0YSkgPyBkYXRhIDogZGlmZlByb3BzKGluc3RhbmNlLCBkYXRhKTtcbiAgY29uc3QgcHJldkhhbmRsZXJzID0gbG9jYWxTdGF0ZS5ldmVudENvdW50O1xuXG4gIC8vIFByZXBhcmUgbWVtb2l6ZWQgcHJvcHNcbiAgaWYgKGluc3RhbmNlLl9fcjNmKSBpbnN0YW5jZS5fX3IzZi5tZW1vaXplZFByb3BzID0gbWVtb2l6ZWQ7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2hhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgIGxldCBba2V5LCB2YWx1ZSwgaXNFdmVudCwga2V5c10gPSBjaGFuZ2VzW2ldO1xuXG4gICAgLy8gQWxpYXMgKG91dHB1dCllbmNvZGluZyA9PiAob3V0cHV0KWNvbG9yU3BhY2UgKHNpbmNlIHIxNTIpXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC10aHJlZS1maWJlci9wdWxsLzI4MjlcbiAgICBpZiAoaGFzQ29sb3JTcGFjZShpbnN0YW5jZSkpIHtcbiAgICAgIGNvbnN0IHNSR0JFbmNvZGluZyA9IDMwMDE7XG4gICAgICBjb25zdCBTUkdCQ29sb3JTcGFjZSA9ICdzcmdiJztcbiAgICAgIGNvbnN0IExpbmVhclNSR0JDb2xvclNwYWNlID0gJ3NyZ2ItbGluZWFyJztcbiAgICAgIGlmIChrZXkgPT09ICdlbmNvZGluZycpIHtcbiAgICAgICAga2V5ID0gJ2NvbG9yU3BhY2UnO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlID09PSBzUkdCRW5jb2RpbmcgPyBTUkdCQ29sb3JTcGFjZSA6IExpbmVhclNSR0JDb2xvclNwYWNlO1xuICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdvdXRwdXRFbmNvZGluZycpIHtcbiAgICAgICAga2V5ID0gJ291dHB1dENvbG9yU3BhY2UnO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlID09PSBzUkdCRW5jb2RpbmcgPyBTUkdCQ29sb3JTcGFjZSA6IExpbmVhclNSR0JDb2xvclNwYWNlO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgY3VycmVudEluc3RhbmNlID0gaW5zdGFuY2U7XG4gICAgbGV0IHRhcmdldFByb3AgPSBjdXJyZW50SW5zdGFuY2Vba2V5XTtcblxuICAgIC8vIFJldm9sdmUgZGFzaGVkIHByb3BzXG4gICAgaWYgKGtleXMubGVuZ3RoKSB7XG4gICAgICB0YXJnZXRQcm9wID0ga2V5cy5yZWR1Y2UoKGFjYywga2V5KSA9PiBhY2Nba2V5XSwgaW5zdGFuY2UpO1xuICAgICAgLy8gSWYgdGhlIHRhcmdldCBpcyBhdG9taWMsIGl0IGZvcmNlcyB1cyB0byBzd2l0Y2ggdGhlIHJvb3RcbiAgICAgIGlmICghKHRhcmdldFByb3AgJiYgdGFyZ2V0UHJvcC5zZXQpKSB7XG4gICAgICAgIGNvbnN0IFtuYW1lLCAuLi5yZXZlcnNlRW50cmllc10gPSBrZXlzLnJldmVyc2UoKTtcbiAgICAgICAgY3VycmVudEluc3RhbmNlID0gcmV2ZXJzZUVudHJpZXMucmV2ZXJzZSgpLnJlZHVjZSgoYWNjLCBrZXkpID0+IGFjY1trZXldLCBpbnN0YW5jZSk7XG4gICAgICAgIGtleSA9IG5hbWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9pc3N1ZXMvMjEyMDlcbiAgICAvLyBITVIvZmFzdC1yZWZyZXNoIHJlbGllcyBvbiB0aGUgYWJpbGl0eSB0byBjYW5jZWwgb3V0IHByb3BzLCBidXQgdGhyZWVqc1xuICAgIC8vIGhhcyBubyBtZWFucyB0byBkbyB0aGlzLiBIZW5jZSB3ZSBjdXJhdGUgYSBzbWFsbCBjb2xsZWN0aW9uIG9mIHZhbHVlLWNsYXNzZXNcbiAgICAvLyB3aXRoIHRoZWlyIHJlc3BlY3RpdmUgY29uc3RydWN0b3Ivc2V0IGFyZ3VtZW50c1xuICAgIC8vIEZvciByZW1vdmVkIHByb3BzLCB0cnkgdG8gc2V0IGRlZmF1bHQgdmFsdWVzLCBpZiBwb3NzaWJsZVxuICAgIGlmICh2YWx1ZSA9PT0gREVGQVVMVCArICdyZW1vdmUnKSB7XG4gICAgICBpZiAoY3VycmVudEluc3RhbmNlLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgIC8vIGNyZWF0ZSBhIGJsYW5rIHNsYXRlIG9mIHRoZSBpbnN0YW5jZSBhbmQgY29weSB0aGUgcGFydGljdWxhciBwYXJhbWV0ZXIuXG4gICAgICAgIGxldCBjdG9yID0gREVGQVVMVFMuZ2V0KGN1cnJlbnRJbnN0YW5jZS5jb25zdHJ1Y3Rvcik7XG4gICAgICAgIGlmICghY3Rvcikge1xuICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICBjdG9yID0gbmV3IGN1cnJlbnRJbnN0YW5jZS5jb25zdHJ1Y3RvcigpO1xuICAgICAgICAgIERFRkFVTFRTLnNldChjdXJyZW50SW5zdGFuY2UuY29uc3RydWN0b3IsIGN0b3IpO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlID0gY3RvcltrZXldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaW5zdGFuY2UgZG9lcyBub3QgaGF2ZSBjb25zdHJ1Y3RvciwganVzdCBzZXQgaXQgdG8gMFxuICAgICAgICB2YWx1ZSA9IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRGVhbCB3aXRoIHBvaW50ZXIgZXZlbnRzIC4uLlxuICAgIGlmIChpc0V2ZW50KSB7XG4gICAgICBpZiAodmFsdWUpIGxvY2FsU3RhdGUuaGFuZGxlcnNba2V5XSA9IHZhbHVlO2Vsc2UgZGVsZXRlIGxvY2FsU3RhdGUuaGFuZGxlcnNba2V5XTtcbiAgICAgIGxvY2FsU3RhdGUuZXZlbnRDb3VudCA9IE9iamVjdC5rZXlzKGxvY2FsU3RhdGUuaGFuZGxlcnMpLmxlbmd0aDtcbiAgICB9XG4gICAgLy8gU3BlY2lhbCB0cmVhdG1lbnQgZm9yIG9iamVjdHMgd2l0aCBzdXBwb3J0IGZvciBzZXQvY29weSwgYW5kIGxheWVyc1xuICAgIGVsc2UgaWYgKHRhcmdldFByb3AgJiYgdGFyZ2V0UHJvcC5zZXQgJiYgKHRhcmdldFByb3AuY29weSB8fCB0YXJnZXRQcm9wIGluc3RhbmNlb2YgVEhSRUUuTGF5ZXJzKSkge1xuICAgICAgLy8gSWYgdmFsdWUgaXMgYW4gYXJyYXlcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBpZiAodGFyZ2V0UHJvcC5mcm9tQXJyYXkpIHRhcmdldFByb3AuZnJvbUFycmF5KHZhbHVlKTtlbHNlIHRhcmdldFByb3Auc2V0KC4uLnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIC8vIFRlc3QgYWdhaW4gdGFyZ2V0LmNvcHkoY2xhc3MpIG5leHQgLi4uXG4gICAgICBlbHNlIGlmICh0YXJnZXRQcm9wLmNvcHkgJiYgdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IgJiYgdGFyZ2V0UHJvcC5jb25zdHJ1Y3RvciA9PT0gdmFsdWUuY29uc3RydWN0b3IpIHtcbiAgICAgICAgdGFyZ2V0UHJvcC5jb3B5KHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIC8vIElmIG5vdGhpbmcgZWxzZSBmaXRzLCBqdXN0IHNldCB0aGUgc2luZ2xlIHZhbHVlLCBpZ25vcmUgdW5kZWZpbmVkXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXRocmVlLWZpYmVyL2lzc3Vlcy8yNzRcbiAgICAgIGVsc2UgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgaXNDb2xvciA9IHRhcmdldFByb3AgaW5zdGFuY2VvZiBUSFJFRS5Db2xvcjtcbiAgICAgICAgLy8gQWxsb3cgc2V0dGluZyBhcnJheSBzY2FsYXJzXG4gICAgICAgIGlmICghaXNDb2xvciAmJiB0YXJnZXRQcm9wLnNldFNjYWxhcikgdGFyZ2V0UHJvcC5zZXRTY2FsYXIodmFsdWUpO1xuICAgICAgICAvLyBMYXllcnMgaGF2ZSBubyBjb3B5IGZ1bmN0aW9uLCB3ZSBtdXN0IHRoZXJlZm9yZSBjb3B5IHRoZSBtYXNrIHByb3BlcnR5XG4gICAgICAgIGVsc2UgaWYgKHRhcmdldFByb3AgaW5zdGFuY2VvZiBUSFJFRS5MYXllcnMgJiYgdmFsdWUgaW5zdGFuY2VvZiBUSFJFRS5MYXllcnMpIHRhcmdldFByb3AubWFzayA9IHZhbHVlLm1hc2s7XG4gICAgICAgIC8vIE90aGVyd2lzZSBqdXN0IHNldCAuLi5cbiAgICAgICAgZWxzZSB0YXJnZXRQcm9wLnNldCh2YWx1ZSk7XG4gICAgICAgIC8vIEZvciB2ZXJzaW9ucyBvZiB0aHJlZSB3aGljaCBkb24ndCBzdXBwb3J0IFRIUkVFLkNvbG9yTWFuYWdlbWVudCxcbiAgICAgICAgLy8gQXV0by1jb252ZXJ0IHNSR0IgY29sb3JzXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvcmVhY3QtdGhyZWUtZmliZXIvaXNzdWVzLzM0NFxuICAgICAgICBpZiAoIWdldENvbG9yTWFuYWdlbWVudCgpICYmICFyb290U3RhdGUubGluZWFyICYmIGlzQ29sb3IpIHRhcmdldFByb3AuY29udmVydFNSR0JUb0xpbmVhcigpO1xuICAgICAgfVxuICAgICAgLy8gRWxzZSwganVzdCBvdmVyd3JpdGUgdGhlIHZhbHVlXG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnRJbnN0YW5jZVtrZXldID0gdmFsdWU7XG5cbiAgICAgIC8vIEF1dG8tY29udmVydCBzUkdCIHRleHR1cmVzLCBmb3Igbm93IC4uLlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC10aHJlZS1maWJlci9pc3N1ZXMvMzQ0XG4gICAgICBpZiAoY3VycmVudEluc3RhbmNlW2tleV0gaW5zdGFuY2VvZiBUSFJFRS5UZXh0dXJlICYmXG4gICAgICAvLyBzUkdCIHRleHR1cmVzIG11c3QgYmUgUkdCQTggc2luY2UgcjEzNyBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL3RocmVlLmpzL3B1bGwvMjMxMjlcbiAgICAgIGN1cnJlbnRJbnN0YW5jZVtrZXldLmZvcm1hdCA9PT0gVEhSRUUuUkdCQUZvcm1hdCAmJiBjdXJyZW50SW5zdGFuY2Vba2V5XS50eXBlID09PSBUSFJFRS5VbnNpZ25lZEJ5dGVUeXBlKSB7XG4gICAgICAgIGNvbnN0IHRleHR1cmUgPSBjdXJyZW50SW5zdGFuY2Vba2V5XTtcbiAgICAgICAgaWYgKGhhc0NvbG9yU3BhY2UodGV4dHVyZSkgJiYgaGFzQ29sb3JTcGFjZShyb290U3RhdGUuZ2wpKSB0ZXh0dXJlLmNvbG9yU3BhY2UgPSByb290U3RhdGUuZ2wub3V0cHV0Q29sb3JTcGFjZTtlbHNlIHRleHR1cmUuZW5jb2RpbmcgPSByb290U3RhdGUuZ2wub3V0cHV0RW5jb2Rpbmc7XG4gICAgICB9XG4gICAgfVxuICAgIGludmFsaWRhdGVJbnN0YW5jZShpbnN0YW5jZSk7XG4gIH1cbiAgaWYgKGxvY2FsU3RhdGUucGFyZW50ICYmIHJvb3RTdGF0ZS5pbnRlcm5hbCAmJiBpbnN0YW5jZS5yYXljYXN0ICYmIHByZXZIYW5kbGVycyAhPT0gbG9jYWxTdGF0ZS5ldmVudENvdW50KSB7XG4gICAgLy8gUHJlLWVtcHRpdmVseSByZW1vdmUgdGhlIGluc3RhbmNlIGZyb20gdGhlIGludGVyYWN0aW9uIG1hbmFnZXJcbiAgICBjb25zdCBpbmRleCA9IHJvb3RTdGF0ZS5pbnRlcm5hbC5pbnRlcmFjdGlvbi5pbmRleE9mKGluc3RhbmNlKTtcbiAgICBpZiAoaW5kZXggPiAtMSkgcm9vdFN0YXRlLmludGVybmFsLmludGVyYWN0aW9uLnNwbGljZShpbmRleCwgMSk7XG4gICAgLy8gQWRkIHRoZSBpbnN0YW5jZSB0byB0aGUgaW50ZXJhY3Rpb24gbWFuYWdlciBvbmx5IHdoZW4gaXQgaGFzIGhhbmRsZXJzXG4gICAgaWYgKGxvY2FsU3RhdGUuZXZlbnRDb3VudCkgcm9vdFN0YXRlLmludGVybmFsLmludGVyYWN0aW9uLnB1c2goaW5zdGFuY2UpO1xuICB9XG5cbiAgLy8gQ2FsbCB0aGUgdXBkYXRlIGxpZmVjeWNsZSB3aGVuIGl0IGlzIGJlaW5nIHVwZGF0ZWQsIGJ1dCBvbmx5IHdoZW4gaXQgaXMgcGFydCBvZiB0aGUgc2NlbmUuXG4gIC8vIFNraXAgdXBkYXRlcyB0byB0aGUgYG9uVXBkYXRlYCBwcm9wIGl0c2VsZlxuICBjb25zdCBpc0NpcmN1bGFyID0gY2hhbmdlcy5sZW5ndGggPT09IDEgJiYgY2hhbmdlc1swXVswXSA9PT0gJ29uVXBkYXRlJztcbiAgaWYgKCFpc0NpcmN1bGFyICYmIGNoYW5nZXMubGVuZ3RoICYmIChfaW5zdGFuY2UkX19yM2Y0ID0gaW5zdGFuY2UuX19yM2YpICE9IG51bGwgJiYgX2luc3RhbmNlJF9fcjNmNC5wYXJlbnQpIHVwZGF0ZUluc3RhbmNlKGluc3RhbmNlKTtcbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuZnVuY3Rpb24gaW52YWxpZGF0ZUluc3RhbmNlKGluc3RhbmNlKSB7XG4gIHZhciBfaW5zdGFuY2UkX19yM2Y1LCBfaW5zdGFuY2UkX19yM2Y1JHJvb3Q7XG4gIGNvbnN0IHN0YXRlID0gKF9pbnN0YW5jZSRfX3IzZjUgPSBpbnN0YW5jZS5fX3IzZikgPT0gbnVsbCA/IHZvaWQgMCA6IChfaW5zdGFuY2UkX19yM2Y1JHJvb3QgPSBfaW5zdGFuY2UkX19yM2Y1LnJvb3QpID09IG51bGwgPyB2b2lkIDAgOiBfaW5zdGFuY2UkX19yM2Y1JHJvb3QuZ2V0U3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IF9pbnN0YW5jZSRfX3IzZjUkcm9vdC5nZXRTdGF0ZSgpO1xuICBpZiAoc3RhdGUgJiYgc3RhdGUuaW50ZXJuYWwuZnJhbWVzID09PSAwKSBzdGF0ZS5pbnZhbGlkYXRlKCk7XG59XG5mdW5jdGlvbiB1cGRhdGVJbnN0YW5jZShpbnN0YW5jZSkge1xuICBpbnN0YW5jZS5vblVwZGF0ZSA9PSBudWxsID8gdm9pZCAwIDogaW5zdGFuY2Uub25VcGRhdGUoaW5zdGFuY2UpO1xufVxuZnVuY3Rpb24gdXBkYXRlQ2FtZXJhKGNhbWVyYSwgc2l6ZSkge1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXRocmVlLWZpYmVyL2lzc3Vlcy85MlxuICAvLyBEbyBub3QgbWVzcyB3aXRoIHRoZSBjYW1lcmEgaWYgaXQgYmVsb25ncyB0byB0aGUgdXNlclxuICBpZiAoIWNhbWVyYS5tYW51YWwpIHtcbiAgICBpZiAoaXNPcnRob2dyYXBoaWNDYW1lcmEoY2FtZXJhKSkge1xuICAgICAgY2FtZXJhLmxlZnQgPSBzaXplLndpZHRoIC8gLTI7XG4gICAgICBjYW1lcmEucmlnaHQgPSBzaXplLndpZHRoIC8gMjtcbiAgICAgIGNhbWVyYS50b3AgPSBzaXplLmhlaWdodCAvIDI7XG4gICAgICBjYW1lcmEuYm90dG9tID0gc2l6ZS5oZWlnaHQgLyAtMjtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FtZXJhLmFzcGVjdCA9IHNpemUud2lkdGggLyBzaXplLmhlaWdodDtcbiAgICB9XG4gICAgY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXRocmVlLWZpYmVyL2lzc3Vlcy8xNzhcbiAgICAvLyBVcGRhdGUgbWF0cml4IHdvcmxkIHNpbmNlIHRoZSByZW5kZXJlciBpcyBhIGZyYW1lIGxhdGVcbiAgICBjYW1lcmEudXBkYXRlTWF0cml4V29ybGQoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYWtlSWQoZXZlbnQpIHtcbiAgcmV0dXJuIChldmVudC5ldmVudE9iamVjdCB8fCBldmVudC5vYmplY3QpLnV1aWQgKyAnLycgKyBldmVudC5pbmRleCArIGV2ZW50Lmluc3RhbmNlSWQ7XG59XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC90cmVlL21haW4vcGFja2FnZXMvcmVhY3QtcmVjb25jaWxlciNnZXRjdXJyZW50ZXZlbnRwcmlvcml0eVxuLy8gR2l2ZXMgUmVhY3QgYSBjbHVlIGFzIHRvIGhvdyBpbXBvcnQgdGhlIGN1cnJlbnQgaW50ZXJhY3Rpb24gaXNcbmZ1bmN0aW9uIGdldEV2ZW50UHJpb3JpdHkoKSB7XG4gIHZhciBfZ2xvYmFsU2NvcGUkZXZlbnQ7XG4gIC8vIEdldCBhIGhhbmRsZSB0byB0aGUgY3VycmVudCBnbG9iYWwgc2NvcGUgaW4gd2luZG93IGFuZCB3b3JrZXIgY29udGV4dHMgaWYgYWJsZVxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXRocmVlLWZpYmVyL3B1bGwvMjQ5M1xuICBjb25zdCBnbG9iYWxTY29wZSA9IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmIHx8IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdztcbiAgaWYgKCFnbG9iYWxTY29wZSkgcmV0dXJuIERlZmF1bHRFdmVudFByaW9yaXR5O1xuICBjb25zdCBuYW1lID0gKF9nbG9iYWxTY29wZSRldmVudCA9IGdsb2JhbFNjb3BlLmV2ZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2dsb2JhbFNjb3BlJGV2ZW50LnR5cGU7XG4gIHN3aXRjaCAobmFtZSkge1xuICAgIGNhc2UgJ2NsaWNrJzpcbiAgICBjYXNlICdjb250ZXh0bWVudSc6XG4gICAgY2FzZSAnZGJsY2xpY2snOlxuICAgIGNhc2UgJ3BvaW50ZXJjYW5jZWwnOlxuICAgIGNhc2UgJ3BvaW50ZXJkb3duJzpcbiAgICBjYXNlICdwb2ludGVydXAnOlxuICAgICAgcmV0dXJuIERpc2NyZXRlRXZlbnRQcmlvcml0eTtcbiAgICBjYXNlICdwb2ludGVybW92ZSc6XG4gICAgY2FzZSAncG9pbnRlcm91dCc6XG4gICAgY2FzZSAncG9pbnRlcm92ZXInOlxuICAgIGNhc2UgJ3BvaW50ZXJlbnRlcic6XG4gICAgY2FzZSAncG9pbnRlcmxlYXZlJzpcbiAgICBjYXNlICd3aGVlbCc6XG4gICAgICByZXR1cm4gQ29udGludW91c0V2ZW50UHJpb3JpdHk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBEZWZhdWx0RXZlbnRQcmlvcml0eTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbGVhc2UgcG9pbnRlciBjYXB0dXJlcy5cbiAqIFRoaXMgaXMgY2FsbGVkIGJ5IHJlbGVhc2VQb2ludGVyQ2FwdHVyZSBpbiB0aGUgQVBJLCBhbmQgd2hlbiBhbiBvYmplY3QgaXMgcmVtb3ZlZC5cbiAqL1xuZnVuY3Rpb24gcmVsZWFzZUludGVybmFsUG9pbnRlckNhcHR1cmUoY2FwdHVyZWRNYXAsIG9iaiwgY2FwdHVyZXMsIHBvaW50ZXJJZCkge1xuICBjb25zdCBjYXB0dXJlRGF0YSA9IGNhcHR1cmVzLmdldChvYmopO1xuICBpZiAoY2FwdHVyZURhdGEpIHtcbiAgICBjYXB0dXJlcy5kZWxldGUob2JqKTtcbiAgICAvLyBJZiB0aGlzIHdhcyB0aGUgbGFzdCBjYXB0dXJpbmcgb2JqZWN0IGZvciB0aGlzIHBvaW50ZXJcbiAgICBpZiAoY2FwdHVyZXMuc2l6ZSA9PT0gMCkge1xuICAgICAgY2FwdHVyZWRNYXAuZGVsZXRlKHBvaW50ZXJJZCk7XG4gICAgICBjYXB0dXJlRGF0YS50YXJnZXQucmVsZWFzZVBvaW50ZXJDYXB0dXJlKHBvaW50ZXJJZCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiByZW1vdmVJbnRlcmFjdGl2aXR5KHN0b3JlLCBvYmplY3QpIHtcbiAgY29uc3Qge1xuICAgIGludGVybmFsXG4gIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAvLyBSZW1vdmVzIGV2ZXJ5IHRyYWNlIG9mIGFuIG9iamVjdCBmcm9tIHRoZSBkYXRhIHN0b3JlXG4gIGludGVybmFsLmludGVyYWN0aW9uID0gaW50ZXJuYWwuaW50ZXJhY3Rpb24uZmlsdGVyKG8gPT4gbyAhPT0gb2JqZWN0KTtcbiAgaW50ZXJuYWwuaW5pdGlhbEhpdHMgPSBpbnRlcm5hbC5pbml0aWFsSGl0cy5maWx0ZXIobyA9PiBvICE9PSBvYmplY3QpO1xuICBpbnRlcm5hbC5ob3ZlcmVkLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICBpZiAodmFsdWUuZXZlbnRPYmplY3QgPT09IG9iamVjdCB8fCB2YWx1ZS5vYmplY3QgPT09IG9iamVjdCkge1xuICAgICAgLy8gQ2xlYXIgb3V0IGludGVyc2VjdHMsIHRoZXkgYXJlIG91dGRhdGVkIGJ5IG5vd1xuICAgICAgaW50ZXJuYWwuaG92ZXJlZC5kZWxldGUoa2V5KTtcbiAgICB9XG4gIH0pO1xuICBpbnRlcm5hbC5jYXB0dXJlZE1hcC5mb3JFYWNoKChjYXB0dXJlcywgcG9pbnRlcklkKSA9PiB7XG4gICAgcmVsZWFzZUludGVybmFsUG9pbnRlckNhcHR1cmUoaW50ZXJuYWwuY2FwdHVyZWRNYXAsIG9iamVjdCwgY2FwdHVyZXMsIHBvaW50ZXJJZCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlRXZlbnRzKHN0b3JlKSB7XG4gIC8qKiBDYWxjdWxhdGVzIGRlbHRhICovXG4gIGZ1bmN0aW9uIGNhbGN1bGF0ZURpc3RhbmNlKGV2ZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAgaW50ZXJuYWxcbiAgICB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICBjb25zdCBkeCA9IGV2ZW50Lm9mZnNldFggLSBpbnRlcm5hbC5pbml0aWFsQ2xpY2tbMF07XG4gICAgY29uc3QgZHkgPSBldmVudC5vZmZzZXRZIC0gaW50ZXJuYWwuaW5pdGlhbENsaWNrWzFdO1xuICAgIHJldHVybiBNYXRoLnJvdW5kKE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSkpO1xuICB9XG5cbiAgLyoqIFJldHVybnMgdHJ1ZSBpZiBhbiBpbnN0YW5jZSBoYXMgYSB2YWxpZCBwb2ludGVyLWV2ZW50IHJlZ2lzdGVyZWQsIHRoaXMgZXhjbHVkZXMgc2Nyb2xsLCBjbGlja3MgZXRjICovXG4gIGZ1bmN0aW9uIGZpbHRlclBvaW50ZXJFdmVudHMob2JqZWN0cykge1xuICAgIHJldHVybiBvYmplY3RzLmZpbHRlcihvYmogPT4gWydNb3ZlJywgJ092ZXInLCAnRW50ZXInLCAnT3V0JywgJ0xlYXZlJ10uc29tZShuYW1lID0+IHtcbiAgICAgIHZhciBfcjNmO1xuICAgICAgcmV0dXJuIChfcjNmID0gb2JqLl9fcjNmKSA9PSBudWxsID8gdm9pZCAwIDogX3IzZi5oYW5kbGVyc1snb25Qb2ludGVyJyArIG5hbWVdO1xuICAgIH0pKTtcbiAgfVxuICBmdW5jdGlvbiBpbnRlcnNlY3QoZXZlbnQsIGZpbHRlcikge1xuICAgIGNvbnN0IHN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICBjb25zdCBkdXBsaWNhdGVzID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IGludGVyc2VjdGlvbnMgPSBbXTtcbiAgICAvLyBBbGxvdyBjYWxsZXJzIHRvIGVsaW1pbmF0ZSBldmVudCBvYmplY3RzXG4gICAgY29uc3QgZXZlbnRzT2JqZWN0cyA9IGZpbHRlciA/IGZpbHRlcihzdGF0ZS5pbnRlcm5hbC5pbnRlcmFjdGlvbikgOiBzdGF0ZS5pbnRlcm5hbC5pbnRlcmFjdGlvbjtcbiAgICAvLyBSZXNldCBhbGwgcmF5Y2FzdGVyIGNhbWVyYXMgdG8gdW5kZWZpbmVkXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBldmVudHNPYmplY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IGdldFJvb3RTdGF0ZShldmVudHNPYmplY3RzW2ldKTtcbiAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICBzdGF0ZS5yYXljYXN0ZXIuY2FtZXJhID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXN0YXRlLnByZXZpb3VzUm9vdCkge1xuICAgICAgLy8gTWFrZSBzdXJlIHJvb3QtbGV2ZWwgcG9pbnRlciBhbmQgcmF5IGFyZSBzZXQgdXBcbiAgICAgIHN0YXRlLmV2ZW50cy5jb21wdXRlID09IG51bGwgPyB2b2lkIDAgOiBzdGF0ZS5ldmVudHMuY29tcHV0ZShldmVudCwgc3RhdGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVSYXljYXN0KG9iaikge1xuICAgICAgY29uc3Qgc3RhdGUgPSBnZXRSb290U3RhdGUob2JqKTtcbiAgICAgIC8vIFNraXAgZXZlbnQgaGFuZGxpbmcgd2hlbiBub0V2ZW50cyBpcyBzZXQsIG9yIHdoZW4gdGhlIHJheWNhc3RlcnMgY2FtZXJhIGlzIG51bGxcbiAgICAgIGlmICghc3RhdGUgfHwgIXN0YXRlLmV2ZW50cy5lbmFibGVkIHx8IHN0YXRlLnJheWNhc3Rlci5jYW1lcmEgPT09IG51bGwpIHJldHVybiBbXTtcblxuICAgICAgLy8gV2hlbiB0aGUgY2FtZXJhIGlzIHVuZGVmaW5lZCB3ZSBoYXZlIHRvIGNhbGwgdGhlIGV2ZW50IGxheWVycyB1cGRhdGUgZnVuY3Rpb25cbiAgICAgIGlmIChzdGF0ZS5yYXljYXN0ZXIuY2FtZXJhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIF9zdGF0ZSRwcmV2aW91c1Jvb3Q7XG4gICAgICAgIHN0YXRlLmV2ZW50cy5jb21wdXRlID09IG51bGwgPyB2b2lkIDAgOiBzdGF0ZS5ldmVudHMuY29tcHV0ZShldmVudCwgc3RhdGUsIChfc3RhdGUkcHJldmlvdXNSb290ID0gc3RhdGUucHJldmlvdXNSb290KSA9PSBudWxsID8gdm9pZCAwIDogX3N0YXRlJHByZXZpb3VzUm9vdC5nZXRTdGF0ZSgpKTtcbiAgICAgICAgLy8gSWYgdGhlIGNhbWVyYSBpcyBzdGlsbCB1bmRlZmluZWQgd2UgaGF2ZSB0byBza2lwIHRoaXMgbGF5ZXIgZW50aXJlbHlcbiAgICAgICAgaWYgKHN0YXRlLnJheWNhc3Rlci5jYW1lcmEgPT09IHVuZGVmaW5lZCkgc3RhdGUucmF5Y2FzdGVyLmNhbWVyYSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vIEludGVyc2VjdCBvYmplY3QgYnkgb2JqZWN0XG4gICAgICByZXR1cm4gc3RhdGUucmF5Y2FzdGVyLmNhbWVyYSA/IHN0YXRlLnJheWNhc3Rlci5pbnRlcnNlY3RPYmplY3Qob2JqLCB0cnVlKSA6IFtdO1xuICAgIH1cblxuICAgIC8vIENvbGxlY3QgZXZlbnRzXG4gICAgbGV0IGhpdHMgPSBldmVudHNPYmplY3RzXG4gICAgLy8gSW50ZXJzZWN0IG9iamVjdHNcbiAgICAuZmxhdE1hcChoYW5kbGVSYXljYXN0KVxuICAgIC8vIFNvcnQgYnkgZXZlbnQgcHJpb3JpdHkgYW5kIGRpc3RhbmNlXG4gICAgLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgIGNvbnN0IGFTdGF0ZSA9IGdldFJvb3RTdGF0ZShhLm9iamVjdCk7XG4gICAgICBjb25zdCBiU3RhdGUgPSBnZXRSb290U3RhdGUoYi5vYmplY3QpO1xuICAgICAgaWYgKCFhU3RhdGUgfHwgIWJTdGF0ZSkgcmV0dXJuIGEuZGlzdGFuY2UgLSBiLmRpc3RhbmNlO1xuICAgICAgcmV0dXJuIGJTdGF0ZS5ldmVudHMucHJpb3JpdHkgLSBhU3RhdGUuZXZlbnRzLnByaW9yaXR5IHx8IGEuZGlzdGFuY2UgLSBiLmRpc3RhbmNlO1xuICAgIH0pXG4gICAgLy8gRmlsdGVyIG91dCBkdXBsaWNhdGVzXG4gICAgLmZpbHRlcihpdGVtID0+IHtcbiAgICAgIGNvbnN0IGlkID0gbWFrZUlkKGl0ZW0pO1xuICAgICAgaWYgKGR1cGxpY2F0ZXMuaGFzKGlkKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgZHVwbGljYXRlcy5hZGQoaWQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL3RocmVlLmpzL2lzc3Vlcy8xNjAzMVxuICAgIC8vIEFsbG93IGN1c3RvbSB1c2VybGFuZCBpbnRlcnNlY3Qgc29ydCBvcmRlciwgdGhpcyBsaWtlbHkgb25seSBtYWtlcyBzZW5zZSBvbiB0aGUgcm9vdCBmaWx0ZXJcbiAgICBpZiAoc3RhdGUuZXZlbnRzLmZpbHRlcikgaGl0cyA9IHN0YXRlLmV2ZW50cy5maWx0ZXIoaGl0cywgc3RhdGUpO1xuXG4gICAgLy8gQnViYmxlIHVwIHRoZSBldmVudHMsIGZpbmQgdGhlIGV2ZW50IHNvdXJjZSAoZXZlbnRPYmplY3QpXG4gICAgZm9yIChjb25zdCBoaXQgb2YgaGl0cykge1xuICAgICAgbGV0IGV2ZW50T2JqZWN0ID0gaGl0Lm9iamVjdDtcbiAgICAgIC8vIEJ1YmJsZSBldmVudCB1cFxuICAgICAgd2hpbGUgKGV2ZW50T2JqZWN0KSB7XG4gICAgICAgIHZhciBfcjNmMjtcbiAgICAgICAgaWYgKChfcjNmMiA9IGV2ZW50T2JqZWN0Ll9fcjNmKSAhPSBudWxsICYmIF9yM2YyLmV2ZW50Q291bnQpIGludGVyc2VjdGlvbnMucHVzaCh7XG4gICAgICAgICAgLi4uaGl0LFxuICAgICAgICAgIGV2ZW50T2JqZWN0XG4gICAgICAgIH0pO1xuICAgICAgICBldmVudE9iamVjdCA9IGV2ZW50T2JqZWN0LnBhcmVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgaW50ZXJhY3Rpb24gaXMgY2FwdHVyZWQsIG1ha2UgYWxsIGNhcHR1cmluZyB0YXJnZXRzIHBhcnQgb2YgdGhlIGludGVyc2VjdC5cbiAgICBpZiAoJ3BvaW50ZXJJZCcgaW4gZXZlbnQgJiYgc3RhdGUuaW50ZXJuYWwuY2FwdHVyZWRNYXAuaGFzKGV2ZW50LnBvaW50ZXJJZCkpIHtcbiAgICAgIGZvciAobGV0IGNhcHR1cmVEYXRhIG9mIHN0YXRlLmludGVybmFsLmNhcHR1cmVkTWFwLmdldChldmVudC5wb2ludGVySWQpLnZhbHVlcygpKSB7XG4gICAgICAgIGlmICghZHVwbGljYXRlcy5oYXMobWFrZUlkKGNhcHR1cmVEYXRhLmludGVyc2VjdGlvbikpKSBpbnRlcnNlY3Rpb25zLnB1c2goY2FwdHVyZURhdGEuaW50ZXJzZWN0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGludGVyc2VjdGlvbnM7XG4gIH1cblxuICAvKiogIEhhbmRsZXMgaW50ZXJzZWN0aW9ucyBieSBmb3J3YXJkaW5nIHRoZW0gdG8gaGFuZGxlcnMgKi9cbiAgZnVuY3Rpb24gaGFuZGxlSW50ZXJzZWN0cyhpbnRlcnNlY3Rpb25zLCBldmVudCwgZGVsdGEsIGNhbGxiYWNrKSB7XG4gICAgY29uc3Qgcm9vdFN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcblxuICAgIC8vIElmIGFueXRoaW5nIGhhcyBiZWVuIGZvdW5kLCBmb3J3YXJkIGl0IHRvIHRoZSBldmVudCBsaXN0ZW5lcnNcbiAgICBpZiAoaW50ZXJzZWN0aW9ucy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGxvY2FsU3RhdGUgPSB7XG4gICAgICAgIHN0b3BwZWQ6IGZhbHNlXG4gICAgICB9O1xuICAgICAgZm9yIChjb25zdCBoaXQgb2YgaW50ZXJzZWN0aW9ucykge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IGdldFJvb3RTdGF0ZShoaXQub2JqZWN0KSB8fCByb290U3RhdGU7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICByYXljYXN0ZXIsXG4gICAgICAgICAgcG9pbnRlcixcbiAgICAgICAgICBjYW1lcmEsXG4gICAgICAgICAgaW50ZXJuYWxcbiAgICAgICAgfSA9IHN0YXRlO1xuICAgICAgICBjb25zdCB1bnByb2plY3RlZFBvaW50ID0gbmV3IFRIUkVFLlZlY3RvcjMocG9pbnRlci54LCBwb2ludGVyLnksIDApLnVucHJvamVjdChjYW1lcmEpO1xuICAgICAgICBjb25zdCBoYXNQb2ludGVyQ2FwdHVyZSA9IGlkID0+IHtcbiAgICAgICAgICB2YXIgX2ludGVybmFsJGNhcHR1cmVkTWFwLCBfaW50ZXJuYWwkY2FwdHVyZWRNYXAyO1xuICAgICAgICAgIHJldHVybiAoX2ludGVybmFsJGNhcHR1cmVkTWFwID0gKF9pbnRlcm5hbCRjYXB0dXJlZE1hcDIgPSBpbnRlcm5hbC5jYXB0dXJlZE1hcC5nZXQoaWQpKSA9PSBudWxsID8gdm9pZCAwIDogX2ludGVybmFsJGNhcHR1cmVkTWFwMi5oYXMoaGl0LmV2ZW50T2JqZWN0KSkgIT0gbnVsbCA/IF9pbnRlcm5hbCRjYXB0dXJlZE1hcCA6IGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzZXRQb2ludGVyQ2FwdHVyZSA9IGlkID0+IHtcbiAgICAgICAgICBjb25zdCBjYXB0dXJlRGF0YSA9IHtcbiAgICAgICAgICAgIGludGVyc2VjdGlvbjogaGl0LFxuICAgICAgICAgICAgdGFyZ2V0OiBldmVudC50YXJnZXRcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChpbnRlcm5hbC5jYXB0dXJlZE1hcC5oYXMoaWQpKSB7XG4gICAgICAgICAgICAvLyBpZiB0aGUgcG9pbnRlcklkIHdhcyBwcmV2aW91c2x5IGNhcHR1cmVkLCB3ZSBhZGQgdGhlIGhpdCB0byB0aGVcbiAgICAgICAgICAgIC8vIGV2ZW50IGNhcHR1cmVkTWFwLlxuICAgICAgICAgICAgaW50ZXJuYWwuY2FwdHVyZWRNYXAuZ2V0KGlkKS5zZXQoaGl0LmV2ZW50T2JqZWN0LCBjYXB0dXJlRGF0YSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBwb2ludGVySWQgd2FzIG5vdCBwcmV2aW91c2x5IGNhcHR1cmVkLCB3ZSBjcmVhdGUgYSBtYXBcbiAgICAgICAgICAgIC8vIGNvbnRhaW5pbmcgdGhlIGhpdE9iamVjdCwgYW5kIHRoZSBoaXQuIGhpdE9iamVjdCBpcyB1c2VkIGZvclxuICAgICAgICAgICAgLy8gZmFzdGVyIGFjY2Vzcy5cbiAgICAgICAgICAgIGludGVybmFsLmNhcHR1cmVkTWFwLnNldChpZCwgbmV3IE1hcChbW2hpdC5ldmVudE9iamVjdCwgY2FwdHVyZURhdGFdXSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBldmVudC50YXJnZXQuc2V0UG9pbnRlckNhcHR1cmUoaWQpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZWxlYXNlUG9pbnRlckNhcHR1cmUgPSBpZCA9PiB7XG4gICAgICAgICAgY29uc3QgY2FwdHVyZXMgPSBpbnRlcm5hbC5jYXB0dXJlZE1hcC5nZXQoaWQpO1xuICAgICAgICAgIGlmIChjYXB0dXJlcykge1xuICAgICAgICAgICAgcmVsZWFzZUludGVybmFsUG9pbnRlckNhcHR1cmUoaW50ZXJuYWwuY2FwdHVyZWRNYXAsIGhpdC5ldmVudE9iamVjdCwgY2FwdHVyZXMsIGlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQWRkIG5hdGl2ZSBldmVudCBwcm9wc1xuICAgICAgICBsZXQgZXh0cmFjdEV2ZW50UHJvcHMgPSB7fTtcbiAgICAgICAgLy8gVGhpcyBpdGVyYXRlcyBvdmVyIHRoZSBldmVudCdzIHByb3BlcnRpZXMgaW5jbHVkaW5nIHRoZSBpbmhlcml0ZWQgb25lcy4gTmF0aXZlIFBvaW50ZXJFdmVudHMgaGF2ZSBtb3N0IG9mIHRoZWlyIHByb3BzIGFzIGdldHRlcnMgd2hpY2ggYXJlIGluaGVyaXRlZCwgYnV0IHBvbHlmaWxsZWQgUG9pbnRlckV2ZW50cyBoYXZlIHRoZW0gYWxsIGFzIHRoZWlyIG93biBwcm9wZXJ0aWVzIChpLmUuIG5vdCBpbmhlcml0ZWQpLiBXZSBjYW4ndCB1c2UgT2JqZWN0LmtleXMoKSBvciBPYmplY3QuZW50cmllcygpIGFzIHRoZXkgb25seSByZXR1cm4gXCJvd25cIiBwcm9wZXJ0aWVzOyBub3IgT2JqZWN0LmdldFByb3RvdHlwZU9mKGV2ZW50KSBhcyB0aGF0ICpkb2Vzbid0KiByZXR1cm4gXCJvd25cIiBwcm9wZXJ0aWVzLCBvbmx5IGluaGVyaXRlZCBvbmVzLlxuICAgICAgICBmb3IgKGxldCBwcm9wIGluIGV2ZW50KSB7XG4gICAgICAgICAgbGV0IHByb3BlcnR5ID0gZXZlbnRbcHJvcF07XG4gICAgICAgICAgLy8gT25seSBjb3B5IG92ZXIgYXRvbWljcywgbGVhdmUgZnVuY3Rpb25zIGFsb25lIGFzIHRoZXNlIHNob3VsZCBiZVxuICAgICAgICAgIC8vIGNhbGxlZCBhcyBldmVudC5uYXRpdmVFdmVudC5mbigpXG4gICAgICAgICAgaWYgKHR5cGVvZiBwcm9wZXJ0eSAhPT0gJ2Z1bmN0aW9uJykgZXh0cmFjdEV2ZW50UHJvcHNbcHJvcF0gPSBwcm9wZXJ0eTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmF5Y2FzdEV2ZW50ID0ge1xuICAgICAgICAgIC4uLmhpdCxcbiAgICAgICAgICAuLi5leHRyYWN0RXZlbnRQcm9wcyxcbiAgICAgICAgICBwb2ludGVyLFxuICAgICAgICAgIGludGVyc2VjdGlvbnMsXG4gICAgICAgICAgc3RvcHBlZDogbG9jYWxTdGF0ZS5zdG9wcGVkLFxuICAgICAgICAgIGRlbHRhLFxuICAgICAgICAgIHVucHJvamVjdGVkUG9pbnQsXG4gICAgICAgICAgcmF5OiByYXljYXN0ZXIucmF5LFxuICAgICAgICAgIGNhbWVyYTogY2FtZXJhLFxuICAgICAgICAgIC8vIEhpamFjayBzdG9wUHJvcGFnYXRpb24sIHdoaWNoIGp1c3Qgc2V0cyBhIGZsYWdcbiAgICAgICAgICBzdG9wUHJvcGFnYXRpb24oKSB7XG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXRocmVlLWZpYmVyL2lzc3Vlcy81OTZcbiAgICAgICAgICAgIC8vIEV2ZW50cyBhcmUgbm90IGFsbG93ZWQgdG8gc3RvcCBwcm9wYWdhdGlvbiBpZiB0aGUgcG9pbnRlciBoYXMgYmVlbiBjYXB0dXJlZFxuICAgICAgICAgICAgY29uc3QgY2FwdHVyZXNGb3JQb2ludGVyID0gJ3BvaW50ZXJJZCcgaW4gZXZlbnQgJiYgaW50ZXJuYWwuY2FwdHVyZWRNYXAuZ2V0KGV2ZW50LnBvaW50ZXJJZCk7XG5cbiAgICAgICAgICAgIC8vIFdlIG9ubHkgYXV0aG9yaXplIHN0b3BQcm9wYWdhdGlvbi4uLlxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgLy8gLi4uaWYgdGhpcyBwb2ludGVyIGhhc24ndCBiZWVuIGNhcHR1cmVkXG4gICAgICAgICAgICAhY2FwdHVyZXNGb3JQb2ludGVyIHx8XG4gICAgICAgICAgICAvLyAuLi4gb3IgaWYgdGhlIGhpdCBvYmplY3QgaXMgY2FwdHVyaW5nIHRoZSBwb2ludGVyXG4gICAgICAgICAgICBjYXB0dXJlc0ZvclBvaW50ZXIuaGFzKGhpdC5ldmVudE9iamVjdCkpIHtcbiAgICAgICAgICAgICAgcmF5Y2FzdEV2ZW50LnN0b3BwZWQgPSBsb2NhbFN0YXRlLnN0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAvLyBQcm9wYWdhdGlvbiBpcyBzdG9wcGVkLCByZW1vdmUgYWxsIG90aGVyIGhvdmVyIHJlY29yZHNcbiAgICAgICAgICAgICAgLy8gQW4gZXZlbnQgaGFuZGxlciBpcyBvbmx5IGFsbG93ZWQgdG8gZmx1c2ggb3RoZXIgaGFuZGxlcnMgaWYgaXQgaXMgaG92ZXJlZCBpdHNlbGZcbiAgICAgICAgICAgICAgaWYgKGludGVybmFsLmhvdmVyZWQuc2l6ZSAmJiBBcnJheS5mcm9tKGludGVybmFsLmhvdmVyZWQudmFsdWVzKCkpLmZpbmQoaSA9PiBpLmV2ZW50T2JqZWN0ID09PSBoaXQuZXZlbnRPYmplY3QpKSB7XG4gICAgICAgICAgICAgICAgLy8gT2JqZWN0cyBjYW5ub3QgZmx1c2ggb3V0IGhpZ2hlciB1cCBvYmplY3RzIHRoYXQgaGF2ZSBhbHJlYWR5IGNhdWdodCB0aGUgZXZlbnRcbiAgICAgICAgICAgICAgICBjb25zdCBoaWdoZXIgPSBpbnRlcnNlY3Rpb25zLnNsaWNlKDAsIGludGVyc2VjdGlvbnMuaW5kZXhPZihoaXQpKTtcbiAgICAgICAgICAgICAgICBjYW5jZWxQb2ludGVyKFsuLi5oaWdoZXIsIGhpdF0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICAvLyB0aGVyZSBzaG91bGQgYmUgYSBkaXN0aW5jdGlvbiBiZXR3ZWVuIHRhcmdldCBhbmQgY3VycmVudFRhcmdldFxuICAgICAgICAgIHRhcmdldDoge1xuICAgICAgICAgICAgaGFzUG9pbnRlckNhcHR1cmUsXG4gICAgICAgICAgICBzZXRQb2ludGVyQ2FwdHVyZSxcbiAgICAgICAgICAgIHJlbGVhc2VQb2ludGVyQ2FwdHVyZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgY3VycmVudFRhcmdldDoge1xuICAgICAgICAgICAgaGFzUG9pbnRlckNhcHR1cmUsXG4gICAgICAgICAgICBzZXRQb2ludGVyQ2FwdHVyZSxcbiAgICAgICAgICAgIHJlbGVhc2VQb2ludGVyQ2FwdHVyZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgbmF0aXZlRXZlbnQ6IGV2ZW50XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQ2FsbCBzdWJzY3JpYmVyc1xuICAgICAgICBjYWxsYmFjayhyYXljYXN0RXZlbnQpO1xuICAgICAgICAvLyBFdmVudCBidWJibGluZyBtYXkgYmUgaW50ZXJydXB0ZWQgYnkgc3RvcFByb3BhZ2F0aW9uXG4gICAgICAgIGlmIChsb2NhbFN0YXRlLnN0b3BwZWQgPT09IHRydWUpIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaW50ZXJzZWN0aW9ucztcbiAgfVxuICBmdW5jdGlvbiBjYW5jZWxQb2ludGVyKGludGVyc2VjdGlvbnMpIHtcbiAgICBjb25zdCB7XG4gICAgICBpbnRlcm5hbFxuICAgIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgIGZvciAoY29uc3QgaG92ZXJlZE9iaiBvZiBpbnRlcm5hbC5ob3ZlcmVkLnZhbHVlcygpKSB7XG4gICAgICAvLyBXaGVuIG5vIG9iamVjdHMgd2VyZSBoaXQgb3IgdGhlIHRoZSBob3ZlcmVkIG9iamVjdCB3YXNuJ3QgZm91bmQgdW5kZXJuZWF0aCB0aGUgY3Vyc29yXG4gICAgICAvLyB3ZSBjYWxsIG9uUG9pbnRlck91dCBhbmQgZGVsZXRlIHRoZSBvYmplY3QgZnJvbSB0aGUgaG92ZXJlZC1lbGVtZW50cyBtYXBcbiAgICAgIGlmICghaW50ZXJzZWN0aW9ucy5sZW5ndGggfHwgIWludGVyc2VjdGlvbnMuZmluZChoaXQgPT4gaGl0Lm9iamVjdCA9PT0gaG92ZXJlZE9iai5vYmplY3QgJiYgaGl0LmluZGV4ID09PSBob3ZlcmVkT2JqLmluZGV4ICYmIGhpdC5pbnN0YW5jZUlkID09PSBob3ZlcmVkT2JqLmluc3RhbmNlSWQpKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50T2JqZWN0ID0gaG92ZXJlZE9iai5ldmVudE9iamVjdDtcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBldmVudE9iamVjdC5fX3IzZjtcbiAgICAgICAgY29uc3QgaGFuZGxlcnMgPSBpbnN0YW5jZSA9PSBudWxsID8gdm9pZCAwIDogaW5zdGFuY2UuaGFuZGxlcnM7XG4gICAgICAgIGludGVybmFsLmhvdmVyZWQuZGVsZXRlKG1ha2VJZChob3ZlcmVkT2JqKSk7XG4gICAgICAgIGlmIChpbnN0YW5jZSAhPSBudWxsICYmIGluc3RhbmNlLmV2ZW50Q291bnQpIHtcbiAgICAgICAgICAvLyBDbGVhciBvdXQgaW50ZXJzZWN0cywgdGhleSBhcmUgb3V0ZGF0ZWQgYnkgbm93XG4gICAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgIC4uLmhvdmVyZWRPYmosXG4gICAgICAgICAgICBpbnRlcnNlY3Rpb25zXG4gICAgICAgICAgfTtcbiAgICAgICAgICBoYW5kbGVycy5vblBvaW50ZXJPdXQgPT0gbnVsbCA/IHZvaWQgMCA6IGhhbmRsZXJzLm9uUG9pbnRlck91dChkYXRhKTtcbiAgICAgICAgICBoYW5kbGVycy5vblBvaW50ZXJMZWF2ZSA9PSBudWxsID8gdm9pZCAwIDogaGFuZGxlcnMub25Qb2ludGVyTGVhdmUoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcG9pbnRlck1pc3NlZChldmVudCwgb2JqZWN0cykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2JqZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgaW5zdGFuY2UgPSBvYmplY3RzW2ldLl9fcjNmO1xuICAgICAgaW5zdGFuY2UgPT0gbnVsbCA/IHZvaWQgMCA6IGluc3RhbmNlLmhhbmRsZXJzLm9uUG9pbnRlck1pc3NlZCA9PSBudWxsID8gdm9pZCAwIDogaW5zdGFuY2UuaGFuZGxlcnMub25Qb2ludGVyTWlzc2VkKGV2ZW50KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gaGFuZGxlUG9pbnRlcihuYW1lKSB7XG4gICAgLy8gRGVhbCB3aXRoIGNhbmNlbGF0aW9uXG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlICdvblBvaW50ZXJMZWF2ZSc6XG4gICAgICBjYXNlICdvblBvaW50ZXJDYW5jZWwnOlxuICAgICAgICByZXR1cm4gKCkgPT4gY2FuY2VsUG9pbnRlcihbXSk7XG4gICAgICBjYXNlICdvbkxvc3RQb2ludGVyQ2FwdHVyZSc6XG4gICAgICAgIHJldHVybiBldmVudCA9PiB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgaW50ZXJuYWxcbiAgICAgICAgICB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICBpZiAoJ3BvaW50ZXJJZCcgaW4gZXZlbnQgJiYgaW50ZXJuYWwuY2FwdHVyZWRNYXAuaGFzKGV2ZW50LnBvaW50ZXJJZCkpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBvYmplY3QgZXZlbnQgaW50ZXJmYWNlIGhhZCBvbkxvc3RQb2ludGVyQ2FwdHVyZSwgd2UnZCBjYWxsIGl0IGhlcmUgb24gZXZlcnlcbiAgICAgICAgICAgIC8vIG9iamVjdCB0aGF0J3MgZ2V0dGluZyByZW1vdmVkLiBXZSBjYWxsIGl0IG9uIHRoZSBuZXh0IGZyYW1lIGJlY2F1c2Ugb25Mb3N0UG9pbnRlckNhcHR1cmVcbiAgICAgICAgICAgIC8vIGZpcmVzIGJlZm9yZSBvblBvaW50ZXJVcC4gT3RoZXJ3aXNlIHBvaW50ZXJVcCB3b3VsZCBuZXZlciBiZSBjYWxsZWQgaWYgdGhlIGV2ZW50IGRpZG4ndFxuICAgICAgICAgICAgLy8gaGFwcGVuIGluIHRoZSBvYmplY3QgaXQgb3JpZ2luYXRlZCBmcm9tLCBsZWF2aW5nIGNvbXBvbmVudHMgaW4gYSBpbi1iZXR3ZWVuIHN0YXRlLlxuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgICAgLy8gT25seSByZWxlYXNlIGlmIHBvaW50ZXItdXAgZGlkbid0IGRvIGl0IGFscmVhZHlcbiAgICAgICAgICAgICAgaWYgKGludGVybmFsLmNhcHR1cmVkTWFwLmhhcyhldmVudC5wb2ludGVySWQpKSB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWwuY2FwdHVyZWRNYXAuZGVsZXRlKGV2ZW50LnBvaW50ZXJJZCk7XG4gICAgICAgICAgICAgICAgY2FuY2VsUG9pbnRlcihbXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBBbnkgb3RoZXIgcG9pbnRlciBnb2VzIGhlcmUgLi4uXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGhhbmRsZUV2ZW50KGV2ZW50KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG9uUG9pbnRlck1pc3NlZCxcbiAgICAgICAgaW50ZXJuYWxcbiAgICAgIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuXG4gICAgICAvLyBwcmVwYXJlUmF5KGV2ZW50KVxuICAgICAgaW50ZXJuYWwubGFzdEV2ZW50LmN1cnJlbnQgPSBldmVudDtcblxuICAgICAgLy8gR2V0IGZyZXNoIGludGVyc2VjdHNcbiAgICAgIGNvbnN0IGlzUG9pbnRlck1vdmUgPSBuYW1lID09PSAnb25Qb2ludGVyTW92ZSc7XG4gICAgICBjb25zdCBpc0NsaWNrRXZlbnQgPSBuYW1lID09PSAnb25DbGljaycgfHwgbmFtZSA9PT0gJ29uQ29udGV4dE1lbnUnIHx8IG5hbWUgPT09ICdvbkRvdWJsZUNsaWNrJztcbiAgICAgIGNvbnN0IGZpbHRlciA9IGlzUG9pbnRlck1vdmUgPyBmaWx0ZXJQb2ludGVyRXZlbnRzIDogdW5kZWZpbmVkO1xuICAgICAgY29uc3QgaGl0cyA9IGludGVyc2VjdChldmVudCwgZmlsdGVyKTtcbiAgICAgIGNvbnN0IGRlbHRhID0gaXNDbGlja0V2ZW50ID8gY2FsY3VsYXRlRGlzdGFuY2UoZXZlbnQpIDogMDtcblxuICAgICAgLy8gU2F2ZSBpbml0aWFsIGNvb3JkaW5hdGVzIG9uIHBvaW50ZXItZG93blxuICAgICAgaWYgKG5hbWUgPT09ICdvblBvaW50ZXJEb3duJykge1xuICAgICAgICBpbnRlcm5hbC5pbml0aWFsQ2xpY2sgPSBbZXZlbnQub2Zmc2V0WCwgZXZlbnQub2Zmc2V0WV07XG4gICAgICAgIGludGVybmFsLmluaXRpYWxIaXRzID0gaGl0cy5tYXAoaGl0ID0+IGhpdC5ldmVudE9iamVjdCk7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIGEgY2xpY2sgeWllbGRzIG5vIHJlc3VsdHMsIHBhc3MgaXQgYmFjayB0byB0aGUgdXNlciBhcyBhIG1pc3NcbiAgICAgIC8vIE1pc3NlZCBldmVudHMgaGF2ZSB0byBjb21lIGZpcnN0IGluIG9yZGVyIHRvIGVzdGFibGlzaCB1c2VyLWxhbmQgc2lkZS1lZmZlY3QgY2xlYW4gdXBcbiAgICAgIGlmIChpc0NsaWNrRXZlbnQgJiYgIWhpdHMubGVuZ3RoKSB7XG4gICAgICAgIGlmIChkZWx0YSA8PSAyKSB7XG4gICAgICAgICAgcG9pbnRlck1pc3NlZChldmVudCwgaW50ZXJuYWwuaW50ZXJhY3Rpb24pO1xuICAgICAgICAgIGlmIChvblBvaW50ZXJNaXNzZWQpIG9uUG9pbnRlck1pc3NlZChldmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFRha2UgY2FyZSBvZiB1bmhvdmVyXG4gICAgICBpZiAoaXNQb2ludGVyTW92ZSkgY2FuY2VsUG9pbnRlcihoaXRzKTtcbiAgICAgIGZ1bmN0aW9uIG9uSW50ZXJzZWN0KGRhdGEpIHtcbiAgICAgICAgY29uc3QgZXZlbnRPYmplY3QgPSBkYXRhLmV2ZW50T2JqZWN0O1xuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGV2ZW50T2JqZWN0Ll9fcjNmO1xuICAgICAgICBjb25zdCBoYW5kbGVycyA9IGluc3RhbmNlID09IG51bGwgPyB2b2lkIDAgOiBpbnN0YW5jZS5oYW5kbGVycztcblxuICAgICAgICAvLyBDaGVjayBwcmVzZW5jZSBvZiBoYW5kbGVyc1xuICAgICAgICBpZiAoIShpbnN0YW5jZSAhPSBudWxsICYmIGluc3RhbmNlLmV2ZW50Q291bnQpKSByZXR1cm47XG5cbiAgICAgICAgLypcbiAgICAgICAgTUFZQkUgVE9ETywgREVMRVRFIElGIE5PVDogXG4gICAgICAgICAgQ2hlY2sgaWYgdGhlIG9iamVjdCBpcyBjYXB0dXJlZCwgY2FwdHVyZWQgZXZlbnRzIHNob3VsZCBub3QgaGF2ZSBpbnRlcnNlY3RzIHJ1bm5pbmcgaW4gcGFyYWxsZWxcbiAgICAgICAgICBCdXQgd291bGRuJ3QgaXQgYmUgYmV0dGVyIHRvIGp1c3QgcmVwbGFjZSBjYXB0dXJlZE1hcCB3aXRoIGEgc2luZ2xlIGVudHJ5P1xuICAgICAgICAgIEFsc28sIGFyZSB3ZSBPSyB3aXRoIHN0cmFpZ2h0IHVwIG1ha2luZyBwaWNraW5nIHVwIG11bHRpcGxlIG9iamVjdHMgaW1wb3NzaWJsZT9cbiAgICAgICAgICBcbiAgICAgICAgY29uc3QgcG9pbnRlcklkID0gKGRhdGEgYXMgVGhyZWVFdmVudDxQb2ludGVyRXZlbnQ+KS5wb2ludGVySWQgICAgICAgIFxuICAgICAgICBpZiAocG9pbnRlcklkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjb25zdCBjYXB0dXJlZE1lc2hTZXQgPSBpbnRlcm5hbC5jYXB0dXJlZE1hcC5nZXQocG9pbnRlcklkKVxuICAgICAgICAgIGlmIChjYXB0dXJlZE1lc2hTZXQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhcHR1cmVkID0gY2FwdHVyZWRNZXNoU2V0LmdldChldmVudE9iamVjdClcbiAgICAgICAgICAgIGlmIChjYXB0dXJlZCAmJiBjYXB0dXJlZC5sb2NhbFN0YXRlLnN0b3BwZWQpIHJldHVyblxuICAgICAgICAgIH1cbiAgICAgICAgfSovXG5cbiAgICAgICAgaWYgKGlzUG9pbnRlck1vdmUpIHtcbiAgICAgICAgICAvLyBNb3ZlIGV2ZW50IC4uLlxuICAgICAgICAgIGlmIChoYW5kbGVycy5vblBvaW50ZXJPdmVyIHx8IGhhbmRsZXJzLm9uUG9pbnRlckVudGVyIHx8IGhhbmRsZXJzLm9uUG9pbnRlck91dCB8fCBoYW5kbGVycy5vblBvaW50ZXJMZWF2ZSkge1xuICAgICAgICAgICAgLy8gV2hlbiBlbnRlciBvciBvdXQgaXMgcHJlc2VudCB0YWtlIGNhcmUgb2YgaG92ZXItc3RhdGVcbiAgICAgICAgICAgIGNvbnN0IGlkID0gbWFrZUlkKGRhdGEpO1xuICAgICAgICAgICAgY29uc3QgaG92ZXJlZEl0ZW0gPSBpbnRlcm5hbC5ob3ZlcmVkLmdldChpZCk7XG4gICAgICAgICAgICBpZiAoIWhvdmVyZWRJdGVtKSB7XG4gICAgICAgICAgICAgIC8vIElmIHRoZSBvYmplY3Qgd2Fzbid0IHByZXZpb3VzbHkgaG92ZXJlZCwgYm9vayBpdCBhbmQgY2FsbCBpdHMgaGFuZGxlclxuICAgICAgICAgICAgICBpbnRlcm5hbC5ob3ZlcmVkLnNldChpZCwgZGF0YSk7XG4gICAgICAgICAgICAgIGhhbmRsZXJzLm9uUG9pbnRlck92ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGhhbmRsZXJzLm9uUG9pbnRlck92ZXIoZGF0YSk7XG4gICAgICAgICAgICAgIGhhbmRsZXJzLm9uUG9pbnRlckVudGVyID09IG51bGwgPyB2b2lkIDAgOiBoYW5kbGVycy5vblBvaW50ZXJFbnRlcihkYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaG92ZXJlZEl0ZW0uc3RvcHBlZCkge1xuICAgICAgICAgICAgICAvLyBJZiB0aGUgb2JqZWN0IHdhcyBwcmV2aW91c2x5IGhvdmVyZWQgYW5kIHN0b3BwZWQsIHdlIHNob3VsZG4ndCBhbGxvdyBvdGhlciBpdGVtcyB0byBwcm9jZWVkXG4gICAgICAgICAgICAgIGRhdGEuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIENhbGwgbW91c2UgbW92ZVxuICAgICAgICAgIGhhbmRsZXJzLm9uUG9pbnRlck1vdmUgPT0gbnVsbCA/IHZvaWQgMCA6IGhhbmRsZXJzLm9uUG9pbnRlck1vdmUoZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQWxsIG90aGVyIGV2ZW50cyAuLi5cbiAgICAgICAgICBjb25zdCBoYW5kbGVyID0gaGFuZGxlcnNbbmFtZV07XG4gICAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICAgIC8vIEZvcndhcmQgYWxsIGV2ZW50cyBiYWNrIHRvIHRoZWlyIHJlc3BlY3RpdmUgaGFuZGxlcnMgd2l0aCB0aGUgZXhjZXB0aW9uIG9mIGNsaWNrIGV2ZW50cyxcbiAgICAgICAgICAgIC8vIHdoaWNoIG11c3QgdXNlIHRoZSBpbml0aWFsIHRhcmdldFxuICAgICAgICAgICAgaWYgKCFpc0NsaWNrRXZlbnQgfHwgaW50ZXJuYWwuaW5pdGlhbEhpdHMuaW5jbHVkZXMoZXZlbnRPYmplY3QpKSB7XG4gICAgICAgICAgICAgIC8vIE1pc3NlZCBldmVudHMgaGF2ZSB0byBjb21lIGZpcnN0XG4gICAgICAgICAgICAgIHBvaW50ZXJNaXNzZWQoZXZlbnQsIGludGVybmFsLmludGVyYWN0aW9uLmZpbHRlcihvYmplY3QgPT4gIWludGVybmFsLmluaXRpYWxIaXRzLmluY2x1ZGVzKG9iamVjdCkpKTtcbiAgICAgICAgICAgICAgLy8gTm93IGNhbGwgdGhlIGhhbmRsZXJcbiAgICAgICAgICAgICAgaGFuZGxlcihkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVHJpZ2dlciBvblBvaW50ZXJNaXNzZWQgb24gYWxsIGVsZW1lbnRzIHRoYXQgaGF2ZSBwb2ludGVyIG92ZXIvb3V0IGhhbmRsZXJzLCBidXQgbm90IGNsaWNrIGFuZCB3ZXJlbid0IGhpdFxuICAgICAgICAgICAgaWYgKGlzQ2xpY2tFdmVudCAmJiBpbnRlcm5hbC5pbml0aWFsSGl0cy5pbmNsdWRlcyhldmVudE9iamVjdCkpIHtcbiAgICAgICAgICAgICAgcG9pbnRlck1pc3NlZChldmVudCwgaW50ZXJuYWwuaW50ZXJhY3Rpb24uZmlsdGVyKG9iamVjdCA9PiAhaW50ZXJuYWwuaW5pdGlhbEhpdHMuaW5jbHVkZXMob2JqZWN0KSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaGFuZGxlSW50ZXJzZWN0cyhoaXRzLCBldmVudCwgZGVsdGEsIG9uSW50ZXJzZWN0KTtcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgaGFuZGxlUG9pbnRlclxuICB9O1xufVxuXG4vLyBLZXlzIHRoYXQgc2hvdWxkbid0IGJlIGNvcGllZCBiZXR3ZWVuIFIzRiBzdG9yZXNcbmNvbnN0IHByaXZhdGVLZXlzID0gWydzZXQnLCAnZ2V0JywgJ3NldFNpemUnLCAnc2V0RnJhbWVsb29wJywgJ3NldERwcicsICdldmVudHMnLCAnaW52YWxpZGF0ZScsICdhZHZhbmNlJywgJ3NpemUnLCAndmlld3BvcnQnXTtcbmNvbnN0IGlzUmVuZGVyZXIgPSBkZWYgPT4gISEoZGVmICE9IG51bGwgJiYgZGVmLnJlbmRlcik7XG5jb25zdCBjb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5jb25zdCBjcmVhdGVTdG9yZSA9IChpbnZhbGlkYXRlLCBhZHZhbmNlKSA9PiB7XG4gIGNvbnN0IHJvb3RTdGF0ZSA9IGNyZWF0ZSgoc2V0LCBnZXQpID0+IHtcbiAgICBjb25zdCBwb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgY29uc3QgZGVmYXVsdFRhcmdldCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgY29uc3QgdGVtcFRhcmdldCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgZnVuY3Rpb24gZ2V0Q3VycmVudFZpZXdwb3J0KGNhbWVyYSA9IGdldCgpLmNhbWVyYSwgdGFyZ2V0ID0gZGVmYXVsdFRhcmdldCwgc2l6ZSA9IGdldCgpLnNpemUpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgdG9wLFxuICAgICAgICBsZWZ0XG4gICAgICB9ID0gc2l6ZTtcbiAgICAgIGNvbnN0IGFzcGVjdCA9IHdpZHRoIC8gaGVpZ2h0O1xuICAgICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIFRIUkVFLlZlY3RvcjMpIHRlbXBUYXJnZXQuY29weSh0YXJnZXQpO2Vsc2UgdGVtcFRhcmdldC5zZXQoLi4udGFyZ2V0KTtcbiAgICAgIGNvbnN0IGRpc3RhbmNlID0gY2FtZXJhLmdldFdvcmxkUG9zaXRpb24ocG9zaXRpb24pLmRpc3RhbmNlVG8odGVtcFRhcmdldCk7XG4gICAgICBpZiAoaXNPcnRob2dyYXBoaWNDYW1lcmEoY2FtZXJhKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHdpZHRoOiB3aWR0aCAvIGNhbWVyYS56b29tLFxuICAgICAgICAgIGhlaWdodDogaGVpZ2h0IC8gY2FtZXJhLnpvb20sXG4gICAgICAgICAgdG9wLFxuICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgZmFjdG9yOiAxLFxuICAgICAgICAgIGRpc3RhbmNlLFxuICAgICAgICAgIGFzcGVjdFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZm92ID0gY2FtZXJhLmZvdiAqIE1hdGguUEkgLyAxODA7IC8vIGNvbnZlcnQgdmVydGljYWwgZm92IHRvIHJhZGlhbnNcbiAgICAgICAgY29uc3QgaCA9IDIgKiBNYXRoLnRhbihmb3YgLyAyKSAqIGRpc3RhbmNlOyAvLyB2aXNpYmxlIGhlaWdodFxuICAgICAgICBjb25zdCB3ID0gaCAqICh3aWR0aCAvIGhlaWdodCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgd2lkdGg6IHcsXG4gICAgICAgICAgaGVpZ2h0OiBoLFxuICAgICAgICAgIHRvcCxcbiAgICAgICAgICBsZWZ0LFxuICAgICAgICAgIGZhY3Rvcjogd2lkdGggLyB3LFxuICAgICAgICAgIGRpc3RhbmNlLFxuICAgICAgICAgIGFzcGVjdFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgcGVyZm9ybWFuY2VUaW1lb3V0ID0gdW5kZWZpbmVkO1xuICAgIGNvbnN0IHNldFBlcmZvcm1hbmNlQ3VycmVudCA9IGN1cnJlbnQgPT4gc2V0KHN0YXRlID0+ICh7XG4gICAgICBwZXJmb3JtYW5jZToge1xuICAgICAgICAuLi5zdGF0ZS5wZXJmb3JtYW5jZSxcbiAgICAgICAgY3VycmVudFxuICAgICAgfVxuICAgIH0pKTtcbiAgICBjb25zdCBwb2ludGVyID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcbiAgICBjb25zdCByb290U3RhdGUgPSB7XG4gICAgICBzZXQsXG4gICAgICBnZXQsXG4gICAgICAvLyBNb2NrIG9iamVjdHMgdGhhdCBoYXZlIHRvIGJlIGNvbmZpZ3VyZWRcbiAgICAgIGdsOiBudWxsLFxuICAgICAgY2FtZXJhOiBudWxsLFxuICAgICAgcmF5Y2FzdGVyOiBudWxsLFxuICAgICAgZXZlbnRzOiB7XG4gICAgICAgIHByaW9yaXR5OiAxLFxuICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICBjb25uZWN0ZWQ6IGZhbHNlXG4gICAgICB9LFxuICAgICAgeHI6IG51bGwsXG4gICAgICBzY2VuZTogbnVsbCxcbiAgICAgIGludmFsaWRhdGU6IChmcmFtZXMgPSAxKSA9PiBpbnZhbGlkYXRlKGdldCgpLCBmcmFtZXMpLFxuICAgICAgYWR2YW5jZTogKHRpbWVzdGFtcCwgcnVuR2xvYmFsRWZmZWN0cykgPT4gYWR2YW5jZSh0aW1lc3RhbXAsIHJ1bkdsb2JhbEVmZmVjdHMsIGdldCgpKSxcbiAgICAgIGxlZ2FjeTogZmFsc2UsXG4gICAgICBsaW5lYXI6IGZhbHNlLFxuICAgICAgZmxhdDogZmFsc2UsXG4gICAgICBjb250cm9sczogbnVsbCxcbiAgICAgIGNsb2NrOiBuZXcgVEhSRUUuQ2xvY2soKSxcbiAgICAgIHBvaW50ZXIsXG4gICAgICBtb3VzZTogcG9pbnRlcixcbiAgICAgIGZyYW1lbG9vcDogJ2Fsd2F5cycsXG4gICAgICBvblBvaW50ZXJNaXNzZWQ6IHVuZGVmaW5lZCxcbiAgICAgIHBlcmZvcm1hbmNlOiB7XG4gICAgICAgIGN1cnJlbnQ6IDEsXG4gICAgICAgIG1pbjogMC41LFxuICAgICAgICBtYXg6IDEsXG4gICAgICAgIGRlYm91bmNlOiAyMDAsXG4gICAgICAgIHJlZ3Jlc3M6ICgpID0+IHtcbiAgICAgICAgICBjb25zdCBzdGF0ZSA9IGdldCgpO1xuICAgICAgICAgIC8vIENsZWFyIHRpbWVvdXRcbiAgICAgICAgICBpZiAocGVyZm9ybWFuY2VUaW1lb3V0KSBjbGVhclRpbWVvdXQocGVyZm9ybWFuY2VUaW1lb3V0KTtcbiAgICAgICAgICAvLyBTZXQgbG93ZXIgYm91bmQgcGVyZm9ybWFuY2VcbiAgICAgICAgICBpZiAoc3RhdGUucGVyZm9ybWFuY2UuY3VycmVudCAhPT0gc3RhdGUucGVyZm9ybWFuY2UubWluKSBzZXRQZXJmb3JtYW5jZUN1cnJlbnQoc3RhdGUucGVyZm9ybWFuY2UubWluKTtcbiAgICAgICAgICAvLyBHbyBiYWNrIHRvIHVwcGVyIGJvdW5kIHBlcmZvcm1hbmNlIGFmdGVyIGEgd2hpbGUgdW5sZXNzIHNvbWV0aGluZyByZWdyZXNzZXMgbWVhbndoaWxlXG4gICAgICAgICAgcGVyZm9ybWFuY2VUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiBzZXRQZXJmb3JtYW5jZUN1cnJlbnQoZ2V0KCkucGVyZm9ybWFuY2UubWF4KSwgc3RhdGUucGVyZm9ybWFuY2UuZGVib3VuY2UpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2l6ZToge1xuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICB0b3A6IDAsXG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIHVwZGF0ZVN0eWxlOiBmYWxzZVxuICAgICAgfSxcbiAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgIGluaXRpYWxEcHI6IDAsXG4gICAgICAgIGRwcjogMCxcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgdG9wOiAwLFxuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICBhc3BlY3Q6IDAsXG4gICAgICAgIGRpc3RhbmNlOiAwLFxuICAgICAgICBmYWN0b3I6IDAsXG4gICAgICAgIGdldEN1cnJlbnRWaWV3cG9ydFxuICAgICAgfSxcbiAgICAgIHNldEV2ZW50czogZXZlbnRzID0+IHNldChzdGF0ZSA9PiAoe1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgZXZlbnRzOiB7XG4gICAgICAgICAgLi4uc3RhdGUuZXZlbnRzLFxuICAgICAgICAgIC4uLmV2ZW50c1xuICAgICAgICB9XG4gICAgICB9KSksXG4gICAgICBzZXRTaXplOiAod2lkdGgsIGhlaWdodCwgdXBkYXRlU3R5bGUsIHRvcCwgbGVmdCkgPT4ge1xuICAgICAgICBjb25zdCBjYW1lcmEgPSBnZXQoKS5jYW1lcmE7XG4gICAgICAgIGNvbnN0IHNpemUgPSB7XG4gICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgIHRvcDogdG9wIHx8IDAsXG4gICAgICAgICAgbGVmdDogbGVmdCB8fCAwLFxuICAgICAgICAgIHVwZGF0ZVN0eWxlXG4gICAgICAgIH07XG4gICAgICAgIHNldChzdGF0ZSA9PiAoe1xuICAgICAgICAgIHNpemUsXG4gICAgICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgICAgIC4uLnN0YXRlLnZpZXdwb3J0LFxuICAgICAgICAgICAgLi4uZ2V0Q3VycmVudFZpZXdwb3J0KGNhbWVyYSwgZGVmYXVsdFRhcmdldCwgc2l6ZSlcbiAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgIH0sXG4gICAgICBzZXREcHI6IGRwciA9PiBzZXQoc3RhdGUgPT4ge1xuICAgICAgICBjb25zdCByZXNvbHZlZCA9IGNhbGN1bGF0ZURwcihkcHIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgICAgICAuLi5zdGF0ZS52aWV3cG9ydCxcbiAgICAgICAgICAgIGRwcjogcmVzb2x2ZWQsXG4gICAgICAgICAgICBpbml0aWFsRHByOiBzdGF0ZS52aWV3cG9ydC5pbml0aWFsRHByIHx8IHJlc29sdmVkXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSksXG4gICAgICBzZXRGcmFtZWxvb3A6IChmcmFtZWxvb3AgPSAnYWx3YXlzJykgPT4ge1xuICAgICAgICBjb25zdCBjbG9jayA9IGdldCgpLmNsb2NrO1xuXG4gICAgICAgIC8vIGlmIGZyYW1lbG9vcCA9PT0gXCJuZXZlclwiIGNsb2NrLmVsYXBzZWRUaW1lIGlzIHVwZGF0ZWQgdXNpbmcgYWR2YW5jZSh0aW1lc3RhbXApXG4gICAgICAgIGNsb2NrLnN0b3AoKTtcbiAgICAgICAgY2xvY2suZWxhcHNlZFRpbWUgPSAwO1xuICAgICAgICBpZiAoZnJhbWVsb29wICE9PSAnbmV2ZXInKSB7XG4gICAgICAgICAgY2xvY2suc3RhcnQoKTtcbiAgICAgICAgICBjbG9jay5lbGFwc2VkVGltZSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgc2V0KCgpID0+ICh7XG4gICAgICAgICAgZnJhbWVsb29wXG4gICAgICAgIH0pKTtcbiAgICAgIH0sXG4gICAgICBwcmV2aW91c1Jvb3Q6IHVuZGVmaW5lZCxcbiAgICAgIGludGVybmFsOiB7XG4gICAgICAgIGFjdGl2ZTogZmFsc2UsXG4gICAgICAgIHByaW9yaXR5OiAwLFxuICAgICAgICBmcmFtZXM6IDAsXG4gICAgICAgIGxhc3RFdmVudDogLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZVJlZigpLFxuICAgICAgICBpbnRlcmFjdGlvbjogW10sXG4gICAgICAgIGhvdmVyZWQ6IG5ldyBNYXAoKSxcbiAgICAgICAgc3Vic2NyaWJlcnM6IFtdLFxuICAgICAgICBpbml0aWFsQ2xpY2s6IFswLCAwXSxcbiAgICAgICAgaW5pdGlhbEhpdHM6IFtdLFxuICAgICAgICBjYXB0dXJlZE1hcDogbmV3IE1hcCgpLFxuICAgICAgICBzdWJzY3JpYmU6IChyZWYsIHByaW9yaXR5LCBzdG9yZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGludGVybmFsID0gZ2V0KCkuaW50ZXJuYWw7XG4gICAgICAgICAgLy8gSWYgdGhpcyBzdWJzY3JpcHRpb24gd2FzIGdpdmVuIGEgcHJpb3JpdHksIGl0IHRha2VzIHJlbmRlcmluZyBpbnRvIGl0cyBvd24gaGFuZHNcbiAgICAgICAgICAvLyBGb3IgdGhhdCByZWFzb24gd2Ugc3dpdGNoIG9mZiBhdXRvbWF0aWMgcmVuZGVyaW5nIGFuZCBpbmNyZWFzZSB0aGUgbWFudWFsIGZsYWdcbiAgICAgICAgICAvLyBBcyBsb25nIGFzIHRoaXMgZmxhZyBpcyBwb3NpdGl2ZSB0aGVyZSBjYW4gYmUgbm8gaW50ZXJuYWwgcmVuZGVyaW5nIGF0IGFsbFxuICAgICAgICAgIC8vIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgbXVsdGlwbGUgcmVuZGVyIHN1YnNjcmlwdGlvbnNcbiAgICAgICAgICBpbnRlcm5hbC5wcmlvcml0eSA9IGludGVybmFsLnByaW9yaXR5ICsgKHByaW9yaXR5ID4gMCA/IDEgOiAwKTtcbiAgICAgICAgICBpbnRlcm5hbC5zdWJzY3JpYmVycy5wdXNoKHtcbiAgICAgICAgICAgIHJlZixcbiAgICAgICAgICAgIHByaW9yaXR5LFxuICAgICAgICAgICAgc3RvcmVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICAvLyBSZWdpc3RlciBzdWJzY3JpYmVyIGFuZCBzb3J0IGxheWVycyBmcm9tIGxvd2VzdCB0byBoaWdoZXN0LCBtZWFuaW5nLFxuICAgICAgICAgIC8vIGhpZ2hlc3QgcHJpb3JpdHkgcmVuZGVycyBsYXN0IChvbiB0b3Agb2YgdGhlIG90aGVyIGZyYW1lcylcbiAgICAgICAgICBpbnRlcm5hbC5zdWJzY3JpYmVycyA9IGludGVybmFsLnN1YnNjcmliZXJzLnNvcnQoKGEsIGIpID0+IGEucHJpb3JpdHkgLSBiLnByaW9yaXR5KTtcbiAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW50ZXJuYWwgPSBnZXQoKS5pbnRlcm5hbDtcbiAgICAgICAgICAgIGlmIChpbnRlcm5hbCAhPSBudWxsICYmIGludGVybmFsLnN1YnNjcmliZXJzKSB7XG4gICAgICAgICAgICAgIC8vIERlY3JlYXNlIG1hbnVhbCBmbGFnIGlmIHRoaXMgc3Vic2NyaXB0aW9uIGhhZCBhIHByaW9yaXR5XG4gICAgICAgICAgICAgIGludGVybmFsLnByaW9yaXR5ID0gaW50ZXJuYWwucHJpb3JpdHkgLSAocHJpb3JpdHkgPiAwID8gMSA6IDApO1xuICAgICAgICAgICAgICAvLyBSZW1vdmUgc3Vic2NyaWJlciBmcm9tIGxpc3RcbiAgICAgICAgICAgICAgaW50ZXJuYWwuc3Vic2NyaWJlcnMgPSBpbnRlcm5hbC5zdWJzY3JpYmVycy5maWx0ZXIocyA9PiBzLnJlZiAhPT0gcmVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gcm9vdFN0YXRlO1xuICB9KTtcbiAgY29uc3Qgc3RhdGUgPSByb290U3RhdGUuZ2V0U3RhdGUoKTtcbiAgbGV0IG9sZFNpemUgPSBzdGF0ZS5zaXplO1xuICBsZXQgb2xkRHByID0gc3RhdGUudmlld3BvcnQuZHByO1xuICBsZXQgb2xkQ2FtZXJhID0gc3RhdGUuY2FtZXJhO1xuICByb290U3RhdGUuc3Vic2NyaWJlKCgpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBjYW1lcmEsXG4gICAgICBzaXplLFxuICAgICAgdmlld3BvcnQsXG4gICAgICBnbCxcbiAgICAgIHNldFxuICAgIH0gPSByb290U3RhdGUuZ2V0U3RhdGUoKTtcblxuICAgIC8vIFJlc2l6ZSBjYW1lcmEgYW5kIHJlbmRlcmVyIG9uIGNoYW5nZXMgdG8gc2l6ZSBhbmQgcGl4ZWxyYXRpb1xuICAgIGlmIChzaXplICE9PSBvbGRTaXplIHx8IHZpZXdwb3J0LmRwciAhPT0gb2xkRHByKSB7XG4gICAgICB2YXIgX3NpemUkdXBkYXRlU3R5bGU7XG4gICAgICBvbGRTaXplID0gc2l6ZTtcbiAgICAgIG9sZERwciA9IHZpZXdwb3J0LmRwcjtcbiAgICAgIC8vIFVwZGF0ZSBjYW1lcmEgJiByZW5kZXJlclxuICAgICAgdXBkYXRlQ2FtZXJhKGNhbWVyYSwgc2l6ZSk7XG4gICAgICBnbC5zZXRQaXhlbFJhdGlvKHZpZXdwb3J0LmRwcik7XG4gICAgICBjb25zdCB1cGRhdGVTdHlsZSA9IChfc2l6ZSR1cGRhdGVTdHlsZSA9IHNpemUudXBkYXRlU3R5bGUpICE9IG51bGwgPyBfc2l6ZSR1cGRhdGVTdHlsZSA6IHR5cGVvZiBIVE1MQ2FudmFzRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2wuZG9tRWxlbWVudCBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50O1xuICAgICAgZ2wuc2V0U2l6ZShzaXplLndpZHRoLCBzaXplLmhlaWdodCwgdXBkYXRlU3R5bGUpO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSB2aWV3cG9ydCBvbmNlIHRoZSBjYW1lcmEgY2hhbmdlc1xuICAgIGlmIChjYW1lcmEgIT09IG9sZENhbWVyYSkge1xuICAgICAgb2xkQ2FtZXJhID0gY2FtZXJhO1xuICAgICAgLy8gVXBkYXRlIHZpZXdwb3J0XG4gICAgICBzZXQoc3RhdGUgPT4gKHtcbiAgICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgICAuLi5zdGF0ZS52aWV3cG9ydCxcbiAgICAgICAgICAuLi5zdGF0ZS52aWV3cG9ydC5nZXRDdXJyZW50Vmlld3BvcnQoY2FtZXJhKVxuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgfVxuICB9KTtcblxuICAvLyBJbnZhbGlkYXRlIG9uIGFueSBjaGFuZ2VcbiAgcm9vdFN0YXRlLnN1YnNjcmliZShzdGF0ZSA9PiBpbnZhbGlkYXRlKHN0YXRlKSk7XG5cbiAgLy8gUmV0dXJuIHJvb3Qgc3RhdGVcbiAgcmV0dXJuIHJvb3RTdGF0ZTtcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZVN1YnMoY2FsbGJhY2ssIHN1YnMpIHtcbiAgY29uc3Qgc3ViID0ge1xuICAgIGNhbGxiYWNrXG4gIH07XG4gIHN1YnMuYWRkKHN1Yik7XG4gIHJldHVybiAoKSA9PiB2b2lkIHN1YnMuZGVsZXRlKHN1Yik7XG59XG5sZXQgaTtcbmxldCBnbG9iYWxFZmZlY3RzID0gbmV3IFNldCgpO1xubGV0IGdsb2JhbEFmdGVyRWZmZWN0cyA9IG5ldyBTZXQoKTtcbmxldCBnbG9iYWxUYWlsRWZmZWN0cyA9IG5ldyBTZXQoKTtcblxuLyoqXG4gKiBBZGRzIGEgZ2xvYmFsIHJlbmRlciBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgZWFjaCBmcmFtZS5cbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLnBtbmQucnMvcmVhY3QtdGhyZWUtZmliZXIvYXBpL2FkZGl0aW9uYWwtZXhwb3J0cyNhZGRFZmZlY3RcbiAqL1xuY29uc3QgYWRkRWZmZWN0ID0gY2FsbGJhY2sgPT4gY3JlYXRlU3VicyhjYWxsYmFjaywgZ2xvYmFsRWZmZWN0cyk7XG5cbi8qKlxuICogQWRkcyBhIGdsb2JhbCBhZnRlci1yZW5kZXIgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGVhY2ggZnJhbWUuXG4gKiBAc2VlIGh0dHBzOi8vZG9jcy5wbW5kLnJzL3JlYWN0LXRocmVlLWZpYmVyL2FwaS9hZGRpdGlvbmFsLWV4cG9ydHMjYWRkQWZ0ZXJFZmZlY3RcbiAqL1xuY29uc3QgYWRkQWZ0ZXJFZmZlY3QgPSBjYWxsYmFjayA9PiBjcmVhdGVTdWJzKGNhbGxiYWNrLCBnbG9iYWxBZnRlckVmZmVjdHMpO1xuXG4vKipcbiAqIEFkZHMgYSBnbG9iYWwgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gcmVuZGVyaW5nIHN0b3BzLlxuICogQHNlZSBodHRwczovL2RvY3MucG1uZC5ycy9yZWFjdC10aHJlZS1maWJlci9hcGkvYWRkaXRpb25hbC1leHBvcnRzI2FkZFRhaWxcbiAqL1xuY29uc3QgYWRkVGFpbCA9IGNhbGxiYWNrID0+IGNyZWF0ZVN1YnMoY2FsbGJhY2ssIGdsb2JhbFRhaWxFZmZlY3RzKTtcbmZ1bmN0aW9uIHJ1bihlZmZlY3RzLCB0aW1lc3RhbXApIHtcbiAgaWYgKCFlZmZlY3RzLnNpemUpIHJldHVybjtcbiAgZm9yIChjb25zdCB7XG4gICAgY2FsbGJhY2tcbiAgfSBvZiBlZmZlY3RzLnZhbHVlcygpKSB7XG4gICAgY2FsbGJhY2sodGltZXN0YW1wKTtcbiAgfVxufVxuZnVuY3Rpb24gZmx1c2hHbG9iYWxFZmZlY3RzKHR5cGUsIHRpbWVzdGFtcCkge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdiZWZvcmUnOlxuICAgICAgcmV0dXJuIHJ1bihnbG9iYWxFZmZlY3RzLCB0aW1lc3RhbXApO1xuICAgIGNhc2UgJ2FmdGVyJzpcbiAgICAgIHJldHVybiBydW4oZ2xvYmFsQWZ0ZXJFZmZlY3RzLCB0aW1lc3RhbXApO1xuICAgIGNhc2UgJ3RhaWwnOlxuICAgICAgcmV0dXJuIHJ1bihnbG9iYWxUYWlsRWZmZWN0cywgdGltZXN0YW1wKTtcbiAgfVxufVxubGV0IHN1YnNjcmliZXJzO1xubGV0IHN1YnNjcmlwdGlvbjtcbmZ1bmN0aW9uIHJlbmRlciQxKHRpbWVzdGFtcCwgc3RhdGUsIGZyYW1lKSB7XG4gIC8vIFJ1biBsb2NhbCBlZmZlY3RzXG4gIGxldCBkZWx0YSA9IHN0YXRlLmNsb2NrLmdldERlbHRhKCk7XG4gIC8vIEluIGZyYW1lbG9vcD0nbmV2ZXInIG1vZGUsIGNsb2NrIHRpbWVzIGFyZSB1cGRhdGVkIHVzaW5nIHRoZSBwcm92aWRlZCB0aW1lc3RhbXBcbiAgaWYgKHN0YXRlLmZyYW1lbG9vcCA9PT0gJ25ldmVyJyAmJiB0eXBlb2YgdGltZXN0YW1wID09PSAnbnVtYmVyJykge1xuICAgIGRlbHRhID0gdGltZXN0YW1wIC0gc3RhdGUuY2xvY2suZWxhcHNlZFRpbWU7XG4gICAgc3RhdGUuY2xvY2sub2xkVGltZSA9IHN0YXRlLmNsb2NrLmVsYXBzZWRUaW1lO1xuICAgIHN0YXRlLmNsb2NrLmVsYXBzZWRUaW1lID0gdGltZXN0YW1wO1xuICB9XG4gIC8vIENhbGwgc3Vic2NyaWJlcnMgKHVzZUZyYW1lKVxuICBzdWJzY3JpYmVycyA9IHN0YXRlLmludGVybmFsLnN1YnNjcmliZXJzO1xuICBmb3IgKGkgPSAwOyBpIDwgc3Vic2NyaWJlcnMubGVuZ3RoOyBpKyspIHtcbiAgICBzdWJzY3JpcHRpb24gPSBzdWJzY3JpYmVyc1tpXTtcbiAgICBzdWJzY3JpcHRpb24ucmVmLmN1cnJlbnQoc3Vic2NyaXB0aW9uLnN0b3JlLmdldFN0YXRlKCksIGRlbHRhLCBmcmFtZSk7XG4gIH1cbiAgLy8gUmVuZGVyIGNvbnRlbnRcbiAgaWYgKCFzdGF0ZS5pbnRlcm5hbC5wcmlvcml0eSAmJiBzdGF0ZS5nbC5yZW5kZXIpIHN0YXRlLmdsLnJlbmRlcihzdGF0ZS5zY2VuZSwgc3RhdGUuY2FtZXJhKTtcbiAgLy8gRGVjcmVhc2UgZnJhbWUgY291bnRcbiAgc3RhdGUuaW50ZXJuYWwuZnJhbWVzID0gTWF0aC5tYXgoMCwgc3RhdGUuaW50ZXJuYWwuZnJhbWVzIC0gMSk7XG4gIHJldHVybiBzdGF0ZS5mcmFtZWxvb3AgPT09ICdhbHdheXMnID8gMSA6IHN0YXRlLmludGVybmFsLmZyYW1lcztcbn1cbmZ1bmN0aW9uIGNyZWF0ZUxvb3Aocm9vdHMpIHtcbiAgbGV0IHJ1bm5pbmcgPSBmYWxzZTtcbiAgbGV0IHJlcGVhdDtcbiAgbGV0IGZyYW1lO1xuICBsZXQgc3RhdGU7XG4gIGZ1bmN0aW9uIGxvb3AodGltZXN0YW1wKSB7XG4gICAgZnJhbWUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUobG9vcCk7XG4gICAgcnVubmluZyA9IHRydWU7XG4gICAgcmVwZWF0ID0gMDtcblxuICAgIC8vIFJ1biBlZmZlY3RzXG4gICAgZmx1c2hHbG9iYWxFZmZlY3RzKCdiZWZvcmUnLCB0aW1lc3RhbXApO1xuXG4gICAgLy8gUmVuZGVyIGFsbCByb290c1xuICAgIGZvciAoY29uc3Qgcm9vdCBvZiByb290cy52YWx1ZXMoKSkge1xuICAgICAgdmFyIF9zdGF0ZSRnbCR4cjtcbiAgICAgIHN0YXRlID0gcm9vdC5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgLy8gSWYgdGhlIGZyYW1lbG9vcCBpcyBpbnZhbGlkYXRlZCwgZG8gbm90IHJ1biBhbm90aGVyIGZyYW1lXG4gICAgICBpZiAoc3RhdGUuaW50ZXJuYWwuYWN0aXZlICYmIChzdGF0ZS5mcmFtZWxvb3AgPT09ICdhbHdheXMnIHx8IHN0YXRlLmludGVybmFsLmZyYW1lcyA+IDApICYmICEoKF9zdGF0ZSRnbCR4ciA9IHN0YXRlLmdsLnhyKSAhPSBudWxsICYmIF9zdGF0ZSRnbCR4ci5pc1ByZXNlbnRpbmcpKSB7XG4gICAgICAgIHJlcGVhdCArPSByZW5kZXIkMSh0aW1lc3RhbXAsIHN0YXRlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSdW4gYWZ0ZXItZWZmZWN0c1xuICAgIGZsdXNoR2xvYmFsRWZmZWN0cygnYWZ0ZXInLCB0aW1lc3RhbXApO1xuXG4gICAgLy8gU3RvcCB0aGUgbG9vcCBpZiBub3RoaW5nIGludmFsaWRhdGVzIGl0XG4gICAgaWYgKHJlcGVhdCA9PT0gMCkge1xuICAgICAgLy8gVGFpbCBjYWxsIGVmZmVjdHMsIHRoZXkgYXJlIGNhbGxlZCB3aGVuIHJlbmRlcmluZyBzdG9wc1xuICAgICAgZmx1c2hHbG9iYWxFZmZlY3RzKCd0YWlsJywgdGltZXN0YW1wKTtcblxuICAgICAgLy8gRmxhZyBlbmQgb2Ygb3BlcmF0aW9uXG4gICAgICBydW5uaW5nID0gZmFsc2U7XG4gICAgICByZXR1cm4gY2FuY2VsQW5pbWF0aW9uRnJhbWUoZnJhbWUpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBpbnZhbGlkYXRlKHN0YXRlLCBmcmFtZXMgPSAxKSB7XG4gICAgdmFyIF9zdGF0ZSRnbCR4cjI7XG4gICAgaWYgKCFzdGF0ZSkgcmV0dXJuIHJvb3RzLmZvckVhY2gocm9vdCA9PiBpbnZhbGlkYXRlKHJvb3Quc3RvcmUuZ2V0U3RhdGUoKSksIGZyYW1lcyk7XG4gICAgaWYgKChfc3RhdGUkZ2wkeHIyID0gc3RhdGUuZ2wueHIpICE9IG51bGwgJiYgX3N0YXRlJGdsJHhyMi5pc1ByZXNlbnRpbmcgfHwgIXN0YXRlLmludGVybmFsLmFjdGl2ZSB8fCBzdGF0ZS5mcmFtZWxvb3AgPT09ICduZXZlcicpIHJldHVybjtcbiAgICAvLyBJbmNyZWFzZSBmcmFtZXMsIGRvIG5vdCBnbyBoaWdoZXIgdGhhbiA2MFxuICAgIHN0YXRlLmludGVybmFsLmZyYW1lcyA9IE1hdGgubWluKDYwLCBzdGF0ZS5pbnRlcm5hbC5mcmFtZXMgKyBmcmFtZXMpO1xuICAgIC8vIElmIHRoZSByZW5kZXItbG9vcCBpc24ndCBhY3RpdmUsIHN0YXJ0IGl0XG4gICAgaWYgKCFydW5uaW5nKSB7XG4gICAgICBydW5uaW5nID0gdHJ1ZTtcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShsb29wKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gYWR2YW5jZSh0aW1lc3RhbXAsIHJ1bkdsb2JhbEVmZmVjdHMgPSB0cnVlLCBzdGF0ZSwgZnJhbWUpIHtcbiAgICBpZiAocnVuR2xvYmFsRWZmZWN0cykgZmx1c2hHbG9iYWxFZmZlY3RzKCdiZWZvcmUnLCB0aW1lc3RhbXApO1xuICAgIGlmICghc3RhdGUpIGZvciAoY29uc3Qgcm9vdCBvZiByb290cy52YWx1ZXMoKSkgcmVuZGVyJDEodGltZXN0YW1wLCByb290LnN0b3JlLmdldFN0YXRlKCkpO2Vsc2UgcmVuZGVyJDEodGltZXN0YW1wLCBzdGF0ZSwgZnJhbWUpO1xuICAgIGlmIChydW5HbG9iYWxFZmZlY3RzKSBmbHVzaEdsb2JhbEVmZmVjdHMoJ2FmdGVyJywgdGltZXN0YW1wKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGxvb3AsXG4gICAgLyoqXG4gICAgICogSW52YWxpZGF0ZXMgdGhlIHZpZXcsIHJlcXVlc3RpbmcgYSBmcmFtZSB0byBiZSByZW5kZXJlZC4gV2lsbCBnbG9iYWxseSBpbnZhbGlkYXRlIHVubGVzcyBwYXNzZWQgYSByb290J3Mgc3RhdGUuXG4gICAgICogQHNlZSBodHRwczovL2RvY3MucG1uZC5ycy9yZWFjdC10aHJlZS1maWJlci9hcGkvYWRkaXRpb25hbC1leHBvcnRzI2ludmFsaWRhdGVcbiAgICAgKi9cbiAgICBpbnZhbGlkYXRlLFxuICAgIC8qKlxuICAgICAqIEFkdmFuY2VzIHRoZSBmcmFtZWxvb3AgYW5kIHJ1bnMgcmVuZGVyIGVmZmVjdHMsIHVzZWZ1bCBmb3Igd2hlbiBtYW51YWxseSByZW5kZXJpbmcgdmlhIGBmcmFtZWxvb3A9XCJuZXZlclwiYC5cbiAgICAgKiBAc2VlIGh0dHBzOi8vZG9jcy5wbW5kLnJzL3JlYWN0LXRocmVlLWZpYmVyL2FwaS9hZGRpdGlvbmFsLWV4cG9ydHMjYWR2YW5jZVxuICAgICAqL1xuICAgIGFkdmFuY2VcbiAgfTtcbn1cblxuLyoqXG4gKiBFeHBvc2VzIGFuIG9iamVjdCdzIHtAbGluayBMb2NhbFN0YXRlfS5cbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLnBtbmQucnMvcmVhY3QtdGhyZWUtZmliZXIvYXBpL2FkZGl0aW9uYWwtZXhwb3J0cyN1c2VJbnN0YW5jZUhhbmRsZVxuICpcbiAqICoqTm90ZSoqOiB0aGlzIGlzIGFuIGVzY2FwZSBoYXRjaCB0byByZWFjdC1pbnRlcm5hbCBmaWVsZHMuIEV4cGVjdCB0aGlzIHRvIGNoYW5nZSBzaWduaWZpY2FudGx5IGJldHdlZW4gdmVyc2lvbnMuXG4gKi9cbmZ1bmN0aW9uIHVzZUluc3RhbmNlSGFuZGxlKHJlZikge1xuICBjb25zdCBpbnN0YW5jZSA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB2b2lkIChpbnN0YW5jZS5jdXJyZW50ID0gcmVmLmN1cnJlbnQuX19yM2YpLCBbcmVmXSk7XG4gIHJldHVybiBpbnN0YW5jZTtcbn1cbmZ1bmN0aW9uIHVzZVN0b3JlKCkge1xuICBjb25zdCBzdG9yZSA9IFJlYWN0LnVzZUNvbnRleHQoY29udGV4dCk7XG4gIGlmICghc3RvcmUpIHRocm93IG5ldyBFcnJvcignUjNGOiBIb29rcyBjYW4gb25seSBiZSB1c2VkIHdpdGhpbiB0aGUgQ2FudmFzIGNvbXBvbmVudCEnKTtcbiAgcmV0dXJuIHN0b3JlO1xufVxuXG4vKipcbiAqIEFjY2Vzc2VzIFIzRidzIGludGVybmFsIHN0YXRlLCBjb250YWluaW5nIHJlbmRlcmVyLCBjYW52YXMsIHNjZW5lLCBldGMuXG4gKiBAc2VlIGh0dHBzOi8vZG9jcy5wbW5kLnJzL3JlYWN0LXRocmVlLWZpYmVyL2FwaS9ob29rcyN1c2V0aHJlZVxuICovXG5mdW5jdGlvbiB1c2VUaHJlZShzZWxlY3RvciA9IHN0YXRlID0+IHN0YXRlLCBlcXVhbGl0eUZuKSB7XG4gIHJldHVybiB1c2VTdG9yZSgpKHNlbGVjdG9yLCBlcXVhbGl0eUZuKTtcbn1cblxuLyoqXG4gKiBFeGVjdXRlcyBhIGNhbGxiYWNrIGJlZm9yZSByZW5kZXIgaW4gYSBzaGFyZWQgZnJhbWUgbG9vcC5cbiAqIENhbiBvcmRlciBlZmZlY3RzIHdpdGggcmVuZGVyIHByaW9yaXR5IG9yIG1hbnVhbGx5IHJlbmRlciB3aXRoIGEgcG9zaXRpdmUgcHJpb3JpdHkuXG4gKiBAc2VlIGh0dHBzOi8vZG9jcy5wbW5kLnJzL3JlYWN0LXRocmVlLWZpYmVyL2FwaS9ob29rcyN1c2VmcmFtZVxuICovXG5mdW5jdGlvbiB1c2VGcmFtZShjYWxsYmFjaywgcmVuZGVyUHJpb3JpdHkgPSAwKSB7XG4gIGNvbnN0IHN0b3JlID0gdXNlU3RvcmUoKTtcbiAgY29uc3Qgc3Vic2NyaWJlID0gc3RvcmUuZ2V0U3RhdGUoKS5pbnRlcm5hbC5zdWJzY3JpYmU7XG4gIC8vIE1lbW9pemUgcmVmXG4gIGNvbnN0IHJlZiA9IHVzZU11dGFibGVDYWxsYmFjayhjYWxsYmFjayk7XG4gIC8vIFN1YnNjcmliZSBvbiBtb3VudCwgdW5zdWJzY3JpYmUgb24gdW5tb3VudFxuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHN1YnNjcmliZShyZWYsIHJlbmRlclByaW9yaXR5LCBzdG9yZSksIFtyZW5kZXJQcmlvcml0eSwgc3Vic2NyaWJlLCBzdG9yZV0pO1xuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgbm9kZSBncmFwaCBvZiBhbiBvYmplY3Qgd2l0aCBuYW1lZCBub2RlcyAmIG1hdGVyaWFscy5cbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLnBtbmQucnMvcmVhY3QtdGhyZWUtZmliZXIvYXBpL2hvb2tzI3VzZWdyYXBoXG4gKi9cbmZ1bmN0aW9uIHVzZUdyYXBoKG9iamVjdCkge1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiBidWlsZEdyYXBoKG9iamVjdCksIFtvYmplY3RdKTtcbn1cbmZ1bmN0aW9uIGxvYWRpbmdGbihleHRlbnNpb25zLCBvblByb2dyZXNzKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoUHJvdG8sIC4uLmlucHV0KSB7XG4gICAgLy8gQ29uc3RydWN0IG5ldyBsb2FkZXIgYW5kIHJ1biBleHRlbnNpb25zXG4gICAgY29uc3QgbG9hZGVyID0gbmV3IFByb3RvKCk7XG4gICAgaWYgKGV4dGVuc2lvbnMpIGV4dGVuc2lvbnMobG9hZGVyKTtcbiAgICAvLyBHbyB0aHJvdWdoIHRoZSB1cmxzIGFuZCBsb2FkIHRoZW1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoaW5wdXQubWFwKGlucHV0ID0+IG5ldyBQcm9taXNlKChyZXMsIHJlamVjdCkgPT4gbG9hZGVyLmxvYWQoaW5wdXQsIGRhdGEgPT4ge1xuICAgICAgaWYgKGRhdGEuc2NlbmUpIE9iamVjdC5hc3NpZ24oZGF0YSwgYnVpbGRHcmFwaChkYXRhLnNjZW5lKSk7XG4gICAgICByZXMoZGF0YSk7XG4gICAgfSwgb25Qcm9ncmVzcywgZXJyb3IgPT4gcmVqZWN0KG5ldyBFcnJvcihgQ291bGQgbm90IGxvYWQgJHtpbnB1dH06ICR7ZXJyb3IubWVzc2FnZX1gKSkpKSkpO1xuICB9O1xufVxuXG4vKipcbiAqIFN5bmNocm9ub3VzbHkgbG9hZHMgYW5kIGNhY2hlcyBhc3NldHMgd2l0aCBhIHRocmVlIGxvYWRlci5cbiAqXG4gKiBOb3RlOiB0aGlzIGhvb2sncyBjYWxsZXIgbXVzdCBiZSB3cmFwcGVkIHdpdGggYFJlYWN0LlN1c3BlbnNlYFxuICogQHNlZSBodHRwczovL2RvY3MucG1uZC5ycy9yZWFjdC10aHJlZS1maWJlci9hcGkvaG9va3MjdXNlbG9hZGVyXG4gKi9cbmZ1bmN0aW9uIHVzZUxvYWRlcihQcm90bywgaW5wdXQsIGV4dGVuc2lvbnMsIG9uUHJvZ3Jlc3MpIHtcbiAgLy8gVXNlIHN1c3BlbnNlIHRvIGxvYWQgYXN5bmMgYXNzZXRzXG4gIGNvbnN0IGtleXMgPSBBcnJheS5pc0FycmF5KGlucHV0KSA/IGlucHV0IDogW2lucHV0XTtcbiAgY29uc3QgcmVzdWx0cyA9IHN1c3BlbmQobG9hZGluZ0ZuKGV4dGVuc2lvbnMsIG9uUHJvZ3Jlc3MpLCBbUHJvdG8sIC4uLmtleXNdLCB7XG4gICAgZXF1YWw6IGlzLmVxdVxuICB9KTtcbiAgLy8gUmV0dXJuIHRoZSBvYmplY3Qvc1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShpbnB1dCkgPyByZXN1bHRzIDogcmVzdWx0c1swXTtcbn1cblxuLyoqXG4gKiBQcmVsb2FkcyBhbiBhc3NldCBpbnRvIGNhY2hlIGFzIGEgc2lkZS1lZmZlY3QuXG4gKi9cbnVzZUxvYWRlci5wcmVsb2FkID0gZnVuY3Rpb24gKFByb3RvLCBpbnB1dCwgZXh0ZW5zaW9ucykge1xuICBjb25zdCBrZXlzID0gQXJyYXkuaXNBcnJheShpbnB1dCkgPyBpbnB1dCA6IFtpbnB1dF07XG4gIHJldHVybiBwcmVsb2FkKGxvYWRpbmdGbihleHRlbnNpb25zKSwgW1Byb3RvLCAuLi5rZXlzXSk7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgYSBsb2FkZWQgYXNzZXQgZnJvbSBjYWNoZS5cbiAqL1xudXNlTG9hZGVyLmNsZWFyID0gZnVuY3Rpb24gKFByb3RvLCBpbnB1dCkge1xuICBjb25zdCBrZXlzID0gQXJyYXkuaXNBcnJheShpbnB1dCkgPyBpbnB1dCA6IFtpbnB1dF07XG4gIHJldHVybiBjbGVhcihbUHJvdG8sIC4uLmtleXNdKTtcbn07XG5cbmNvbnN0IHJvb3RzID0gbmV3IE1hcCgpO1xuY29uc3Qge1xuICBpbnZhbGlkYXRlLFxuICBhZHZhbmNlXG59ID0gY3JlYXRlTG9vcChyb290cyk7XG5jb25zdCB7XG4gIHJlY29uY2lsZXIsXG4gIGFwcGx5UHJvcHNcbn0gPSBjcmVhdGVSZW5kZXJlcihyb290cywgZ2V0RXZlbnRQcmlvcml0eSk7XG5jb25zdCBzaGFsbG93TG9vc2UgPSB7XG4gIG9iamVjdHM6ICdzaGFsbG93JyxcbiAgc3RyaWN0OiBmYWxzZVxufTtcbmNvbnN0IGNyZWF0ZVJlbmRlcmVySW5zdGFuY2UgPSAoZ2wsIGNhbnZhcykgPT4ge1xuICBjb25zdCBjdXN0b21SZW5kZXJlciA9IHR5cGVvZiBnbCA9PT0gJ2Z1bmN0aW9uJyA/IGdsKGNhbnZhcykgOiBnbDtcbiAgaWYgKGlzUmVuZGVyZXIoY3VzdG9tUmVuZGVyZXIpKSByZXR1cm4gY3VzdG9tUmVuZGVyZXI7ZWxzZSByZXR1cm4gbmV3IFRIUkVFLldlYkdMUmVuZGVyZXIoe1xuICAgIHBvd2VyUHJlZmVyZW5jZTogJ2hpZ2gtcGVyZm9ybWFuY2UnLFxuICAgIGNhbnZhczogY2FudmFzLFxuICAgIGFudGlhbGlhczogdHJ1ZSxcbiAgICBhbHBoYTogdHJ1ZSxcbiAgICAuLi5nbFxuICB9KTtcbn07XG5mdW5jdGlvbiBjb21wdXRlSW5pdGlhbFNpemUoY2FudmFzLCBkZWZhdWx0U2l6ZSkge1xuICBpZiAoZGVmYXVsdFNpemUpIHJldHVybiBkZWZhdWx0U2l6ZTtcbiAgaWYgKHR5cGVvZiBIVE1MQ2FudmFzRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgY2FudmFzIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQgJiYgY2FudmFzLnBhcmVudEVsZW1lbnQpIHtcbiAgICBjb25zdCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIHRvcCxcbiAgICAgIGxlZnRcbiAgICB9ID0gY2FudmFzLnBhcmVudEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgdG9wLFxuICAgICAgbGVmdFxuICAgIH07XG4gIH0gZWxzZSBpZiAodHlwZW9mIE9mZnNjcmVlbkNhbnZhcyAhPT0gJ3VuZGVmaW5lZCcgJiYgY2FudmFzIGluc3RhbmNlb2YgT2Zmc2NyZWVuQ2FudmFzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiBjYW52YXMud2lkdGgsXG4gICAgICBoZWlnaHQ6IGNhbnZhcy5oZWlnaHQsXG4gICAgICB0b3A6IDAsXG4gICAgICBsZWZ0OiAwXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHdpZHRoOiAwLFxuICAgIGhlaWdodDogMCxcbiAgICB0b3A6IDAsXG4gICAgbGVmdDogMFxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlUm9vdChjYW52YXMpIHtcbiAgLy8gQ2hlY2sgYWdhaW5zdCBtaXN0YWtlbiB1c2Ugb2YgY3JlYXRlUm9vdFxuICBjb25zdCBwcmV2Um9vdCA9IHJvb3RzLmdldChjYW52YXMpO1xuICBjb25zdCBwcmV2RmliZXIgPSBwcmV2Um9vdCA9PSBudWxsID8gdm9pZCAwIDogcHJldlJvb3QuZmliZXI7XG4gIGNvbnN0IHByZXZTdG9yZSA9IHByZXZSb290ID09IG51bGwgPyB2b2lkIDAgOiBwcmV2Um9vdC5zdG9yZTtcbiAgaWYgKHByZXZSb290KSBjb25zb2xlLndhcm4oJ1IzRi5jcmVhdGVSb290IHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbmNlIScpO1xuXG4gIC8vIFJlcG9ydCB3aGVuIGFuIGVycm9yIHdhcyBkZXRlY3RlZCBpbiBhIHByZXZpb3VzIHJlbmRlclxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXRocmVlLWZpYmVyL3B1bGwvMjI2MVxuICBjb25zdCBsb2dSZWNvdmVyYWJsZUVycm9yID0gdHlwZW9mIHJlcG9ydEVycm9yID09PSAnZnVuY3Rpb24nID9cbiAgLy8gSW4gbW9kZXJuIGJyb3dzZXJzLCByZXBvcnRFcnJvciB3aWxsIGRpc3BhdGNoIGFuIGVycm9yIGV2ZW50LFxuICAvLyBlbXVsYXRpbmcgYW4gdW5jYXVnaHQgSmF2YVNjcmlwdCBlcnJvci5cbiAgcmVwb3J0RXJyb3IgOlxuICAvLyBJbiBvbGRlciBicm93c2VycyBhbmQgdGVzdCBlbnZpcm9ubWVudHMsIGZhbGxiYWNrIHRvIGNvbnNvbGUuZXJyb3IuXG4gIGNvbnNvbGUuZXJyb3I7XG5cbiAgLy8gQ3JlYXRlIHN0b3JlXG4gIGNvbnN0IHN0b3JlID0gcHJldlN0b3JlIHx8IGNyZWF0ZVN0b3JlKGludmFsaWRhdGUsIGFkdmFuY2UpO1xuICAvLyBDcmVhdGUgcmVuZGVyZXJcbiAgY29uc3QgZmliZXIgPSBwcmV2RmliZXIgfHwgcmVjb25jaWxlci5jcmVhdGVDb250YWluZXIoc3RvcmUsIENvbmN1cnJlbnRSb290LCBudWxsLCBmYWxzZSwgbnVsbCwgJycsIGxvZ1JlY292ZXJhYmxlRXJyb3IsIG51bGwpO1xuICAvLyBNYXAgaXRcbiAgaWYgKCFwcmV2Um9vdCkgcm9vdHMuc2V0KGNhbnZhcywge1xuICAgIGZpYmVyLFxuICAgIHN0b3JlXG4gIH0pO1xuXG4gIC8vIExvY2Fsc1xuICBsZXQgb25DcmVhdGVkO1xuICBsZXQgY29uZmlndXJlZCA9IGZhbHNlO1xuICBsZXQgbGFzdENhbWVyYTtcbiAgcmV0dXJuIHtcbiAgICBjb25maWd1cmUocHJvcHMgPSB7fSkge1xuICAgICAgbGV0IHtcbiAgICAgICAgZ2w6IGdsQ29uZmlnLFxuICAgICAgICBzaXplOiBwcm9wc1NpemUsXG4gICAgICAgIHNjZW5lOiBzY2VuZU9wdGlvbnMsXG4gICAgICAgIGV2ZW50cyxcbiAgICAgICAgb25DcmVhdGVkOiBvbkNyZWF0ZWRDYWxsYmFjayxcbiAgICAgICAgc2hhZG93cyA9IGZhbHNlLFxuICAgICAgICBsaW5lYXIgPSBmYWxzZSxcbiAgICAgICAgZmxhdCA9IGZhbHNlLFxuICAgICAgICBsZWdhY3kgPSBmYWxzZSxcbiAgICAgICAgb3J0aG9ncmFwaGljID0gZmFsc2UsXG4gICAgICAgIGZyYW1lbG9vcCA9ICdhbHdheXMnLFxuICAgICAgICBkcHIgPSBbMSwgMl0sXG4gICAgICAgIHBlcmZvcm1hbmNlLFxuICAgICAgICByYXljYXN0ZXI6IHJheWNhc3RPcHRpb25zLFxuICAgICAgICBjYW1lcmE6IGNhbWVyYU9wdGlvbnMsXG4gICAgICAgIG9uUG9pbnRlck1pc3NlZFxuICAgICAgfSA9IHByb3BzO1xuICAgICAgbGV0IHN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcblxuICAgICAgLy8gU2V0IHVwIHJlbmRlcmVyIChvbmUgdGltZSBvbmx5ISlcbiAgICAgIGxldCBnbCA9IHN0YXRlLmdsO1xuICAgICAgaWYgKCFzdGF0ZS5nbCkgc3RhdGUuc2V0KHtcbiAgICAgICAgZ2w6IGdsID0gY3JlYXRlUmVuZGVyZXJJbnN0YW5jZShnbENvbmZpZywgY2FudmFzKVxuICAgICAgfSk7XG5cbiAgICAgIC8vIFNldCB1cCByYXljYXN0ZXIgKG9uZSB0aW1lIG9ubHkhKVxuICAgICAgbGV0IHJheWNhc3RlciA9IHN0YXRlLnJheWNhc3RlcjtcbiAgICAgIGlmICghcmF5Y2FzdGVyKSBzdGF0ZS5zZXQoe1xuICAgICAgICByYXljYXN0ZXI6IHJheWNhc3RlciA9IG5ldyBUSFJFRS5SYXljYXN0ZXIoKVxuICAgICAgfSk7XG5cbiAgICAgIC8vIFNldCByYXljYXN0ZXIgb3B0aW9uc1xuICAgICAgY29uc3Qge1xuICAgICAgICBwYXJhbXMsXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH0gPSByYXljYXN0T3B0aW9ucyB8fCB7fTtcbiAgICAgIGlmICghaXMuZXF1KG9wdGlvbnMsIHJheWNhc3Rlciwgc2hhbGxvd0xvb3NlKSkgYXBwbHlQcm9wcyhyYXljYXN0ZXIsIHtcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfSk7XG4gICAgICBpZiAoIWlzLmVxdShwYXJhbXMsIHJheWNhc3Rlci5wYXJhbXMsIHNoYWxsb3dMb29zZSkpIGFwcGx5UHJvcHMocmF5Y2FzdGVyLCB7XG4gICAgICAgIHBhcmFtczoge1xuICAgICAgICAgIC4uLnJheWNhc3Rlci5wYXJhbXMsXG4gICAgICAgICAgLi4ucGFyYW1zXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBDcmVhdGUgZGVmYXVsdCBjYW1lcmEsIGRvbid0IG92ZXJ3cml0ZSBhbnkgdXNlci1zZXQgc3RhdGVcbiAgICAgIGlmICghc3RhdGUuY2FtZXJhIHx8IHN0YXRlLmNhbWVyYSA9PT0gbGFzdENhbWVyYSAmJiAhaXMuZXF1KGxhc3RDYW1lcmEsIGNhbWVyYU9wdGlvbnMsIHNoYWxsb3dMb29zZSkpIHtcbiAgICAgICAgbGFzdENhbWVyYSA9IGNhbWVyYU9wdGlvbnM7XG4gICAgICAgIGNvbnN0IGlzQ2FtZXJhID0gY2FtZXJhT3B0aW9ucyBpbnN0YW5jZW9mIFRIUkVFLkNhbWVyYTtcbiAgICAgICAgY29uc3QgY2FtZXJhID0gaXNDYW1lcmEgPyBjYW1lcmFPcHRpb25zIDogb3J0aG9ncmFwaGljID8gbmV3IFRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYSgwLCAwLCAwLCAwLCAwLjEsIDEwMDApIDogbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKDc1LCAwLCAwLjEsIDEwMDApO1xuICAgICAgICBpZiAoIWlzQ2FtZXJhKSB7XG4gICAgICAgICAgY2FtZXJhLnBvc2l0aW9uLnogPSA1O1xuICAgICAgICAgIGlmIChjYW1lcmFPcHRpb25zKSBhcHBseVByb3BzKGNhbWVyYSwgY2FtZXJhT3B0aW9ucyk7XG4gICAgICAgICAgLy8gQWx3YXlzIGxvb2sgYXQgY2VudGVyIGJ5IGRlZmF1bHRcbiAgICAgICAgICBpZiAoIXN0YXRlLmNhbWVyYSAmJiAhKGNhbWVyYU9wdGlvbnMgIT0gbnVsbCAmJiBjYW1lcmFPcHRpb25zLnJvdGF0aW9uKSkgY2FtZXJhLmxvb2tBdCgwLCAwLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5zZXQoe1xuICAgICAgICAgIGNhbWVyYVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gU2V0IHVwIHNjZW5lIChvbmUgdGltZSBvbmx5ISlcbiAgICAgIGlmICghc3RhdGUuc2NlbmUpIHtcbiAgICAgICAgbGV0IHNjZW5lO1xuICAgICAgICBpZiAoc2NlbmVPcHRpb25zIGluc3RhbmNlb2YgVEhSRUUuU2NlbmUpIHtcbiAgICAgICAgICBzY2VuZSA9IHNjZW5lT3B0aW9ucztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzY2VuZSA9IG5ldyBUSFJFRS5TY2VuZSgpO1xuICAgICAgICAgIGlmIChzY2VuZU9wdGlvbnMpIGFwcGx5UHJvcHMoc2NlbmUsIHNjZW5lT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuc2V0KHtcbiAgICAgICAgICBzY2VuZTogcHJlcGFyZShzY2VuZSlcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNldCB1cCBYUiAob25lIHRpbWUgb25seSEpXG4gICAgICBpZiAoIXN0YXRlLnhyKSB7XG4gICAgICAgIHZhciBfZ2wkeHI7XG4gICAgICAgIC8vIEhhbmRsZSBmcmFtZSBiZWhhdmlvciBpbiBXZWJYUlxuICAgICAgICBjb25zdCBoYW5kbGVYUkZyYW1lID0gKHRpbWVzdGFtcCwgZnJhbWUpID0+IHtcbiAgICAgICAgICBjb25zdCBzdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgaWYgKHN0YXRlLmZyYW1lbG9vcCA9PT0gJ25ldmVyJykgcmV0dXJuO1xuICAgICAgICAgIGFkdmFuY2UodGltZXN0YW1wLCB0cnVlLCBzdGF0ZSwgZnJhbWUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFRvZ2dsZSByZW5kZXIgc3dpdGNoaW5nIG9uIHNlc3Npb25cbiAgICAgICAgY29uc3QgaGFuZGxlU2Vzc2lvbkNoYW5nZSA9ICgpID0+IHtcbiAgICAgICAgICBjb25zdCBzdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgc3RhdGUuZ2wueHIuZW5hYmxlZCA9IHN0YXRlLmdsLnhyLmlzUHJlc2VudGluZztcbiAgICAgICAgICBzdGF0ZS5nbC54ci5zZXRBbmltYXRpb25Mb29wKHN0YXRlLmdsLnhyLmlzUHJlc2VudGluZyA/IGhhbmRsZVhSRnJhbWUgOiBudWxsKTtcbiAgICAgICAgICBpZiAoIXN0YXRlLmdsLnhyLmlzUHJlc2VudGluZykgaW52YWxpZGF0ZShzdGF0ZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gV2ViWFIgc2Vzc2lvbiBtYW5hZ2VyXG4gICAgICAgIGNvbnN0IHhyID0ge1xuICAgICAgICAgIGNvbm5lY3QoKSB7XG4gICAgICAgICAgICBjb25zdCBnbCA9IHN0b3JlLmdldFN0YXRlKCkuZ2w7XG4gICAgICAgICAgICBnbC54ci5hZGRFdmVudExpc3RlbmVyKCdzZXNzaW9uc3RhcnQnLCBoYW5kbGVTZXNzaW9uQ2hhbmdlKTtcbiAgICAgICAgICAgIGdsLnhyLmFkZEV2ZW50TGlzdGVuZXIoJ3Nlc3Npb25lbmQnLCBoYW5kbGVTZXNzaW9uQ2hhbmdlKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgICAgICBjb25zdCBnbCA9IHN0b3JlLmdldFN0YXRlKCkuZ2w7XG4gICAgICAgICAgICBnbC54ci5yZW1vdmVFdmVudExpc3RlbmVyKCdzZXNzaW9uc3RhcnQnLCBoYW5kbGVTZXNzaW9uQ2hhbmdlKTtcbiAgICAgICAgICAgIGdsLnhyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Nlc3Npb25lbmQnLCBoYW5kbGVTZXNzaW9uQ2hhbmdlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gU3Vic2NyaWJlIHRvIFdlYlhSIHNlc3Npb24gZXZlbnRzXG4gICAgICAgIGlmICh0eXBlb2YgKChfZ2wkeHIgPSBnbC54cikgPT0gbnVsbCA/IHZvaWQgMCA6IF9nbCR4ci5hZGRFdmVudExpc3RlbmVyKSA9PT0gJ2Z1bmN0aW9uJykgeHIuY29ubmVjdCgpO1xuICAgICAgICBzdGF0ZS5zZXQoe1xuICAgICAgICAgIHhyXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBTZXQgc2hhZG93bWFwXG4gICAgICBpZiAoZ2wuc2hhZG93TWFwKSB7XG4gICAgICAgIGNvbnN0IG9sZEVuYWJsZWQgPSBnbC5zaGFkb3dNYXAuZW5hYmxlZDtcbiAgICAgICAgY29uc3Qgb2xkVHlwZSA9IGdsLnNoYWRvd01hcC50eXBlO1xuICAgICAgICBnbC5zaGFkb3dNYXAuZW5hYmxlZCA9ICEhc2hhZG93cztcbiAgICAgICAgaWYgKGlzLmJvbyhzaGFkb3dzKSkge1xuICAgICAgICAgIGdsLnNoYWRvd01hcC50eXBlID0gVEhSRUUuUENGU29mdFNoYWRvd01hcDtcbiAgICAgICAgfSBlbHNlIGlmIChpcy5zdHIoc2hhZG93cykpIHtcbiAgICAgICAgICB2YXIgX3R5cGVzJHNoYWRvd3M7XG4gICAgICAgICAgY29uc3QgdHlwZXMgPSB7XG4gICAgICAgICAgICBiYXNpYzogVEhSRUUuQmFzaWNTaGFkb3dNYXAsXG4gICAgICAgICAgICBwZXJjZW50YWdlOiBUSFJFRS5QQ0ZTaGFkb3dNYXAsXG4gICAgICAgICAgICBzb2Z0OiBUSFJFRS5QQ0ZTb2Z0U2hhZG93TWFwLFxuICAgICAgICAgICAgdmFyaWFuY2U6IFRIUkVFLlZTTVNoYWRvd01hcFxuICAgICAgICAgIH07XG4gICAgICAgICAgZ2wuc2hhZG93TWFwLnR5cGUgPSAoX3R5cGVzJHNoYWRvd3MgPSB0eXBlc1tzaGFkb3dzXSkgIT0gbnVsbCA/IF90eXBlcyRzaGFkb3dzIDogVEhSRUUuUENGU29mdFNoYWRvd01hcDtcbiAgICAgICAgfSBlbHNlIGlmIChpcy5vYmooc2hhZG93cykpIHtcbiAgICAgICAgICBPYmplY3QuYXNzaWduKGdsLnNoYWRvd01hcCwgc2hhZG93cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9sZEVuYWJsZWQgIT09IGdsLnNoYWRvd01hcC5lbmFibGVkIHx8IG9sZFR5cGUgIT09IGdsLnNoYWRvd01hcC50eXBlKSBnbC5zaGFkb3dNYXAubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBTYWZlbHkgc2V0IGNvbG9yIG1hbmFnZW1lbnQgaWYgYXZhaWxhYmxlLlxuICAgICAgLy8gQXZvaWQgYWNjZXNzaW5nIFRIUkVFLkNvbG9yTWFuYWdlbWVudCB0byBwbGF5IG5pY2Ugd2l0aCBvbGRlciB2ZXJzaW9uc1xuICAgICAgY29uc3QgQ29sb3JNYW5hZ2VtZW50ID0gZ2V0Q29sb3JNYW5hZ2VtZW50KCk7XG4gICAgICBpZiAoQ29sb3JNYW5hZ2VtZW50KSB7XG4gICAgICAgIGlmICgnZW5hYmxlZCcgaW4gQ29sb3JNYW5hZ2VtZW50KSBDb2xvck1hbmFnZW1lbnQuZW5hYmxlZCA9ICFsZWdhY3k7ZWxzZSBpZiAoJ2xlZ2FjeU1vZGUnIGluIENvbG9yTWFuYWdlbWVudCkgQ29sb3JNYW5hZ2VtZW50LmxlZ2FjeU1vZGUgPSBsZWdhY3k7XG4gICAgICB9XG5cbiAgICAgIC8vIFNldCBjb2xvciBzcGFjZSBhbmQgdG9uZW1hcHBpbmcgcHJlZmVyZW5jZXNcbiAgICAgIGNvbnN0IExpbmVhckVuY29kaW5nID0gMzAwMDtcbiAgICAgIGNvbnN0IHNSR0JFbmNvZGluZyA9IDMwMDE7XG4gICAgICBhcHBseVByb3BzKGdsLCB7XG4gICAgICAgIG91dHB1dEVuY29kaW5nOiBsaW5lYXIgPyBMaW5lYXJFbmNvZGluZyA6IHNSR0JFbmNvZGluZyxcbiAgICAgICAgdG9uZU1hcHBpbmc6IGZsYXQgPyBUSFJFRS5Ob1RvbmVNYXBwaW5nIDogVEhSRUUuQUNFU0ZpbG1pY1RvbmVNYXBwaW5nXG4gICAgICB9KTtcblxuICAgICAgLy8gVXBkYXRlIGNvbG9yIG1hbmFnZW1lbnQgc3RhdGVcbiAgICAgIGlmIChzdGF0ZS5sZWdhY3kgIT09IGxlZ2FjeSkgc3RhdGUuc2V0KCgpID0+ICh7XG4gICAgICAgIGxlZ2FjeVxuICAgICAgfSkpO1xuICAgICAgaWYgKHN0YXRlLmxpbmVhciAhPT0gbGluZWFyKSBzdGF0ZS5zZXQoKCkgPT4gKHtcbiAgICAgICAgbGluZWFyXG4gICAgICB9KSk7XG4gICAgICBpZiAoc3RhdGUuZmxhdCAhPT0gZmxhdCkgc3RhdGUuc2V0KCgpID0+ICh7XG4gICAgICAgIGZsYXRcbiAgICAgIH0pKTtcblxuICAgICAgLy8gU2V0IGdsIHByb3BzXG4gICAgICBpZiAoZ2xDb25maWcgJiYgIWlzLmZ1bihnbENvbmZpZykgJiYgIWlzUmVuZGVyZXIoZ2xDb25maWcpICYmICFpcy5lcXUoZ2xDb25maWcsIGdsLCBzaGFsbG93TG9vc2UpKSBhcHBseVByb3BzKGdsLCBnbENvbmZpZyk7XG4gICAgICAvLyBTdG9yZSBldmVudHMgaW50ZXJuYWxseVxuICAgICAgaWYgKGV2ZW50cyAmJiAhc3RhdGUuZXZlbnRzLmhhbmRsZXJzKSBzdGF0ZS5zZXQoe1xuICAgICAgICBldmVudHM6IGV2ZW50cyhzdG9yZSlcbiAgICAgIH0pO1xuICAgICAgLy8gQ2hlY2sgc2l6ZSwgYWxsb3cgaXQgdG8gdGFrZSBvbiBjb250YWluZXIgYm91bmRzIGluaXRpYWxseVxuICAgICAgY29uc3Qgc2l6ZSA9IGNvbXB1dGVJbml0aWFsU2l6ZShjYW52YXMsIHByb3BzU2l6ZSk7XG4gICAgICBpZiAoIWlzLmVxdShzaXplLCBzdGF0ZS5zaXplLCBzaGFsbG93TG9vc2UpKSB7XG4gICAgICAgIHN0YXRlLnNldFNpemUoc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQsIHNpemUudXBkYXRlU3R5bGUsIHNpemUudG9wLCBzaXplLmxlZnQpO1xuICAgICAgfVxuICAgICAgLy8gQ2hlY2sgcGl4ZWxyYXRpb1xuICAgICAgaWYgKGRwciAmJiBzdGF0ZS52aWV3cG9ydC5kcHIgIT09IGNhbGN1bGF0ZURwcihkcHIpKSBzdGF0ZS5zZXREcHIoZHByKTtcbiAgICAgIC8vIENoZWNrIGZyYW1lbG9vcFxuICAgICAgaWYgKHN0YXRlLmZyYW1lbG9vcCAhPT0gZnJhbWVsb29wKSBzdGF0ZS5zZXRGcmFtZWxvb3AoZnJhbWVsb29wKTtcbiAgICAgIC8vIENoZWNrIHBvaW50ZXIgbWlzc2VkXG4gICAgICBpZiAoIXN0YXRlLm9uUG9pbnRlck1pc3NlZCkgc3RhdGUuc2V0KHtcbiAgICAgICAgb25Qb2ludGVyTWlzc2VkXG4gICAgICB9KTtcbiAgICAgIC8vIENoZWNrIHBlcmZvcm1hbmNlXG4gICAgICBpZiAocGVyZm9ybWFuY2UgJiYgIWlzLmVxdShwZXJmb3JtYW5jZSwgc3RhdGUucGVyZm9ybWFuY2UsIHNoYWxsb3dMb29zZSkpIHN0YXRlLnNldChzdGF0ZSA9PiAoe1xuICAgICAgICBwZXJmb3JtYW5jZToge1xuICAgICAgICAgIC4uLnN0YXRlLnBlcmZvcm1hbmNlLFxuICAgICAgICAgIC4uLnBlcmZvcm1hbmNlXG4gICAgICAgIH1cbiAgICAgIH0pKTtcblxuICAgICAgLy8gU2V0IGxvY2Fsc1xuICAgICAgb25DcmVhdGVkID0gb25DcmVhdGVkQ2FsbGJhY2s7XG4gICAgICBjb25maWd1cmVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgcmVuZGVyKGNoaWxkcmVuKSB7XG4gICAgICAvLyBUaGUgcm9vdCBoYXMgdG8gYmUgY29uZmlndXJlZCBiZWZvcmUgaXQgY2FuIGJlIHJlbmRlcmVkXG4gICAgICBpZiAoIWNvbmZpZ3VyZWQpIHRoaXMuY29uZmlndXJlKCk7XG4gICAgICByZWNvbmNpbGVyLnVwZGF0ZUNvbnRhaW5lciggLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUHJvdmlkZXIsIHtcbiAgICAgICAgc3RvcmU6IHN0b3JlLFxuICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgICAgIG9uQ3JlYXRlZDogb25DcmVhdGVkLFxuICAgICAgICByb290RWxlbWVudDogY2FudmFzXG4gICAgICB9KSwgZmliZXIsIG51bGwsICgpID0+IHVuZGVmaW5lZCk7XG4gICAgICByZXR1cm4gc3RvcmU7XG4gICAgfSxcbiAgICB1bm1vdW50KCkge1xuICAgICAgdW5tb3VudENvbXBvbmVudEF0Tm9kZShjYW52YXMpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHJlbmRlcihjaGlsZHJlbiwgY2FudmFzLCBjb25maWcpIHtcbiAgY29uc29sZS53YXJuKCdSM0YucmVuZGVyIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQgaW4gUmVhY3QgMTguIFVzZSBjcmVhdGVSb290IGluc3RlYWQhJyk7XG4gIGNvbnN0IHJvb3QgPSBjcmVhdGVSb290KGNhbnZhcyk7XG4gIHJvb3QuY29uZmlndXJlKGNvbmZpZyk7XG4gIHJldHVybiByb290LnJlbmRlcihjaGlsZHJlbik7XG59XG5mdW5jdGlvbiBQcm92aWRlcih7XG4gIHN0b3JlLFxuICBjaGlsZHJlbixcbiAgb25DcmVhdGVkLFxuICByb290RWxlbWVudFxufSkge1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBzdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgLy8gRmxhZyB0aGUgY2FudmFzIGFjdGl2ZSwgcmVuZGVyaW5nIHdpbGwgbm93IGJlZ2luXG4gICAgc3RhdGUuc2V0KHN0YXRlID0+ICh7XG4gICAgICBpbnRlcm5hbDoge1xuICAgICAgICAuLi5zdGF0ZS5pbnRlcm5hbCxcbiAgICAgICAgYWN0aXZlOiB0cnVlXG4gICAgICB9XG4gICAgfSkpO1xuICAgIC8vIE5vdGlmaXkgdGhhdCBpbml0IGlzIGNvbXBsZXRlZCwgdGhlIHNjZW5lIGdyYXBoIGV4aXN0cywgYnV0IG5vdGhpbmcgaGFzIHlldCByZW5kZXJlZFxuICAgIGlmIChvbkNyZWF0ZWQpIG9uQ3JlYXRlZChzdGF0ZSk7XG4gICAgLy8gQ29ubmVjdCBldmVudHMgdG8gdGhlIHRhcmdldHMgcGFyZW50LCB0aGlzIGlzIGRvbmUgdG8gZW5zdXJlIGV2ZW50cyBhcmUgcmVnaXN0ZXJlZCBvblxuICAgIC8vIGEgc2hhcmVkIHRhcmdldCwgYW5kIG5vdCBvbiB0aGUgY2FudmFzIGl0c2VsZlxuICAgIGlmICghc3RvcmUuZ2V0U3RhdGUoKS5ldmVudHMuY29ubmVjdGVkKSBzdGF0ZS5ldmVudHMuY29ubmVjdCA9PSBudWxsID8gdm9pZCAwIDogc3RhdGUuZXZlbnRzLmNvbm5lY3Qocm9vdEVsZW1lbnQpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgfSwgW10pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoY29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBzdG9yZVxuICB9LCBjaGlsZHJlbik7XG59XG5mdW5jdGlvbiB1bm1vdW50Q29tcG9uZW50QXROb2RlKGNhbnZhcywgY2FsbGJhY2spIHtcbiAgY29uc3Qgcm9vdCA9IHJvb3RzLmdldChjYW52YXMpO1xuICBjb25zdCBmaWJlciA9IHJvb3QgPT0gbnVsbCA/IHZvaWQgMCA6IHJvb3QuZmliZXI7XG4gIGlmIChmaWJlcikge1xuICAgIGNvbnN0IHN0YXRlID0gcm9vdCA9PSBudWxsID8gdm9pZCAwIDogcm9vdC5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgIGlmIChzdGF0ZSkgc3RhdGUuaW50ZXJuYWwuYWN0aXZlID0gZmFsc2U7XG4gICAgcmVjb25jaWxlci51cGRhdGVDb250YWluZXIobnVsbCwgZmliZXIsIG51bGwsICgpID0+IHtcbiAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIF9zdGF0ZSRnbCwgX3N0YXRlJGdsJHJlbmRlckxpc3RzLCBfc3RhdGUkZ2wyLCBfc3RhdGUkZ2wzO1xuICAgICAgICAgICAgc3RhdGUuZXZlbnRzLmRpc2Nvbm5lY3QgPT0gbnVsbCA/IHZvaWQgMCA6IHN0YXRlLmV2ZW50cy5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAoX3N0YXRlJGdsID0gc3RhdGUuZ2wpID09IG51bGwgPyB2b2lkIDAgOiAoX3N0YXRlJGdsJHJlbmRlckxpc3RzID0gX3N0YXRlJGdsLnJlbmRlckxpc3RzKSA9PSBudWxsID8gdm9pZCAwIDogX3N0YXRlJGdsJHJlbmRlckxpc3RzLmRpc3Bvc2UgPT0gbnVsbCA/IHZvaWQgMCA6IF9zdGF0ZSRnbCRyZW5kZXJMaXN0cy5kaXNwb3NlKCk7XG4gICAgICAgICAgICAoX3N0YXRlJGdsMiA9IHN0YXRlLmdsKSA9PSBudWxsID8gdm9pZCAwIDogX3N0YXRlJGdsMi5mb3JjZUNvbnRleHRMb3NzID09IG51bGwgPyB2b2lkIDAgOiBfc3RhdGUkZ2wyLmZvcmNlQ29udGV4dExvc3MoKTtcbiAgICAgICAgICAgIGlmICgoX3N0YXRlJGdsMyA9IHN0YXRlLmdsKSAhPSBudWxsICYmIF9zdGF0ZSRnbDMueHIpIHN0YXRlLnhyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIGRpc3Bvc2Uoc3RhdGUpO1xuICAgICAgICAgICAgcm9vdHMuZGVsZXRlKGNhbnZhcyk7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKGNhbnZhcyk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLyogLi4uICovXG4gICAgICAgICAgfVxuICAgICAgICB9LCA1MDApO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVQb3J0YWwoY2hpbGRyZW4sIGNvbnRhaW5lciwgc3RhdGUpIHtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFBvcnRhbCwge1xuICAgIGtleTogY29udGFpbmVyLnV1aWQsXG4gICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgIGNvbnRhaW5lcjogY29udGFpbmVyLFxuICAgIHN0YXRlOiBzdGF0ZVxuICB9KTtcbn1cbmZ1bmN0aW9uIFBvcnRhbCh7XG4gIHN0YXRlID0ge30sXG4gIGNoaWxkcmVuLFxuICBjb250YWluZXJcbn0pIHtcbiAgLyoqIFRoaXMgaGFzIHRvIGJlIGEgY29tcG9uZW50IGJlY2F1c2UgaXQgd291bGQgbm90IGJlIGFibGUgdG8gY2FsbCB1c2VUaHJlZS91c2VTdG9yZSBvdGhlcndpc2Ugc2luY2VcbiAgICogIGlmIHRoaXMgaXMgb3VyIGVudmlyb25tZW50LCB0aGVuIHdlIGFyZSBub3QgaW4gcjNmJ3MgcmVuZGVyZXIgYnV0IGluIHJlYWN0LWRvbSwgaXQgd291bGQgdHJpZ2dlclxuICAgKiAgdGhlIFwiUjNGIGhvb2tzIGNhbiBvbmx5IGJlIHVzZWQgd2l0aGluIHRoZSBDYW52YXMgY29tcG9uZW50IVwiIHdhcm5pbmc6XG4gICAqICA8Q2FudmFzPlxuICAgKiAgICB7Y3JlYXRlUG9ydGFsKC4uLil9ICovXG4gIGNvbnN0IHtcbiAgICBldmVudHMsXG4gICAgc2l6ZSxcbiAgICAuLi5yZXN0XG4gIH0gPSBzdGF0ZTtcbiAgY29uc3QgcHJldmlvdXNSb290ID0gdXNlU3RvcmUoKTtcbiAgY29uc3QgW3JheWNhc3Rlcl0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiBuZXcgVEhSRUUuUmF5Y2FzdGVyKCkpO1xuICBjb25zdCBbcG9pbnRlcl0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiBuZXcgVEhSRUUuVmVjdG9yMigpKTtcbiAgY29uc3QgaW5qZWN0ID0gUmVhY3QudXNlQ2FsbGJhY2soKHJvb3RTdGF0ZSwgaW5qZWN0U3RhdGUpID0+IHtcbiAgICBjb25zdCBpbnRlcnNlY3QgPSB7XG4gICAgICAuLi5yb290U3RhdGVcbiAgICB9OyAvLyBhbGwgcHJldiBzdGF0ZSBwcm9wc1xuXG4gICAgLy8gT25seSB0aGUgZmllbGRzIG9mIFwicm9vdFN0YXRlXCIgdGhhdCBkbyBub3QgZGlmZmVyIGZyb20gaW5qZWN0U3RhdGVcbiAgICAvLyBTb21lIHByb3BzIHNob3VsZCBiZSBvZmYtbGltaXRzXG4gICAgLy8gT3RoZXJ3aXNlIGZpbHRlciBvdXQgdGhlIHByb3BzIHRoYXQgYXJlIGRpZmZlcmVudCBhbmQgbGV0IHRoZSBpbmplY3QgbGF5ZXIgdGFrZSBwcmVjZWRlbmNlXG4gICAgT2JqZWN0LmtleXMocm9vdFN0YXRlKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBpZiAoXG4gICAgICAvLyBTb21lIHByb3BzIHNob3VsZCBiZSBvZmYtbGltaXRzXG4gICAgICBwcml2YXRlS2V5cy5pbmNsdWRlcyhrZXkpIHx8XG4gICAgICAvLyBPdGhlcndpc2UgZmlsdGVyIG91dCB0aGUgcHJvcHMgdGhhdCBhcmUgZGlmZmVyZW50IGFuZCBsZXQgdGhlIGluamVjdCBsYXllciB0YWtlIHByZWNlZGVuY2VcbiAgICAgIC8vIFVubGVzcyB0aGUgaW5qZWN0IGxheWVyIHByb3BzIGlzIHVuZGVmaW5lZCwgdGhlbiB3ZSBrZWVwIHRoZSByb290IGxheWVyXG4gICAgICByb290U3RhdGVba2V5XSAhPT0gaW5qZWN0U3RhdGVba2V5XSAmJiBpbmplY3RTdGF0ZVtrZXldKSB7XG4gICAgICAgIGRlbGV0ZSBpbnRlcnNlY3Rba2V5XTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBsZXQgdmlld3BvcnQgPSB1bmRlZmluZWQ7XG4gICAgaWYgKGluamVjdFN0YXRlICYmIHNpemUpIHtcbiAgICAgIGNvbnN0IGNhbWVyYSA9IGluamVjdFN0YXRlLmNhbWVyYTtcbiAgICAgIC8vIENhbGN1bGF0ZSB0aGUgb3ZlcnJpZGUgdmlld3BvcnQsIGlmIHByZXNlbnRcbiAgICAgIHZpZXdwb3J0ID0gcm9vdFN0YXRlLnZpZXdwb3J0LmdldEN1cnJlbnRWaWV3cG9ydChjYW1lcmEsIG5ldyBUSFJFRS5WZWN0b3IzKCksIHNpemUpO1xuICAgICAgLy8gVXBkYXRlIHRoZSBwb3J0YWwgY2FtZXJhLCBpZiBpdCBkaWZmZXJzIGZyb20gdGhlIHByZXZpb3VzIGxheWVyXG4gICAgICBpZiAoY2FtZXJhICE9PSByb290U3RhdGUuY2FtZXJhKSB1cGRhdGVDYW1lcmEoY2FtZXJhLCBzaXplKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIFRoZSBpbnRlcnNlY3QgY29uc2lzdHMgb2YgdGhlIHByZXZpb3VzIHJvb3Qgc3RhdGVcbiAgICAgIC4uLmludGVyc2VjdCxcbiAgICAgIC8vIFBvcnRhbHMgaGF2ZSB0aGVpciBvd24gc2NlbmUsIHdoaWNoIGZvcm1zIHRoZSByb290LCBhIHJheWNhc3RlciBhbmQgYSBwb2ludGVyXG4gICAgICBzY2VuZTogY29udGFpbmVyLFxuICAgICAgcmF5Y2FzdGVyLFxuICAgICAgcG9pbnRlcixcbiAgICAgIG1vdXNlOiBwb2ludGVyLFxuICAgICAgLy8gVGhlaXIgcHJldmlvdXMgcm9vdCBpcyB0aGUgbGF5ZXIgYmVmb3JlIGl0XG4gICAgICBwcmV2aW91c1Jvb3QsXG4gICAgICAvLyBFdmVudHMsIHNpemUgYW5kIHZpZXdwb3J0IGNhbiBiZSBvdmVycmlkZGVuIGJ5IHRoZSBpbmplY3QgbGF5ZXJcbiAgICAgIGV2ZW50czoge1xuICAgICAgICAuLi5yb290U3RhdGUuZXZlbnRzLFxuICAgICAgICAuLi4oaW5qZWN0U3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IGluamVjdFN0YXRlLmV2ZW50cyksXG4gICAgICAgIC4uLmV2ZW50c1xuICAgICAgfSxcbiAgICAgIHNpemU6IHtcbiAgICAgICAgLi4ucm9vdFN0YXRlLnNpemUsXG4gICAgICAgIC4uLnNpemVcbiAgICAgIH0sXG4gICAgICB2aWV3cG9ydDoge1xuICAgICAgICAuLi5yb290U3RhdGUudmlld3BvcnQsXG4gICAgICAgIC4uLnZpZXdwb3J0XG4gICAgICB9LFxuICAgICAgLi4ucmVzdFxuICAgIH07XG4gIH0sIFtzdGF0ZV0pO1xuICBjb25zdCBbdXNlUG9ydGFsU3RvcmVdID0gUmVhY3QudXNlU3RhdGUoKCkgPT4ge1xuICAgIC8vIENyZWF0ZSBhIG1pcnJvcmVkIHN0b3JlLCBiYXNlZCBvbiB0aGUgcHJldmlvdXMgcm9vdCB3aXRoIGEgZmV3IG92ZXJyaWRlcyAuLi5cbiAgICBjb25zdCBwcmV2aW91c1N0YXRlID0gcHJldmlvdXNSb290LmdldFN0YXRlKCk7XG4gICAgY29uc3Qgc3RvcmUgPSBjcmVhdGUoKHNldCwgZ2V0KSA9PiAoe1xuICAgICAgLi4ucHJldmlvdXNTdGF0ZSxcbiAgICAgIHNjZW5lOiBjb250YWluZXIsXG4gICAgICByYXljYXN0ZXIsXG4gICAgICBwb2ludGVyLFxuICAgICAgbW91c2U6IHBvaW50ZXIsXG4gICAgICBwcmV2aW91c1Jvb3QsXG4gICAgICBldmVudHM6IHtcbiAgICAgICAgLi4ucHJldmlvdXNTdGF0ZS5ldmVudHMsXG4gICAgICAgIC4uLmV2ZW50c1xuICAgICAgfSxcbiAgICAgIHNpemU6IHtcbiAgICAgICAgLi4ucHJldmlvdXNTdGF0ZS5zaXplLFxuICAgICAgICAuLi5zaXplXG4gICAgICB9LFxuICAgICAgLi4ucmVzdCxcbiAgICAgIC8vIFNldCBhbmQgZ2V0IHJlZmVyIHRvIHRoaXMgcm9vdC1zdGF0ZVxuICAgICAgc2V0LFxuICAgICAgZ2V0LFxuICAgICAgLy8gTGF5ZXJzIGFyZSBhbGxvd2VkIHRvIG92ZXJyaWRlIGV2ZW50c1xuICAgICAgc2V0RXZlbnRzOiBldmVudHMgPT4gc2V0KHN0YXRlID0+ICh7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBldmVudHM6IHtcbiAgICAgICAgICAuLi5zdGF0ZS5ldmVudHMsXG4gICAgICAgICAgLi4uZXZlbnRzXG4gICAgICAgIH1cbiAgICAgIH0pKVxuICAgIH0pKTtcbiAgICByZXR1cm4gc3RvcmU7XG4gIH0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIFN1YnNjcmliZSB0byBwcmV2aW91cyByb290LXN0YXRlIGFuZCBjb3B5IGNoYW5nZXMgb3ZlciB0byB0aGUgbWlycm9yZWQgcG9ydGFsLXN0YXRlXG4gICAgY29uc3QgdW5zdWIgPSBwcmV2aW91c1Jvb3Quc3Vic2NyaWJlKHByZXYgPT4gdXNlUG9ydGFsU3RvcmUuc2V0U3RhdGUoc3RhdGUgPT4gaW5qZWN0KHByZXYsIHN0YXRlKSkpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB1bnN1YigpO1xuICAgICAgdXNlUG9ydGFsU3RvcmUuZGVzdHJveSgpO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICB1c2VQb3J0YWxTdG9yZS5zZXRTdGF0ZShpbmplY3RTdGF0ZSA9PiBpbmplY3QocHJldmlvdXNSb290LmdldFN0YXRlKCksIGluamVjdFN0YXRlKSk7XG4gIH0sIFtpbmplY3RdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCByZWNvbmNpbGVyLmNyZWF0ZVBvcnRhbCggLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoY29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiB1c2VQb3J0YWxTdG9yZVxuICB9LCBjaGlsZHJlbiksIHVzZVBvcnRhbFN0b3JlLCBudWxsKSk7XG59XG5yZWNvbmNpbGVyLmluamVjdEludG9EZXZUb29scyh7XG4gIGJ1bmRsZVR5cGU6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicgPyAwIDogMSxcbiAgcmVuZGVyZXJQYWNrYWdlTmFtZTogJ0ByZWFjdC10aHJlZS9maWJlcicsXG4gIHZlcnNpb246IFJlYWN0LnZlcnNpb25cbn0pO1xuY29uc3QgYWN0ID0gUmVhY3QudW5zdGFibGVfYWN0O1xuXG5leHBvcnQgeyB1c2VGcmFtZSBhcyBBLCBCbG9jayBhcyBCLCB1c2VHcmFwaCBhcyBDLCB1c2VMb2FkZXIgYXMgRCwgRXJyb3JCb3VuZGFyeSBhcyBFLCB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0IGFzIGEsIGNyZWF0ZVJvb3QgYXMgYiwgY3JlYXRlRXZlbnRzIGFzIGMsIHVubW91bnRDb21wb25lbnRBdE5vZGUgYXMgZCwgZXh0ZW5kIGFzIGUsIGNvbnRleHQgYXMgZiwgY3JlYXRlUG9ydGFsIGFzIGcsIHJlY29uY2lsZXIgYXMgaCwgaXNSZWYgYXMgaSwgYXBwbHlQcm9wcyBhcyBqLCBkaXNwb3NlIGFzIGssIGludmFsaWRhdGUgYXMgbCwgYWR2YW5jZSBhcyBtLCBhZGRFZmZlY3QgYXMgbiwgYWRkQWZ0ZXJFZmZlY3QgYXMgbywgYWRkVGFpbCBhcyBwLCBmbHVzaEdsb2JhbEVmZmVjdHMgYXMgcSwgcmVuZGVyIGFzIHIsIGdldFJvb3RTdGF0ZSBhcyBzLCB0aHJlZVR5cGVzIGFzIHQsIHVzZU11dGFibGVDYWxsYmFjayBhcyB1LCBhY3QgYXMgdiwgcm9vdHMgYXMgdywgdXNlSW5zdGFuY2VIYW5kbGUgYXMgeCwgdXNlU3RvcmUgYXMgeSwgdXNlVGhyZWUgYXMgeiB9O1xuIl0sIm5hbWVzIjpbIlRIUkVFIiwiUmVhY3QiLCJEZWZhdWx0RXZlbnRQcmlvcml0eSIsIkNvbnRpbnVvdXNFdmVudFByaW9yaXR5IiwiRGlzY3JldGVFdmVudFByaW9yaXR5IiwiQ29uY3VycmVudFJvb3QiLCJjcmVhdGUiLCJSZWNvbmNpbGVyIiwidW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjayIsInVuc3RhYmxlX0lkbGVQcmlvcml0eSIsInN1c3BlbmQiLCJwcmVsb2FkIiwiY2xlYXIiLCJ0aHJlZVR5cGVzIiwiT2JqZWN0IiwiZnJlZXplIiwiX19wcm90b19fIiwiY2F0YWxvZ3VlIiwiZXh0ZW5kIiwib2JqZWN0cyIsImFzc2lnbiIsImNyZWF0ZVJlbmRlcmVyIiwiX3Jvb3RzIiwiX2dldEV2ZW50UHJpb3JpdHkiLCJjcmVhdGVJbnN0YW5jZSIsInR5cGUiLCJhcmdzIiwiYXR0YWNoIiwicHJvcHMiLCJyb290IiwibmFtZSIsInRvVXBwZXJDYXNlIiwic2xpY2UiLCJpbnN0YW5jZSIsIm9iamVjdCIsInVuZGVmaW5lZCIsIkVycm9yIiwicHJlcGFyZSIsInByaW1pdGl2ZSIsInRhcmdldCIsIkFycmF5IiwiaXNBcnJheSIsIm1lbW9pemVkUHJvcHMiLCJfX3IzZiIsIkJ1ZmZlckdlb21ldHJ5IiwiTWF0ZXJpYWwiLCJhcHBseVByb3BzJDEiLCJhcHBlbmRDaGlsZCIsInBhcmVudEluc3RhbmNlIiwiY2hpbGQiLCJhZGRlZCIsIl9jaGlsZCRfX3IzZiIsIl9wYXJlbnRJbnN0YW5jZSRfX3IzZiIsImlzT2JqZWN0M0QiLCJhZGQiLCJwdXNoIiwicGFyZW50IiwidXBkYXRlSW5zdGFuY2UiLCJpbnZhbGlkYXRlSW5zdGFuY2UiLCJpbnNlcnRCZWZvcmUiLCJiZWZvcmVDaGlsZCIsIl9jaGlsZCRfX3IzZjIiLCJfcGFyZW50SW5zdGFuY2UkX19yM2YyIiwiZGlzcGF0Y2hFdmVudCIsInJlc3RTaWJsaW5ncyIsImNoaWxkcmVuIiwiZmlsdGVyIiwic2libGluZyIsImluZGV4IiwiaW5kZXhPZiIsInJlbW92ZVJlY3Vyc2l2ZSIsImFycmF5IiwiZGlzcG9zZSIsImZvckVhY2giLCJyZW1vdmVDaGlsZCIsIl9wYXJlbnRJbnN0YW5jZSRfX3IzZjMiLCJfY2hpbGQkX19yM2YzIiwiX2NoaWxkJF9fcjNmNSIsIngiLCJkZXRhY2giLCJfY2hpbGQkX19yM2Y0IiwicmVtb3ZlIiwicmVtb3ZlSW50ZXJhY3Rpdml0eSIsImlzUHJpbWl0aXZlIiwic2hvdWxkRGlzcG9zZSIsIl9jaGlsZCRfX3IzZjYiLCJlIiwic3dpdGNoSW5zdGFuY2UiLCJuZXdQcm9wcyIsImZpYmVyIiwiX2luc3RhbmNlJF9fcjNmIiwibmV3SW5zdGFuY2UiLCJhdXRvUmVtb3ZlZEJlZm9yZUFwcGVuZCIsInJheWNhc3QiLCJldmVudENvdW50Iiwicm9vdFN0YXRlIiwiZ2V0U3RhdGUiLCJpbnRlcm5hbCIsImludGVyYWN0aW9uIiwiYWx0ZXJuYXRlIiwic3RhdGVOb2RlIiwicmVmIiwiY3VycmVudCIsImhhbmRsZVRleHRJbnN0YW5jZSIsImNvbnNvbGUiLCJ3YXJuIiwicmVjb25jaWxlciIsImFwcGVuZEluaXRpYWxDaGlsZCIsInN1cHBvcnRzTXV0YXRpb24iLCJpc1ByaW1hcnlSZW5kZXJlciIsInN1cHBvcnRzUGVyc2lzdGVuY2UiLCJzdXBwb3J0c0h5ZHJhdGlvbiIsIm5vVGltZW91dCIsImFwcGVuZENoaWxkVG9Db250YWluZXIiLCJjb250YWluZXIiLCJzY2VuZSIsInJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lciIsImluc2VydEluQ29udGFpbmVyQmVmb3JlIiwiZ2V0Um9vdEhvc3RDb250ZXh0IiwiZ2V0Q2hpbGRIb3N0Q29udGV4dCIsInBhcmVudEhvc3RDb250ZXh0IiwiZmluYWxpemVJbml0aWFsQ2hpbGRyZW4iLCJfaW5zdGFuY2UkX19yM2YyIiwibG9jYWxTdGF0ZSIsIkJvb2xlYW4iLCJoYW5kbGVycyIsInByZXBhcmVVcGRhdGUiLCJfdHlwZSIsIm9sZFByb3BzIiwiX2luc3RhbmNlJF9fcjNmMyIsImFyZ3NOZXciLCJjTiIsInJlc3ROZXciLCJhcmdzT2xkIiwiY08iLCJyZXN0T2xkIiwic29tZSIsInZhbHVlIiwiZGlmZiIsImRpZmZQcm9wcyIsImNoYW5nZXMiLCJsZW5ndGgiLCJjb21taXRVcGRhdGUiLCJyZWNvbnN0cnVjdCIsIl9vbGRQcm9wcyIsImNvbW1pdE1vdW50IiwiX3Byb3BzIiwiX2ludCIsIl9pbnN0YW5jZSRfX3IzZjQiLCJnZXRQdWJsaWNJbnN0YW5jZSIsInByZXBhcmVGb3JDb21taXQiLCJwcmVwYXJlUG9ydGFsTW91bnQiLCJyZXNldEFmdGVyQ29tbWl0Iiwic2hvdWxkU2V0VGV4dENvbnRlbnQiLCJjbGVhckNvbnRhaW5lciIsImhpZGVJbnN0YW5jZSIsIl9pbnN0YW5jZSRfX3IzZjUiLCJ2aXNpYmxlIiwidW5oaWRlSW5zdGFuY2UiLCJfaW5zdGFuY2UkX19yM2Y2IiwiY3JlYXRlVGV4dEluc3RhbmNlIiwiaGlkZVRleHRJbnN0YW5jZSIsInVuaGlkZVRleHRJbnN0YW5jZSIsImdldEN1cnJlbnRFdmVudFByaW9yaXR5IiwiYmVmb3JlQWN0aXZlSW5zdGFuY2VCbHVyIiwiYWZ0ZXJBY3RpdmVJbnN0YW5jZUJsdXIiLCJkZXRhY2hEZWxldGVkSW5zdGFuY2UiLCJub3ciLCJwZXJmb3JtYW5jZSIsImlzIiwiZnVuIiwiRGF0ZSIsInNjaGVkdWxlVGltZW91dCIsInNldFRpbWVvdXQiLCJjYW5jZWxUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwiYXBwbHlQcm9wcyIsIl93aW5kb3ckZG9jdW1lbnQiLCJfd2luZG93JG5hdmlnYXRvciIsImhhc0NvbG9yU3BhY2UiLCJnZXRDb2xvck1hbmFnZW1lbnQiLCJfQ29sb3JNYW5hZ2VtZW50IiwiQ29sb3JNYW5hZ2VtZW50IiwiaXNPcnRob2dyYXBoaWNDYW1lcmEiLCJkZWYiLCJpc1JlZiIsIm9iaiIsImhhc093blByb3BlcnR5IiwidXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCIsIndpbmRvdyIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsIm5hdmlnYXRvciIsInByb2R1Y3QiLCJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VFZmZlY3QiLCJ1c2VNdXRhYmxlQ2FsbGJhY2siLCJmbiIsInVzZVJlZiIsIkJsb2NrIiwic2V0IiwiUHJvbWlzZSIsIkVycm9yQm91bmRhcnkiLCJDb21wb25lbnQiLCJjb25zdHJ1Y3RvciIsInN0YXRlIiwiZXJyb3IiLCJjb21wb25lbnREaWRDYXRjaCIsImVyciIsInJlbmRlciIsImdldERlcml2ZWRTdGF0ZUZyb21FcnJvciIsIkRFRkFVTFQiLCJERUZBVUxUUyIsIk1hcCIsImlzRGlmZlNldCIsIm1lbW9pemVkIiwiY2FsY3VsYXRlRHByIiwiZHByIiwiX3dpbmRvdyRkZXZpY2VQaXhlbFJhIiwiZGV2aWNlUGl4ZWxSYXRpbyIsIk1hdGgiLCJtaW4iLCJtYXgiLCJnZXRSb290U3RhdGUiLCJfcjNmIiwiYSIsImFyciIsInN0ciIsIm51bSIsImJvbyIsInVuZCIsImVxdSIsImIiLCJhcnJheXMiLCJzdHJpY3QiLCJpc09iaiIsImlzQXJyIiwiaSIsImtleXMiLCJidWlsZEdyYXBoIiwiZGF0YSIsIm5vZGVzIiwibWF0ZXJpYWxzIiwidHJhdmVyc2UiLCJtYXRlcmlhbCIsInAiLCJwcmV2aW91c0F0dGFjaCIsInJlc29sdmUiLCJrZXkiLCJpbmNsdWRlcyIsImVudHJpZXMiLCJzcGxpdCIsImxhc3QiLCJwb3AiLCJyZWR1Y2UiLCJhY2MiLCJJTkRFWF9SRUdFWCIsInRlc3QiLCJyZXBsYWNlIiwicHJldmlvdXMiLCJrTiIsInJOIiwiY1AiLCJrUCIsInJQIiwicHJldmlvdXNLZXlzIiwidW5zaGlmdCIsInByb3AiLCJzdGFydHNXaXRoIiwiX3Jvb3QkZ2V0U3RhdGUiLCJwcmV2SGFuZGxlcnMiLCJpc0V2ZW50Iiwic1JHQkVuY29kaW5nIiwiU1JHQkNvbG9yU3BhY2UiLCJMaW5lYXJTUkdCQ29sb3JTcGFjZSIsImN1cnJlbnRJbnN0YW5jZSIsInRhcmdldFByb3AiLCJyZXZlcnNlRW50cmllcyIsInJldmVyc2UiLCJjdG9yIiwiZ2V0IiwiY29weSIsIkxheWVycyIsImZyb21BcnJheSIsImlzQ29sb3IiLCJDb2xvciIsInNldFNjYWxhciIsIm1hc2siLCJsaW5lYXIiLCJjb252ZXJ0U1JHQlRvTGluZWFyIiwiVGV4dHVyZSIsImZvcm1hdCIsIlJHQkFGb3JtYXQiLCJVbnNpZ25lZEJ5dGVUeXBlIiwidGV4dHVyZSIsImdsIiwiY29sb3JTcGFjZSIsIm91dHB1dENvbG9yU3BhY2UiLCJlbmNvZGluZyIsIm91dHB1dEVuY29kaW5nIiwic3BsaWNlIiwiaXNDaXJjdWxhciIsIl9pbnN0YW5jZSRfX3IzZjUkcm9vdCIsImZyYW1lcyIsImludmFsaWRhdGUiLCJvblVwZGF0ZSIsInVwZGF0ZUNhbWVyYSIsImNhbWVyYSIsInNpemUiLCJtYW51YWwiLCJsZWZ0Iiwid2lkdGgiLCJyaWdodCIsInRvcCIsImhlaWdodCIsImJvdHRvbSIsImFzcGVjdCIsInVwZGF0ZVByb2plY3Rpb25NYXRyaXgiLCJ1cGRhdGVNYXRyaXhXb3JsZCIsIm1ha2VJZCIsImV2ZW50IiwiZXZlbnRPYmplY3QiLCJ1dWlkIiwiaW5zdGFuY2VJZCIsImdldEV2ZW50UHJpb3JpdHkiLCJfZ2xvYmFsU2NvcGUkZXZlbnQiLCJnbG9iYWxTY29wZSIsInNlbGYiLCJyZWxlYXNlSW50ZXJuYWxQb2ludGVyQ2FwdHVyZSIsImNhcHR1cmVkTWFwIiwiY2FwdHVyZXMiLCJwb2ludGVySWQiLCJjYXB0dXJlRGF0YSIsImRlbGV0ZSIsInJlbGVhc2VQb2ludGVyQ2FwdHVyZSIsInN0b3JlIiwibyIsImluaXRpYWxIaXRzIiwiaG92ZXJlZCIsImNyZWF0ZUV2ZW50cyIsImNhbGN1bGF0ZURpc3RhbmNlIiwiZHgiLCJvZmZzZXRYIiwiaW5pdGlhbENsaWNrIiwiZHkiLCJvZmZzZXRZIiwicm91bmQiLCJzcXJ0IiwiZmlsdGVyUG9pbnRlckV2ZW50cyIsImludGVyc2VjdCIsImR1cGxpY2F0ZXMiLCJTZXQiLCJpbnRlcnNlY3Rpb25zIiwiZXZlbnRzT2JqZWN0cyIsInJheWNhc3RlciIsInByZXZpb3VzUm9vdCIsImV2ZW50cyIsImNvbXB1dGUiLCJoYW5kbGVSYXljYXN0IiwiZW5hYmxlZCIsIl9zdGF0ZSRwcmV2aW91c1Jvb3QiLCJpbnRlcnNlY3RPYmplY3QiLCJoaXRzIiwiZmxhdE1hcCIsInNvcnQiLCJhU3RhdGUiLCJiU3RhdGUiLCJkaXN0YW5jZSIsInByaW9yaXR5IiwiaXRlbSIsImlkIiwiaGFzIiwiaGl0IiwiX3IzZjIiLCJ2YWx1ZXMiLCJpbnRlcnNlY3Rpb24iLCJoYW5kbGVJbnRlcnNlY3RzIiwiZGVsdGEiLCJjYWxsYmFjayIsInN0b3BwZWQiLCJwb2ludGVyIiwidW5wcm9qZWN0ZWRQb2ludCIsIlZlY3RvcjMiLCJ5IiwidW5wcm9qZWN0IiwiaGFzUG9pbnRlckNhcHR1cmUiLCJfaW50ZXJuYWwkY2FwdHVyZWRNYXAiLCJfaW50ZXJuYWwkY2FwdHVyZWRNYXAyIiwic2V0UG9pbnRlckNhcHR1cmUiLCJleHRyYWN0RXZlbnRQcm9wcyIsInByb3BlcnR5IiwicmF5Y2FzdEV2ZW50IiwicmF5Iiwic3RvcFByb3BhZ2F0aW9uIiwiY2FwdHVyZXNGb3JQb2ludGVyIiwiZnJvbSIsImZpbmQiLCJoaWdoZXIiLCJjYW5jZWxQb2ludGVyIiwiY3VycmVudFRhcmdldCIsIm5hdGl2ZUV2ZW50IiwiaG92ZXJlZE9iaiIsIm9uUG9pbnRlck91dCIsIm9uUG9pbnRlckxlYXZlIiwicG9pbnRlck1pc3NlZCIsIm9uUG9pbnRlck1pc3NlZCIsImhhbmRsZVBvaW50ZXIiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJoYW5kbGVFdmVudCIsImxhc3RFdmVudCIsImlzUG9pbnRlck1vdmUiLCJpc0NsaWNrRXZlbnQiLCJtYXAiLCJvbkludGVyc2VjdCIsIm9uUG9pbnRlck92ZXIiLCJvblBvaW50ZXJFbnRlciIsImhvdmVyZWRJdGVtIiwib25Qb2ludGVyTW92ZSIsImhhbmRsZXIiLCJwcml2YXRlS2V5cyIsImlzUmVuZGVyZXIiLCJjb250ZXh0IiwiY3JlYXRlQ29udGV4dCIsImNyZWF0ZVN0b3JlIiwiYWR2YW5jZSIsInBvc2l0aW9uIiwiZGVmYXVsdFRhcmdldCIsInRlbXBUYXJnZXQiLCJnZXRDdXJyZW50Vmlld3BvcnQiLCJnZXRXb3JsZFBvc2l0aW9uIiwiZGlzdGFuY2VUbyIsInpvb20iLCJmYWN0b3IiLCJmb3YiLCJQSSIsImgiLCJ0YW4iLCJ3IiwicGVyZm9ybWFuY2VUaW1lb3V0Iiwic2V0UGVyZm9ybWFuY2VDdXJyZW50IiwiVmVjdG9yMiIsImNvbm5lY3RlZCIsInhyIiwidGltZXN0YW1wIiwicnVuR2xvYmFsRWZmZWN0cyIsImxlZ2FjeSIsImZsYXQiLCJjb250cm9scyIsImNsb2NrIiwiQ2xvY2siLCJtb3VzZSIsImZyYW1lbG9vcCIsImRlYm91bmNlIiwicmVncmVzcyIsInVwZGF0ZVN0eWxlIiwidmlld3BvcnQiLCJpbml0aWFsRHByIiwic2V0RXZlbnRzIiwic2V0U2l6ZSIsInNldERwciIsInJlc29sdmVkIiwic2V0RnJhbWVsb29wIiwic3RvcCIsImVsYXBzZWRUaW1lIiwic3RhcnQiLCJhY3RpdmUiLCJjcmVhdGVSZWYiLCJzdWJzY3JpYmVycyIsInN1YnNjcmliZSIsInMiLCJvbGRTaXplIiwib2xkRHByIiwib2xkQ2FtZXJhIiwiX3NpemUkdXBkYXRlU3R5bGUiLCJzZXRQaXhlbFJhdGlvIiwiSFRNTENhbnZhc0VsZW1lbnQiLCJkb21FbGVtZW50IiwiY3JlYXRlU3VicyIsInN1YnMiLCJzdWIiLCJnbG9iYWxFZmZlY3RzIiwiZ2xvYmFsQWZ0ZXJFZmZlY3RzIiwiZ2xvYmFsVGFpbEVmZmVjdHMiLCJhZGRFZmZlY3QiLCJhZGRBZnRlckVmZmVjdCIsImFkZFRhaWwiLCJydW4iLCJlZmZlY3RzIiwiZmx1c2hHbG9iYWxFZmZlY3RzIiwic3Vic2NyaXB0aW9uIiwicmVuZGVyJDEiLCJmcmFtZSIsImdldERlbHRhIiwib2xkVGltZSIsImNyZWF0ZUxvb3AiLCJyb290cyIsInJ1bm5pbmciLCJyZXBlYXQiLCJsb29wIiwiX3N0YXRlJGdsJHhyIiwiaXNQcmVzZW50aW5nIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJfc3RhdGUkZ2wkeHIyIiwidXNlSW5zdGFuY2VIYW5kbGUiLCJ1c2VTdG9yZSIsInVzZUNvbnRleHQiLCJ1c2VUaHJlZSIsInNlbGVjdG9yIiwiZXF1YWxpdHlGbiIsInVzZUZyYW1lIiwicmVuZGVyUHJpb3JpdHkiLCJ1c2VHcmFwaCIsInVzZU1lbW8iLCJsb2FkaW5nRm4iLCJleHRlbnNpb25zIiwib25Qcm9ncmVzcyIsIlByb3RvIiwiaW5wdXQiLCJsb2FkZXIiLCJhbGwiLCJyZXMiLCJyZWplY3QiLCJsb2FkIiwibWVzc2FnZSIsInVzZUxvYWRlciIsInJlc3VsdHMiLCJlcXVhbCIsInNoYWxsb3dMb29zZSIsImNyZWF0ZVJlbmRlcmVySW5zdGFuY2UiLCJjYW52YXMiLCJjdXN0b21SZW5kZXJlciIsIldlYkdMUmVuZGVyZXIiLCJwb3dlclByZWZlcmVuY2UiLCJhbnRpYWxpYXMiLCJhbHBoYSIsImNvbXB1dGVJbml0aWFsU2l6ZSIsImRlZmF1bHRTaXplIiwicGFyZW50RWxlbWVudCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsIk9mZnNjcmVlbkNhbnZhcyIsImNyZWF0ZVJvb3QiLCJwcmV2Um9vdCIsInByZXZGaWJlciIsInByZXZTdG9yZSIsImxvZ1JlY292ZXJhYmxlRXJyb3IiLCJyZXBvcnRFcnJvciIsImNyZWF0ZUNvbnRhaW5lciIsIm9uQ3JlYXRlZCIsImNvbmZpZ3VyZWQiLCJsYXN0Q2FtZXJhIiwiY29uZmlndXJlIiwiZ2xDb25maWciLCJwcm9wc1NpemUiLCJzY2VuZU9wdGlvbnMiLCJvbkNyZWF0ZWRDYWxsYmFjayIsInNoYWRvd3MiLCJvcnRob2dyYXBoaWMiLCJyYXljYXN0T3B0aW9ucyIsImNhbWVyYU9wdGlvbnMiLCJSYXljYXN0ZXIiLCJwYXJhbXMiLCJvcHRpb25zIiwiaXNDYW1lcmEiLCJDYW1lcmEiLCJPcnRob2dyYXBoaWNDYW1lcmEiLCJQZXJzcGVjdGl2ZUNhbWVyYSIsInoiLCJyb3RhdGlvbiIsImxvb2tBdCIsIlNjZW5lIiwiX2dsJHhyIiwiaGFuZGxlWFJGcmFtZSIsImhhbmRsZVNlc3Npb25DaGFuZ2UiLCJzZXRBbmltYXRpb25Mb29wIiwiY29ubmVjdCIsImFkZEV2ZW50TGlzdGVuZXIiLCJkaXNjb25uZWN0IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInNoYWRvd01hcCIsIm9sZEVuYWJsZWQiLCJvbGRUeXBlIiwiUENGU29mdFNoYWRvd01hcCIsIl90eXBlcyRzaGFkb3dzIiwidHlwZXMiLCJiYXNpYyIsIkJhc2ljU2hhZG93TWFwIiwicGVyY2VudGFnZSIsIlBDRlNoYWRvd01hcCIsInNvZnQiLCJ2YXJpYW5jZSIsIlZTTVNoYWRvd01hcCIsIm5lZWRzVXBkYXRlIiwibGVnYWN5TW9kZSIsIkxpbmVhckVuY29kaW5nIiwidG9uZU1hcHBpbmciLCJOb1RvbmVNYXBwaW5nIiwiQUNFU0ZpbG1pY1RvbmVNYXBwaW5nIiwidXBkYXRlQ29udGFpbmVyIiwiUHJvdmlkZXIiLCJyb290RWxlbWVudCIsInVubW91bnQiLCJ1bm1vdW50Q29tcG9uZW50QXROb2RlIiwiY29uZmlnIiwiX3N0YXRlJGdsIiwiX3N0YXRlJGdsJHJlbmRlckxpc3RzIiwiX3N0YXRlJGdsMiIsIl9zdGF0ZSRnbDMiLCJyZW5kZXJMaXN0cyIsImZvcmNlQ29udGV4dExvc3MiLCJjcmVhdGVQb3J0YWwiLCJQb3J0YWwiLCJyZXN0IiwidXNlU3RhdGUiLCJpbmplY3QiLCJ1c2VDYWxsYmFjayIsImluamVjdFN0YXRlIiwidXNlUG9ydGFsU3RvcmUiLCJwcmV2aW91c1N0YXRlIiwidW5zdWIiLCJwcmV2Iiwic2V0U3RhdGUiLCJkZXN0cm95IiwiRnJhZ21lbnQiLCJpbmplY3RJbnRvRGV2VG9vbHMiLCJidW5kbGVUeXBlIiwicHJvY2VzcyIsInJlbmRlcmVyUGFja2FnZU5hbWUiLCJ2ZXJzaW9uIiwiYWN0IiwidW5zdGFibGVfYWN0IiwiQSIsIkIiLCJDIiwiRCIsIkUiLCJjIiwiZCIsImYiLCJnIiwiaiIsImsiLCJsIiwibSIsIm4iLCJxIiwiciIsInQiLCJ1IiwidiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/fiber/dist/index-673ef987.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/fiber/dist/react-three-fiber.esm.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@react-three/fiber/dist/react-three-fiber.esm.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Canvas: () => (/* binding */ Canvas),\n/* harmony export */   ReactThreeFiber: () => (/* reexport safe */ _index_673ef987_esm_js__WEBPACK_IMPORTED_MODULE_0__.t),\n/* harmony export */   _roots: () => (/* reexport safe */ _index_673ef987_esm_js__WEBPACK_IMPORTED_MODULE_0__.w),\n/* harmony export */   act: () => (/* reexport safe */ _index_673ef987_esm_js__WEBPACK_IMPORTED_MODULE_0__.v),\n/* harmony export */   addAfterEffect: () => (/* reexport safe */ _index_673ef987_esm_js__WEBPACK_IMPORTED_MODULE_0__.o),\n/* harmony export */   addEffect: () => (/* reexport safe */ _index_673ef987_esm_js__WEBPACK_IMPORTED_MODULE_0__.n),\n/* harmony export */   addTail: () => (/* reexport safe */ _index_673ef987_esm_js__WEBPACK_IMPORTED_MODULE_0__.p),\n/* harmony export */   advance: () => (/* reexport safe */ _index_673ef987_esm_js__WEBPACK_IMPORTED_MODULE_0__.m),\n/* harmony export */   applyProps: () => (/* reexport safe */ _index_673ef987_esm_js__WEBPACK_IMPORTED_MODULE_0__.j),\n/* harmony export */   context: () => (/* reexport safe */ _index_673ef987_esm_js__WEBPACK_IMPORTED_MODULE_0__.f),\n/* harmony export */   createEvents: () => (/* reexport safe */ _index_673ef987_esm_js__WEBPACK_IMPORTED_MODULE_0__.c),\n/* harmony export */   createPortal: () => (/* reexport safe */ _index_673ef987_esm_js__WEBPACK_IMPORTED_MODULE_0__.g),\n/* harmony export */   createRoot: () => (/* reexport safe */ _index_673ef987_esm_js__WEBPACK_IMPORTED_MODULE_0__.b),\n/* harmony export */   dispose: () => (/* reexport safe */ _index_673ef987_esm_js__WEBPACK_IMPORTED_MODULE_0__.k),\n/* harmony export */   events: () => (/* binding */ createPointerEvents),\n/* harmony export */   extend: () => (/* reexport safe */ _index_673ef987_esm_js__WEBPACK_IMPORTED_MODULE_0__.e),\n/* harmony export */   flushGlobalEffects: () => (/* reexport safe */ _index_673ef987_esm_js__WEBPACK_IMPORTED_MODULE_0__.q),\n/* harmony export */   getRootState: () => (/* reexport safe */ _index_673ef987_esm_js__WEBPACK_IMPORTED_MODULE_0__.s),\n/* harmony export */   invalidate: () => (/* reexport safe */ _index_673ef987_esm_js__WEBPACK_IMPORTED_MODULE_0__.l),\n/* harmony export */   reconciler: () => (/* reexport safe */ _index_673ef987_esm_js__WEBPACK_IMPORTED_MODULE_0__.h),\n/* harmony export */   render: () => (/* reexport safe */ _index_673ef987_esm_js__WEBPACK_IMPORTED_MODULE_0__.r),\n/* harmony export */   unmountComponentAtNode: () => (/* reexport safe */ _index_673ef987_esm_js__WEBPACK_IMPORTED_MODULE_0__.d),\n/* harmony export */   useFrame: () => (/* reexport safe */ _index_673ef987_esm_js__WEBPACK_IMPORTED_MODULE_0__.A),\n/* harmony export */   useGraph: () => (/* reexport safe */ _index_673ef987_esm_js__WEBPACK_IMPORTED_MODULE_0__.C),\n/* harmony export */   useInstanceHandle: () => (/* reexport safe */ _index_673ef987_esm_js__WEBPACK_IMPORTED_MODULE_0__.x),\n/* harmony export */   useLoader: () => (/* reexport safe */ _index_673ef987_esm_js__WEBPACK_IMPORTED_MODULE_0__.D),\n/* harmony export */   useStore: () => (/* reexport safe */ _index_673ef987_esm_js__WEBPACK_IMPORTED_MODULE_0__.y),\n/* harmony export */   useThree: () => (/* reexport safe */ _index_673ef987_esm_js__WEBPACK_IMPORTED_MODULE_0__.z)\n/* harmony export */ });\n/* harmony import */ var _index_673ef987_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-673ef987.esm.js */ \"(ssr)/./node_modules/@react-three/fiber/dist/index-673ef987.esm.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var react_use_measure__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! react-use-measure */ \"(ssr)/./node_modules/react-use-measure/dist/index.js\");\n/* harmony import */ var its_fine__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! its-fine */ \"(ssr)/./node_modules/its-fine/dist/index.js\");\n/* harmony import */ var react_reconciler_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-reconciler/constants */ \"(ssr)/./node_modules/react-reconciler/constants.js\");\n/* harmony import */ var react_reconciler__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-reconciler */ \"(ssr)/./node_modules/react-reconciler/index.js\");\n/* harmony import */ var react_reconciler__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react_reconciler__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var scheduler__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! scheduler */ \"(ssr)/./node_modules/scheduler/index.js\");\n\n\n\n\n\n\n\n\n\n\n\n\nconst DOM_EVENTS = {\n    onClick: [\n        \"click\",\n        false\n    ],\n    onContextMenu: [\n        \"contextmenu\",\n        false\n    ],\n    onDoubleClick: [\n        \"dblclick\",\n        false\n    ],\n    onWheel: [\n        \"wheel\",\n        true\n    ],\n    onPointerDown: [\n        \"pointerdown\",\n        true\n    ],\n    onPointerUp: [\n        \"pointerup\",\n        true\n    ],\n    onPointerLeave: [\n        \"pointerleave\",\n        true\n    ],\n    onPointerMove: [\n        \"pointermove\",\n        true\n    ],\n    onPointerCancel: [\n        \"pointercancel\",\n        true\n    ],\n    onLostPointerCapture: [\n        \"lostpointercapture\",\n        true\n    ]\n};\n/** Default R3F event manager for web */ function createPointerEvents(store) {\n    const { handlePointer } = (0,_index_673ef987_esm_js__WEBPACK_IMPORTED_MODULE_0__.c)(store);\n    return {\n        priority: 1,\n        enabled: true,\n        compute (event, state, previous) {\n            // https://github.com/pmndrs/react-three-fiber/pull/782\n            // Events trigger outside of canvas when moved, use offsetX/Y by default and allow overrides\n            state.pointer.set(event.offsetX / state.size.width * 2 - 1, -(event.offsetY / state.size.height) * 2 + 1);\n            state.raycaster.setFromCamera(state.pointer, state.camera);\n        },\n        connected: undefined,\n        handlers: Object.keys(DOM_EVENTS).reduce((acc, key)=>({\n                ...acc,\n                [key]: handlePointer(key)\n            }), {}),\n        update: ()=>{\n            var _internal$lastEvent;\n            const { events, internal } = store.getState();\n            if ((_internal$lastEvent = internal.lastEvent) != null && _internal$lastEvent.current && events.handlers) events.handlers.onPointerMove(internal.lastEvent.current);\n        },\n        connect: (target)=>{\n            var _events$handlers;\n            const { set, events } = store.getState();\n            events.disconnect == null ? void 0 : events.disconnect();\n            set((state)=>({\n                    events: {\n                        ...state.events,\n                        connected: target\n                    }\n                }));\n            Object.entries((_events$handlers = events.handlers) != null ? _events$handlers : []).forEach(([name, event])=>{\n                const [eventName, passive] = DOM_EVENTS[name];\n                target.addEventListener(eventName, event, {\n                    passive\n                });\n            });\n        },\n        disconnect: ()=>{\n            const { set, events } = store.getState();\n            if (events.connected) {\n                var _events$handlers2;\n                Object.entries((_events$handlers2 = events.handlers) != null ? _events$handlers2 : []).forEach(([name, event])=>{\n                    if (events && events.connected instanceof HTMLElement) {\n                        const [eventName] = DOM_EVENTS[name];\n                        events.connected.removeEventListener(eventName, event);\n                    }\n                });\n                set((state)=>({\n                        events: {\n                            ...state.events,\n                            connected: undefined\n                        }\n                    }));\n            }\n        }\n    };\n}\nconst CanvasImpl = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2__.forwardRef(function Canvas({ children, fallback, resize, style, gl, events = createPointerEvents, eventSource, eventPrefix, shadows, linear, flat, legacy, orthographic, frameloop, dpr, performance, raycaster, camera, scene, onPointerMissed, onCreated, ...props }, forwardedRef) {\n    // Create a known catalogue of Threejs-native elements\n    // This will include the entire THREE namespace by default, users can extend\n    // their own elements by using the createRoot API instead\n    react__WEBPACK_IMPORTED_MODULE_2__.useMemo(()=>(0,_index_673ef987_esm_js__WEBPACK_IMPORTED_MODULE_0__.e)(three__WEBPACK_IMPORTED_MODULE_6__), []);\n    const Bridge = (0,its_fine__WEBPACK_IMPORTED_MODULE_7__.useContextBridge)();\n    const [containerRef, containerRect] = (0,react_use_measure__WEBPACK_IMPORTED_MODULE_8__[\"default\"])({\n        scroll: true,\n        debounce: {\n            scroll: 50,\n            resize: 0\n        },\n        ...resize\n    });\n    const canvasRef = react__WEBPACK_IMPORTED_MODULE_2__.useRef(null);\n    const divRef = react__WEBPACK_IMPORTED_MODULE_2__.useRef(null);\n    react__WEBPACK_IMPORTED_MODULE_2__.useImperativeHandle(forwardedRef, ()=>canvasRef.current);\n    const handlePointerMissed = (0,_index_673ef987_esm_js__WEBPACK_IMPORTED_MODULE_0__.u)(onPointerMissed);\n    const [block, setBlock] = react__WEBPACK_IMPORTED_MODULE_2__.useState(false);\n    const [error, setError] = react__WEBPACK_IMPORTED_MODULE_2__.useState(false);\n    // Suspend this component if block is a promise (2nd run)\n    if (block) throw block;\n    // Throw exception outwards if anything within canvas throws\n    if (error) throw error;\n    const root = react__WEBPACK_IMPORTED_MODULE_2__.useRef(null);\n    (0,_index_673ef987_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(()=>{\n        const canvas = canvasRef.current;\n        if (containerRect.width > 0 && containerRect.height > 0 && canvas) {\n            if (!root.current) root.current = (0,_index_673ef987_esm_js__WEBPACK_IMPORTED_MODULE_0__.b)(canvas);\n            root.current.configure({\n                gl,\n                events,\n                shadows,\n                linear,\n                flat,\n                legacy,\n                orthographic,\n                frameloop,\n                dpr,\n                performance,\n                raycaster,\n                camera,\n                scene,\n                size: containerRect,\n                // Pass mutable reference to onPointerMissed so it's free to update\n                onPointerMissed: (...args)=>handlePointerMissed.current == null ? void 0 : handlePointerMissed.current(...args),\n                onCreated: (state)=>{\n                    // Connect to event source\n                    state.events.connect == null ? void 0 : state.events.connect(eventSource ? (0,_index_673ef987_esm_js__WEBPACK_IMPORTED_MODULE_0__.i)(eventSource) ? eventSource.current : eventSource : divRef.current);\n                    // Set up compute function\n                    if (eventPrefix) {\n                        state.setEvents({\n                            compute: (event, state)=>{\n                                const x = event[eventPrefix + \"X\"];\n                                const y = event[eventPrefix + \"Y\"];\n                                state.pointer.set(x / state.size.width * 2 - 1, -(y / state.size.height) * 2 + 1);\n                                state.raycaster.setFromCamera(state.pointer, state.camera);\n                            }\n                        });\n                    }\n                    // Call onCreated callback\n                    onCreated == null ? void 0 : onCreated(state);\n                }\n            });\n            root.current.render(/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2__.createElement(Bridge, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2__.createElement(_index_673ef987_esm_js__WEBPACK_IMPORTED_MODULE_0__.E, {\n                set: setError\n            }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2__.createElement(react__WEBPACK_IMPORTED_MODULE_2__.Suspense, {\n                fallback: /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2__.createElement(_index_673ef987_esm_js__WEBPACK_IMPORTED_MODULE_0__.B, {\n                    set: setBlock\n                })\n            }, children))));\n        }\n    });\n    react__WEBPACK_IMPORTED_MODULE_2__.useEffect(()=>{\n        const canvas = canvasRef.current;\n        if (canvas) return ()=>(0,_index_673ef987_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(canvas);\n    }, []);\n    // When the event source is not this div, we need to set pointer-events to none\n    // Or else the canvas will block events from reaching the event source\n    const pointerEvents = eventSource ? \"none\" : \"auto\";\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2__.createElement(\"div\", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__[\"default\"])({\n        ref: divRef,\n        style: {\n            position: \"relative\",\n            width: \"100%\",\n            height: \"100%\",\n            overflow: \"hidden\",\n            pointerEvents,\n            ...style\n        }\n    }, props), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2__.createElement(\"div\", {\n        ref: containerRef,\n        style: {\n            width: \"100%\",\n            height: \"100%\"\n        }\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2__.createElement(\"canvas\", {\n        ref: canvasRef,\n        style: {\n            display: \"block\"\n        }\n    }, fallback)));\n});\n/**\n * A DOM canvas which accepts threejs elements as children.\n * @see https://docs.pmnd.rs/react-three-fiber/api/canvas\n */ const Canvas = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2__.forwardRef(function CanvasWrapper(props, ref) {\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2__.createElement(its_fine__WEBPACK_IMPORTED_MODULE_7__.FiberProvider, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2__.createElement(CanvasImpl, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__[\"default\"])({}, props, {\n        ref: ref\n    })));\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2ZpYmVyL2Rpc3QvcmVhY3QtdGhyZWUtZmliZXIuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE0TjtBQUN3UTtBQUMxYTtBQUMzQjtBQUNBO0FBQ1k7QUFDZ0I7QUFDdkI7QUFDbkI7QUFDUztBQUNQO0FBQ0k7QUFFdkIsTUFBTW9FLGFBQWE7SUFDakJDLFNBQVM7UUFBQztRQUFTO0tBQU07SUFDekJDLGVBQWU7UUFBQztRQUFlO0tBQU07SUFDckNDLGVBQWU7UUFBQztRQUFZO0tBQU07SUFDbENDLFNBQVM7UUFBQztRQUFTO0tBQUs7SUFDeEJDLGVBQWU7UUFBQztRQUFlO0tBQUs7SUFDcENDLGFBQWE7UUFBQztRQUFhO0tBQUs7SUFDaENDLGdCQUFnQjtRQUFDO1FBQWdCO0tBQUs7SUFDdENDLGVBQWU7UUFBQztRQUFlO0tBQUs7SUFDcENDLGlCQUFpQjtRQUFDO1FBQWlCO0tBQUs7SUFDeENDLHNCQUFzQjtRQUFDO1FBQXNCO0tBQUs7QUFDcEQ7QUFFQSxzQ0FBc0MsR0FDdEMsU0FBU0Msb0JBQW9CQyxLQUFLO0lBQ2hDLE1BQU0sRUFDSkMsYUFBYSxFQUNkLEdBQUdoRix5REFBWUEsQ0FBQytFO0lBQ2pCLE9BQU87UUFDTEUsVUFBVTtRQUNWQyxTQUFTO1FBQ1RDLFNBQVFDLEtBQUssRUFBRUMsS0FBSyxFQUFFQyxRQUFRO1lBQzVCLHVEQUF1RDtZQUN2RCw0RkFBNEY7WUFDNUZELE1BQU1FLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDSixNQUFNSyxPQUFPLEdBQUdKLE1BQU1LLElBQUksQ0FBQ0MsS0FBSyxHQUFHLElBQUksR0FBRyxDQUFFUCxDQUFBQSxNQUFNUSxPQUFPLEdBQUdQLE1BQU1LLElBQUksQ0FBQ0csTUFBTSxJQUFJLElBQUk7WUFDdkdSLE1BQU1TLFNBQVMsQ0FBQ0MsYUFBYSxDQUFDVixNQUFNRSxPQUFPLEVBQUVG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QU87UUFDaEMsSUFBSXNELFFBQVEsT0FBTyxJQUFNckoseURBQXNCQSxDQUFDcUo7SUFDbEQsR0FBRyxFQUFFO0lBRUwsK0VBQStFO0lBQy9FLHNFQUFzRTtJQUN0RSxNQUFNTyxnQkFBZ0J2QyxjQUFjLFNBQVM7SUFDN0MsT0FBTyxXQUFXLEdBQUV2RSxnREFBbUIsQ0FBQyxPQUFPRCw4RUFBUUEsQ0FBQztRQUN0RGdILEtBQUtqQjtRQUNMekIsT0FBTztZQUNMMkMsVUFBVTtZQUNWbkYsT0FBTztZQUNQRSxRQUFRO1lBQ1JrRixVQUFVO1lBQ1ZIO1lBQ0EsR0FBR3pDLEtBQUs7UUFDVjtJQUNGLEdBQUdlLFFBQVEsV0FBVyxHQUFFcEYsZ0RBQW1CLENBQUMsT0FBTztRQUNqRCtHLEtBQUt2QjtRQUNMbkIsT0FBTztZQUNMeEMsT0FBTztZQUNQRSxRQUFRO1FBQ1Y7SUFDRixHQUFHLFdBQVcsR0FBRS9CLGdEQUFtQixDQUFDLFVBQVU7UUFDNUMrRyxLQUFLbkI7UUFDTHZCLE9BQU87WUFDTDZDLFNBQVM7UUFDWDtJQUNGLEdBQUcvQztBQUNMO0FBRUE7OztDQUdDLEdBQ0QsTUFBTUYsU0FBUyxXQUFXLEdBQUVqRSw2Q0FBZ0IsQ0FBQyxTQUFTbUgsY0FBYy9CLEtBQUssRUFBRTJCLEdBQUc7SUFDNUUsT0FBTyxXQUFXLEdBQUUvRyxnREFBbUIsQ0FBQ0csbURBQWFBLEVBQUUsTUFBTSxXQUFXLEdBQUVILGdEQUFtQixDQUFDK0QsWUFBWWhFLDhFQUFRQSxDQUFDLENBQUMsR0FBR3FGLE9BQU87UUFDNUgyQixLQUFLQTtJQUNQO0FBQ0Y7QUFFaUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teVZScHJvamVjdC8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZmliZXIvZGlzdC9yZWFjdC10aHJlZS1maWJlci5lc20uanM/NzljZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjIGFzIGNyZWF0ZUV2ZW50cywgZSBhcyBleHRlbmQsIHUgYXMgdXNlTXV0YWJsZUNhbGxiYWNrLCBhIGFzIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QsIGIgYXMgY3JlYXRlUm9vdCwgaSBhcyBpc1JlZiwgRSBhcyBFcnJvckJvdW5kYXJ5LCBCIGFzIEJsb2NrLCBkIGFzIHVubW91bnRDb21wb25lbnRBdE5vZGUgfSBmcm9tICcuL2luZGV4LTY3M2VmOTg3LmVzbS5qcyc7XG5leHBvcnQgeyB0IGFzIFJlYWN0VGhyZWVGaWJlciwgdyBhcyBfcm9vdHMsIHYgYXMgYWN0LCBvIGFzIGFkZEFmdGVyRWZmZWN0LCBuIGFzIGFkZEVmZmVjdCwgcCBhcyBhZGRUYWlsLCBtIGFzIGFkdmFuY2UsIGogYXMgYXBwbHlQcm9wcywgZiBhcyBjb250ZXh0LCBjIGFzIGNyZWF0ZUV2ZW50cywgZyBhcyBjcmVhdGVQb3J0YWwsIGIgYXMgY3JlYXRlUm9vdCwgayBhcyBkaXNwb3NlLCBlIGFzIGV4dGVuZCwgcSBhcyBmbHVzaEdsb2JhbEVmZmVjdHMsIHMgYXMgZ2V0Um9vdFN0YXRlLCBsIGFzIGludmFsaWRhdGUsIGggYXMgcmVjb25jaWxlciwgciBhcyByZW5kZXIsIGQgYXMgdW5tb3VudENvbXBvbmVudEF0Tm9kZSwgQSBhcyB1c2VGcmFtZSwgQyBhcyB1c2VHcmFwaCwgeCBhcyB1c2VJbnN0YW5jZUhhbmRsZSwgRCBhcyB1c2VMb2FkZXIsIHkgYXMgdXNlU3RvcmUsIHogYXMgdXNlVGhyZWUgfSBmcm9tICcuL2luZGV4LTY3M2VmOTg3LmVzbS5qcyc7XG5pbXBvcnQgX2V4dGVuZHMgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kcyc7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgKiBhcyBUSFJFRSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgdXNlTWVhc3VyZSBmcm9tICdyZWFjdC11c2UtbWVhc3VyZSc7XG5pbXBvcnQgeyBGaWJlclByb3ZpZGVyLCB1c2VDb250ZXh0QnJpZGdlIH0gZnJvbSAnaXRzLWZpbmUnO1xuaW1wb3J0ICdyZWFjdC1yZWNvbmNpbGVyL2NvbnN0YW50cyc7XG5pbXBvcnQgJ3p1c3RhbmQnO1xuaW1wb3J0ICdyZWFjdC1yZWNvbmNpbGVyJztcbmltcG9ydCAnc2NoZWR1bGVyJztcbmltcG9ydCAnc3VzcGVuZC1yZWFjdCc7XG5cbmNvbnN0IERPTV9FVkVOVFMgPSB7XG4gIG9uQ2xpY2s6IFsnY2xpY2snLCBmYWxzZV0sXG4gIG9uQ29udGV4dE1lbnU6IFsnY29udGV4dG1lbnUnLCBmYWxzZV0sXG4gIG9uRG91YmxlQ2xpY2s6IFsnZGJsY2xpY2snLCBmYWxzZV0sXG4gIG9uV2hlZWw6IFsnd2hlZWwnLCB0cnVlXSxcbiAgb25Qb2ludGVyRG93bjogWydwb2ludGVyZG93bicsIHRydWVdLFxuICBvblBvaW50ZXJVcDogWydwb2ludGVydXAnLCB0cnVlXSxcbiAgb25Qb2ludGVyTGVhdmU6IFsncG9pbnRlcmxlYXZlJywgdHJ1ZV0sXG4gIG9uUG9pbnRlck1vdmU6IFsncG9pbnRlcm1vdmUnLCB0cnVlXSxcbiAgb25Qb2ludGVyQ2FuY2VsOiBbJ3BvaW50ZXJjYW5jZWwnLCB0cnVlXSxcbiAgb25Mb3N0UG9pbnRlckNhcHR1cmU6IFsnbG9zdHBvaW50ZXJjYXB0dXJlJywgdHJ1ZV1cbn07XG5cbi8qKiBEZWZhdWx0IFIzRiBldmVudCBtYW5hZ2VyIGZvciB3ZWIgKi9cbmZ1bmN0aW9uIGNyZWF0ZVBvaW50ZXJFdmVudHMoc3RvcmUpIHtcbiAgY29uc3Qge1xuICAgIGhhbmRsZVBvaW50ZXJcbiAgfSA9IGNyZWF0ZUV2ZW50cyhzdG9yZSk7XG4gIHJldHVybiB7XG4gICAgcHJpb3JpdHk6IDEsXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICBjb21wdXRlKGV2ZW50LCBzdGF0ZSwgcHJldmlvdXMpIHtcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvcmVhY3QtdGhyZWUtZmliZXIvcHVsbC83ODJcbiAgICAgIC8vIEV2ZW50cyB0cmlnZ2VyIG91dHNpZGUgb2YgY2FudmFzIHdoZW4gbW92ZWQsIHVzZSBvZmZzZXRYL1kgYnkgZGVmYXVsdCBhbmQgYWxsb3cgb3ZlcnJpZGVzXG4gICAgICBzdGF0ZS5wb2ludGVyLnNldChldmVudC5vZmZzZXRYIC8gc3RhdGUuc2l6ZS53aWR0aCAqIDIgLSAxLCAtKGV2ZW50Lm9mZnNldFkgLyBzdGF0ZS5zaXplLmhlaWdodCkgKiAyICsgMSk7XG4gICAgICBzdGF0ZS5yYXljYXN0ZXIuc2V0RnJvbUNhbWVyYShzdGF0ZS5wb2ludGVyLCBzdGF0ZS5jYW1lcmEpO1xuICAgIH0sXG4gICAgY29ubmVjdGVkOiB1bmRlZmluZWQsXG4gICAgaGFuZGxlcnM6IE9iamVjdC5rZXlzKERPTV9FVkVOVFMpLnJlZHVjZSgoYWNjLCBrZXkpID0+ICh7XG4gICAgICAuLi5hY2MsXG4gICAgICBba2V5XTogaGFuZGxlUG9pbnRlcihrZXkpXG4gICAgfSksIHt9KSxcbiAgICB1cGRhdGU6ICgpID0+IHtcbiAgICAgIHZhciBfaW50ZXJuYWwkbGFzdEV2ZW50O1xuICAgICAgY29uc3Qge1xuICAgICAgICBldmVudHMsXG4gICAgICAgIGludGVybmFsXG4gICAgICB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgIGlmICgoX2ludGVybmFsJGxhc3RFdmVudCA9IGludGVybmFsLmxhc3RFdmVudCkgIT0gbnVsbCAmJiBfaW50ZXJuYWwkbGFzdEV2ZW50LmN1cnJlbnQgJiYgZXZlbnRzLmhhbmRsZXJzKSBldmVudHMuaGFuZGxlcnMub25Qb2ludGVyTW92ZShpbnRlcm5hbC5sYXN0RXZlbnQuY3VycmVudCk7XG4gICAgfSxcbiAgICBjb25uZWN0OiB0YXJnZXQgPT4ge1xuICAgICAgdmFyIF9ldmVudHMkaGFuZGxlcnM7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHNldCxcbiAgICAgICAgZXZlbnRzXG4gICAgICB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgIGV2ZW50cy5kaXNjb25uZWN0ID09IG51bGwgPyB2b2lkIDAgOiBldmVudHMuZGlzY29ubmVjdCgpO1xuICAgICAgc2V0KHN0YXRlID0+ICh7XG4gICAgICAgIGV2ZW50czoge1xuICAgICAgICAgIC4uLnN0YXRlLmV2ZW50cyxcbiAgICAgICAgICBjb25uZWN0ZWQ6IHRhcmdldFxuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgICBPYmplY3QuZW50cmllcygoX2V2ZW50cyRoYW5kbGVycyA9IGV2ZW50cy5oYW5kbGVycykgIT0gbnVsbCA/IF9ldmVudHMkaGFuZGxlcnMgOiBbXSkuZm9yRWFjaCgoW25hbWUsIGV2ZW50XSkgPT4ge1xuICAgICAgICBjb25zdCBbZXZlbnROYW1lLCBwYXNzaXZlXSA9IERPTV9FVkVOVFNbbmFtZV07XG4gICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgZXZlbnQsIHtcbiAgICAgICAgICBwYXNzaXZlXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBkaXNjb25uZWN0OiAoKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHNldCxcbiAgICAgICAgZXZlbnRzXG4gICAgICB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgIGlmIChldmVudHMuY29ubmVjdGVkKSB7XG4gICAgICAgIHZhciBfZXZlbnRzJGhhbmRsZXJzMjtcbiAgICAgICAgT2JqZWN0LmVudHJpZXMoKF9ldmVudHMkaGFuZGxlcnMyID0gZXZlbnRzLmhhbmRsZXJzKSAhPSBudWxsID8gX2V2ZW50cyRoYW5kbGVyczIgOiBbXSkuZm9yRWFjaCgoW25hbWUsIGV2ZW50XSkgPT4ge1xuICAgICAgICAgIGlmIChldmVudHMgJiYgZXZlbnRzLmNvbm5lY3RlZCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgICAgICBjb25zdCBbZXZlbnROYW1lXSA9IERPTV9FVkVOVFNbbmFtZV07XG4gICAgICAgICAgICBldmVudHMuY29ubmVjdGVkLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBldmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgc2V0KHN0YXRlID0+ICh7XG4gICAgICAgICAgZXZlbnRzOiB7XG4gICAgICAgICAgICAuLi5zdGF0ZS5ldmVudHMsXG4gICAgICAgICAgICBjb25uZWN0ZWQ6IHVuZGVmaW5lZFxuICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuY29uc3QgQ2FudmFzSW1wbCA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIENhbnZhcyh7XG4gIGNoaWxkcmVuLFxuICBmYWxsYmFjayxcbiAgcmVzaXplLFxuICBzdHlsZSxcbiAgZ2wsXG4gIGV2ZW50cyA9IGNyZWF0ZVBvaW50ZXJFdmVudHMsXG4gIGV2ZW50U291cmNlLFxuICBldmVudFByZWZpeCxcbiAgc2hhZG93cyxcbiAgbGluZWFyLFxuICBmbGF0LFxuICBsZWdhY3ksXG4gIG9ydGhvZ3JhcGhpYyxcbiAgZnJhbWVsb29wLFxuICBkcHIsXG4gIHBlcmZvcm1hbmNlLFxuICByYXljYXN0ZXIsXG4gIGNhbWVyYSxcbiAgc2NlbmUsXG4gIG9uUG9pbnRlck1pc3NlZCxcbiAgb25DcmVhdGVkLFxuICAuLi5wcm9wc1xufSwgZm9yd2FyZGVkUmVmKSB7XG4gIC8vIENyZWF0ZSBhIGtub3duIGNhdGFsb2d1ZSBvZiBUaHJlZWpzLW5hdGl2ZSBlbGVtZW50c1xuICAvLyBUaGlzIHdpbGwgaW5jbHVkZSB0aGUgZW50aXJlIFRIUkVFIG5hbWVzcGFjZSBieSBkZWZhdWx0LCB1c2VycyBjYW4gZXh0ZW5kXG4gIC8vIHRoZWlyIG93biBlbGVtZW50cyBieSB1c2luZyB0aGUgY3JlYXRlUm9vdCBBUEkgaW5zdGVhZFxuICBSZWFjdC51c2VNZW1vKCgpID0+IGV4dGVuZChUSFJFRSksIFtdKTtcbiAgY29uc3QgQnJpZGdlID0gdXNlQ29udGV4dEJyaWRnZSgpO1xuICBjb25zdCBbY29udGFpbmVyUmVmLCBjb250YWluZXJSZWN0XSA9IHVzZU1lYXN1cmUoe1xuICAgIHNjcm9sbDogdHJ1ZSxcbiAgICBkZWJvdW5jZToge1xuICAgICAgc2Nyb2xsOiA1MCxcbiAgICAgIHJlc2l6ZTogMFxuICAgIH0sXG4gICAgLi4ucmVzaXplXG4gIH0pO1xuICBjb25zdCBjYW52YXNSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IGRpdlJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgUmVhY3QudXNlSW1wZXJhdGl2ZUhhbmRsZShmb3J3YXJkZWRSZWYsICgpID0+IGNhbnZhc1JlZi5jdXJyZW50KTtcbiAgY29uc3QgaGFuZGxlUG9pbnRlck1pc3NlZCA9IHVzZU11dGFibGVDYWxsYmFjayhvblBvaW50ZXJNaXNzZWQpO1xuICBjb25zdCBbYmxvY2ssIHNldEJsb2NrXSA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XG5cbiAgLy8gU3VzcGVuZCB0aGlzIGNvbXBvbmVudCBpZiBibG9jayBpcyBhIHByb21pc2UgKDJuZCBydW4pXG4gIGlmIChibG9jaykgdGhyb3cgYmxvY2s7XG4gIC8vIFRocm93IGV4Y2VwdGlvbiBvdXR3YXJkcyBpZiBhbnl0aGluZyB3aXRoaW4gY2FudmFzIHRocm93c1xuICBpZiAoZXJyb3IpIHRocm93IGVycm9yO1xuICBjb25zdCByb290ID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWYuY3VycmVudDtcbiAgICBpZiAoY29udGFpbmVyUmVjdC53aWR0aCA+IDAgJiYgY29udGFpbmVyUmVjdC5oZWlnaHQgPiAwICYmIGNhbnZhcykge1xuICAgICAgaWYgKCFyb290LmN1cnJlbnQpIHJvb3QuY3VycmVudCA9IGNyZWF0ZVJvb3QoY2FudmFzKTtcbiAgICAgIHJvb3QuY3VycmVudC5jb25maWd1cmUoe1xuICAgICAgICBnbCxcbiAgICAgICAgZXZlbnRzLFxuICAgICAgICBzaGFkb3dzLFxuICAgICAgICBsaW5lYXIsXG4gICAgICAgIGZsYXQsXG4gICAgICAgIGxlZ2FjeSxcbiAgICAgICAgb3J0aG9ncmFwaGljLFxuICAgICAgICBmcmFtZWxvb3AsXG4gICAgICAgIGRwcixcbiAgICAgICAgcGVyZm9ybWFuY2UsXG4gICAgICAgIHJheWNhc3RlcixcbiAgICAgICAgY2FtZXJhLFxuICAgICAgICBzY2VuZSxcbiAgICAgICAgc2l6ZTogY29udGFpbmVyUmVjdCxcbiAgICAgICAgLy8gUGFzcyBtdXRhYmxlIHJlZmVyZW5jZSB0byBvblBvaW50ZXJNaXNzZWQgc28gaXQncyBmcmVlIHRvIHVwZGF0ZVxuICAgICAgICBvblBvaW50ZXJNaXNzZWQ6ICguLi5hcmdzKSA9PiBoYW5kbGVQb2ludGVyTWlzc2VkLmN1cnJlbnQgPT0gbnVsbCA/IHZvaWQgMCA6IGhhbmRsZVBvaW50ZXJNaXNzZWQuY3VycmVudCguLi5hcmdzKSxcbiAgICAgICAgb25DcmVhdGVkOiBzdGF0ZSA9PiB7XG4gICAgICAgICAgLy8gQ29ubmVjdCB0byBldmVudCBzb3VyY2VcbiAgICAgICAgICBzdGF0ZS5ldmVudHMuY29ubmVjdCA9PSBudWxsID8gdm9pZCAwIDogc3RhdGUuZXZlbnRzLmNvbm5lY3QoZXZlbnRTb3VyY2UgPyBpc1JlZihldmVudFNvdXJjZSkgPyBldmVudFNvdXJjZS5jdXJyZW50IDogZXZlbnRTb3VyY2UgOiBkaXZSZWYuY3VycmVudCk7XG4gICAgICAgICAgLy8gU2V0IHVwIGNvbXB1dGUgZnVuY3Rpb25cbiAgICAgICAgICBpZiAoZXZlbnRQcmVmaXgpIHtcbiAgICAgICAgICAgIHN0YXRlLnNldEV2ZW50cyh7XG4gICAgICAgICAgICAgIGNvbXB1dGU6IChldmVudCwgc3RhdGUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0gZXZlbnRbZXZlbnRQcmVmaXggKyAnWCddO1xuICAgICAgICAgICAgICAgIGNvbnN0IHkgPSBldmVudFtldmVudFByZWZpeCArICdZJ107XG4gICAgICAgICAgICAgICAgc3RhdGUucG9pbnRlci5zZXQoeCAvIHN0YXRlLnNpemUud2lkdGggKiAyIC0gMSwgLSh5IC8gc3RhdGUuc2l6ZS5oZWlnaHQpICogMiArIDEpO1xuICAgICAgICAgICAgICAgIHN0YXRlLnJheWNhc3Rlci5zZXRGcm9tQ2FtZXJhKHN0YXRlLnBvaW50ZXIsIHN0YXRlLmNhbWVyYSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBDYWxsIG9uQ3JlYXRlZCBjYWxsYmFja1xuICAgICAgICAgIG9uQ3JlYXRlZCA9PSBudWxsID8gdm9pZCAwIDogb25DcmVhdGVkKHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByb290LmN1cnJlbnQucmVuZGVyKCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChCcmlkZ2UsIG51bGwsIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEVycm9yQm91bmRhcnksIHtcbiAgICAgICAgc2V0OiBzZXRFcnJvclxuICAgICAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuU3VzcGVuc2UsIHtcbiAgICAgICAgZmFsbGJhY2s6IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEJsb2NrLCB7XG4gICAgICAgICAgc2V0OiBzZXRCbG9ja1xuICAgICAgICB9KVxuICAgICAgfSwgY2hpbGRyZW4pKSkpO1xuICAgIH1cbiAgfSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnQ7XG4gICAgaWYgKGNhbnZhcykgcmV0dXJuICgpID0+IHVubW91bnRDb21wb25lbnRBdE5vZGUoY2FudmFzKTtcbiAgfSwgW10pO1xuXG4gIC8vIFdoZW4gdGhlIGV2ZW50IHNvdXJjZSBpcyBub3QgdGhpcyBkaXYsIHdlIG5lZWQgdG8gc2V0IHBvaW50ZXItZXZlbnRzIHRvIG5vbmVcbiAgLy8gT3IgZWxzZSB0aGUgY2FudmFzIHdpbGwgYmxvY2sgZXZlbnRzIGZyb20gcmVhY2hpbmcgdGhlIGV2ZW50IHNvdXJjZVxuICBjb25zdCBwb2ludGVyRXZlbnRzID0gZXZlbnRTb3VyY2UgPyAnbm9uZScgOiAnYXV0byc7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBfZXh0ZW5kcyh7XG4gICAgcmVmOiBkaXZSZWYsXG4gICAgc3R5bGU6IHtcbiAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgIGhlaWdodDogJzEwMCUnLFxuICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICAgcG9pbnRlckV2ZW50cyxcbiAgICAgIC4uLnN0eWxlXG4gICAgfVxuICB9LCBwcm9wcyksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICByZWY6IGNvbnRhaW5lclJlZixcbiAgICBzdHlsZToge1xuICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgIGhlaWdodDogJzEwMCUnXG4gICAgfVxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiLCB7XG4gICAgcmVmOiBjYW52YXNSZWYsXG4gICAgc3R5bGU6IHtcbiAgICAgIGRpc3BsYXk6ICdibG9jaydcbiAgICB9XG4gIH0sIGZhbGxiYWNrKSkpO1xufSk7XG5cbi8qKlxuICogQSBET00gY2FudmFzIHdoaWNoIGFjY2VwdHMgdGhyZWVqcyBlbGVtZW50cyBhcyBjaGlsZHJlbi5cbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLnBtbmQucnMvcmVhY3QtdGhyZWUtZmliZXIvYXBpL2NhbnZhc1xuICovXG5jb25zdCBDYW52YXMgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBDYW52YXNXcmFwcGVyKHByb3BzLCByZWYpIHtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEZpYmVyUHJvdmlkZXIsIG51bGwsIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENhbnZhc0ltcGwsIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgIHJlZjogcmVmXG4gIH0pKSk7XG59KTtcblxuZXhwb3J0IHsgQ2FudmFzLCBjcmVhdGVQb2ludGVyRXZlbnRzIGFzIGV2ZW50cyB9O1xuIl0sIm5hbWVzIjpbImMiLCJjcmVhdGVFdmVudHMiLCJlIiwiZXh0ZW5kIiwidSIsInVzZU11dGFibGVDYWxsYmFjayIsImEiLCJ1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0IiwiYiIsImNyZWF0ZVJvb3QiLCJpIiwiaXNSZWYiLCJFIiwiRXJyb3JCb3VuZGFyeSIsIkIiLCJCbG9jayIsImQiLCJ1bm1vdW50Q29tcG9uZW50QXROb2RlIiwidCIsIlJlYWN0VGhyZWVGaWJlciIsInciLCJfcm9vdHMiLCJ2IiwiYWN0IiwibyIsImFkZEFmdGVyRWZmZWN0IiwibiIsImFkZEVmZmVjdCIsInAiLCJhZGRUYWlsIiwibSIsImFkdmFuY2UiLCJqIiwiYXBwbHlQcm9wcyIsImYiLCJjb250ZXh0IiwiZyIsImNyZWF0ZVBvcnRhbCIsImsiLCJkaXNwb3NlIiwicSIsImZsdXNoR2xvYmFsRWZmZWN0cyIsInMiLCJnZXRSb290U3RhdGUiLCJsIiwiaW52YWxpZGF0ZSIsImgiLCJyZWNvbmNpbGVyIiwiciIsInJlbmRlciIsIkEiLCJ1c2VGcmFtZSIsIkMiLCJ1c2VHcmFwaCIsIngiLCJ1c2VJbnN0YW5jZUhhbmRsZSIsIkQiLCJ1c2VMb2FkZXIiLCJ5IiwidXNlU3RvcmUiLCJ6IiwidXNlVGhyZWUiLCJfZXh0ZW5kcyIsIlJlYWN0IiwiVEhSRUUiLCJ1c2VNZWFzdXJlIiwiRmliZXJQcm92aWRlciIsInVzZUNvbnRleHRCcmlkZ2UiLCJET01fRVZFTlRTIiwib25DbGljayIsIm9uQ29udGV4dE1lbnUiLCJvbkRvdWJsZUNsaWNrIiwib25XaGVlbCIsIm9uUG9pbnRlckRvd24iLCJvblBvaW50ZXJVcCIsIm9uUG9pbnRlckxlYXZlIiwib25Qb2ludGVyTW92ZSIsIm9uUG9pbnRlckNhbmNlbCIsIm9uTG9zdFBvaW50ZXJDYXB0dXJlIiwiY3JlYXRlUG9pbnRlckV2ZW50cyIsInN0b3JlIiwiaGFuZGxlUG9pbnRlciIsInByaW9yaXR5IiwiZW5hYmxlZCIsImNvbXB1dGUiLCJldmVudCIsInN0YXRlIiwicHJldmlvdXMiLCJwb2ludGVyIiwic2V0Iiwib2Zmc2V0WCIsInNpemUiLCJ3aWR0aCIsIm9mZnNldFkiLCJoZWlnaHQiLCJyYXljYXN0ZXIiLCJzZXRGcm9tQ2FtZXJhIiwiY2FtZXJhIiwiY29ubmVjdGVkIiwidW5kZWZpbmVkIiwiaGFuZGxlcnMiLCJPYmplY3QiLCJrZXlzIiwicmVkdWNlIiwiYWNjIiwia2V5IiwidXBkYXRlIiwiX2ludGVybmFsJGxhc3RFdmVudCIsImV2ZW50cyIsImludGVybmFsIiwiZ2V0U3RhdGUiLCJsYXN0RXZlbnQiLCJjdXJyZW50IiwiY29ubmVjdCIsInRhcmdldCIsIl9ldmVudHMkaGFuZGxlcnMiLCJkaXNjb25uZWN0IiwiZW50cmllcyIsImZvckVhY2giLCJuYW1lIiwiZXZlbnROYW1lIiwicGFzc2l2ZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJfZXZlbnRzJGhhbmRsZXJzMiIsIkhUTUxFbGVtZW50IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIkNhbnZhc0ltcGwiLCJmb3J3YXJkUmVmIiwiQ2FudmFzIiwiY2hpbGRyZW4iLCJmYWxsYmFjayIsInJlc2l6ZSIsInN0eWxlIiwiZ2wiLCJldmVudFNvdXJjZSIsImV2ZW50UHJlZml4Iiwic2hhZG93cyIsImxpbmVhciIsImZsYXQiLCJsZWdhY3kiLCJvcnRob2dyYXBoaWMiLCJmcmFtZWxvb3AiLCJkcHIiLCJwZXJmb3JtYW5jZSIsInNjZW5lIiwib25Qb2ludGVyTWlzc2VkIiwib25DcmVhdGVkIiwicHJvcHMiLCJmb3J3YXJkZWRSZWYiLCJ1c2VNZW1vIiwiQnJpZGdlIiwiY29udGFpbmVyUmVmIiwiY29udGFpbmVyUmVjdCIsInNjcm9sbCIsImRlYm91bmNlIiwiY2FudmFzUmVmIiwidXNlUmVmIiwiZGl2UmVmIiwidXNlSW1wZXJhdGl2ZUhhbmRsZSIsImhhbmRsZVBvaW50ZXJNaXNzZWQiLCJibG9jayIsInNldEJsb2NrIiwidXNlU3RhdGUiLCJlcnJvciIsInNldEVycm9yIiwicm9vdCIsImNhbnZhcyIsImNvbmZpZ3VyZSIsImFyZ3MiLCJzZXRFdmVudHMiLCJjcmVhdGVFbGVtZW50IiwiU3VzcGVuc2UiLCJ1c2VFZmZlY3QiLCJwb2ludGVyRXZlbnRzIiwicmVmIiwicG9zaXRpb24iLCJvdmVyZmxvdyIsImRpc3BsYXkiLCJDYW52YXNXcmFwcGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/fiber/dist/react-three-fiber.esm.js\n");

/***/ })

};
;